"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._identityBase = _identityBase;
exports.identity = identity;
exports.hasIdentity = hasIdentity;
exports.hasIdentityMulti = hasIdentityMulti;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _util = require("@polkadot/util");

var _util2 = require("../util");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
const UNDEF_HEX = {
  toHex: () => undefined
};

function dataAsString(data) {
  return data.isRaw ? (0, _util.u8aToString)(data.asRaw.toU8a(true)) : data.isNone ? undefined : data.toHex();
}

function extractOther(additional) {
  return additional.reduce((other, [_key, _value]) => {
    const key = dataAsString(_key);
    const value = dataAsString(_value);

    if (key && value) {
      other[key] = value;
    }

    return other;
  }, {});
}

function extractIdentity(identityOfOpt, superOf) {
  if (!(identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome)) {
    return {
      judgements: []
    };
  }

  const {
    info,
    judgements
  } = identityOfOpt.unwrap();
  const topDisplay = dataAsString(info.display);
  return {
    display: superOf && dataAsString(superOf[1]) || topDisplay,
    displayParent: superOf && topDisplay,
    email: dataAsString(info.email),
    image: dataAsString(info.image),
    judgements,
    legal: dataAsString(info.legal),
    other: extractOther(info.additional),
    parent: superOf && superOf[0],
    pgp: info.pgpFingerprint.unwrapOr(UNDEF_HEX).toHex(),
    riot: dataAsString(info.riot),
    twitter: dataAsString(info.twitter),
    web: dataAsString(info.web)
  };
}

function getParent(api, identityOfOpt, superOfOpt) {
  if (identityOfOpt !== null && identityOfOpt !== void 0 && identityOfOpt.isSome) {
    // this identity has something set
    return (0, _rxjs.of)([identityOfOpt, undefined]);
  } else if (superOfOpt !== null && superOfOpt !== void 0 && superOfOpt.isSome) {
    const superOf = superOfOpt.unwrap(); // we have a super

    return (0, _rxjs.combineLatest)([api.query.identity.identityOf(superOf[0]), (0, _rxjs.of)(superOf)]);
  } // nothing of value returned


  return (0, _rxjs.of)([undefined, undefined]);
}

function _identityBase(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountId => {
    var _api$query$identity;

    return accountId && (_api$query$identity = api.query.identity) !== null && _api$query$identity !== void 0 && _api$query$identity.identityOf ? api.queryMulti([[api.query.identity.identityOf, accountId], [api.query.identity.superOf, accountId]]) : (0, _rxjs.of)([undefined, undefined]);
  });
}
/**
 * @name identity
 * @description Returns identity info for an account
 */


function identity(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountId => api.derive.accounts._identityBase(accountId).pipe((0, _operators.switchMap)(([identityOfOpt, superOfOpt]) => getParent(api, identityOfOpt, superOfOpt)), (0, _operators.map)(([identityOfOpt, superOf]) => extractIdentity(identityOfOpt, superOf))));
}

function hasIdentity(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountId => api.derive.accounts._identityBase(accountId).pipe((0, _operators.map)(([identityOfOpt, superOfOpt]) => {
    const parentId = superOfOpt && superOfOpt.isSome ? superOfOpt.unwrap()[0].toString() : null;
    const hasIdentity = !!parentId || !!(identityOfOpt && identityOfOpt.isSome);
    return {
      hasIdentity,
      parentId
    };
  })));
}

function hasIdentityMulti(instanceId, api) {
  return (0, _util2.memo)(instanceId, accountIds => (0, _rxjs.combineLatest)(accountIds.map(accountId => api.derive.accounts.hasIdentity(accountId))));
}