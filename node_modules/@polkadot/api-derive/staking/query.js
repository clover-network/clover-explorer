"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.query = query;
exports.queryMulti = queryMulti;

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _util = require("@polkadot/util");

var _util2 = require("../util");

// Copyright 2017-2020 @polkadot/api-derive authors & contributors
// SPDX-License-Identifier: Apache-2.0
function parseDetails(stashId, [controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure], stakingLedgerOpt) {
  const nominators = nominatorsOpt && nominatorsOpt.unwrapOr(null);
  return {
    accountId: stashId,
    controllerId: controllerIdOpt && controllerIdOpt.unwrapOr(null),
    exposure,
    nominators: nominators ? Array.isArray(nominators) ? nominators[0].targets : nominators.targets : [],
    rewardDestination,
    stakingLedger: stakingLedgerOpt.unwrapOrDefault(),
    stashId,
    validatorPrefs: Array.isArray(validatorPrefs) ? validatorPrefs[0] : validatorPrefs
  };
}

function retrievePrev(api, stashId) {
  return api.queryMulti([[api.query.staking.bonded, stashId], [api.query.staking.nominators, stashId], [api.query.staking.payee, stashId], [api.query.staking.validators, stashId], [api.query.staking.stakers, stashId]]);
}

function retrieveCurr(api, stashIds, activeEra, {
  withDestination,
  withExposure,
  withLedger,
  withNominations,
  withPrefs
}) {
  const emptyCont = api.registry.createType('Option<AccountId>');
  const emptyNoms = api.registry.createType('Option<Nominations>');
  const emptyRewa = api.registry.createType('RewardDestination');
  const emptyExpo = api.registry.createType('Exposure');
  const emptyPrefs = api.registry.createType('ValidatorPrefs');
  return (0, _rxjs.combineLatest)([withLedger ? api.query.staking.bonded.multi(stashIds) : (0, _rxjs.of)(stashIds.map(() => emptyCont)), withNominations && api.query.staking.nominators ? api.query.staking.nominators.multi(stashIds) : (0, _rxjs.of)(stashIds.map(() => emptyNoms)), withDestination ? api.query.staking.payee.multi(stashIds) : (0, _rxjs.of)(stashIds.map(() => emptyRewa)), withPrefs ? api.query.staking.validators.multi(stashIds) : (0, _rxjs.of)(stashIds.map(() => emptyPrefs)), withExposure ? api.query.staking.erasStakers.multi(stashIds.map(stashId => [activeEra, stashId])) : (0, _rxjs.of)(stashIds.map(() => emptyExpo))]).pipe((0, _operators.map)(([controllerIdOpt, nominatorsOpt, rewardDestination, validatorPrefs, exposure]) => controllerIdOpt.map((controllerIdOpt, index) => [controllerIdOpt, nominatorsOpt[index], rewardDestination[index], validatorPrefs[index], exposure[index]])));
}

function retrieveControllers(api, optControllerIds) {
  const ids = optControllerIds.filter(opt => opt.isSome).map(opt => opt.unwrap());
  const emptyLed = api.registry.createType('Option<StakingLedger>');

  if (!ids.length) {
    return (0, _rxjs.of)(optControllerIds.map(() => emptyLed));
  }

  return api.query.staking.ledger.multi(ids).pipe((0, _operators.map)(optLedgers => {
    let offset = -1;
    return optControllerIds.map(opt => opt.isSome ? optLedgers[++offset] : emptyLed);
  }));
}
/**
 * @description From a stash, retrieve the controllerId and all relevant details
 */


function query(instanceId, api) {
  return (0, _util2.memo)(instanceId, (accountId, flags) => api.derive.staking.queryMulti([accountId], flags).pipe((0, _operators.map)(([first]) => first)));
}

function queryMulti(instanceId, api) {
  return (0, _util2.memo)(instanceId, (accountIds, flags) => accountIds.length ? api.derive.session.indexes().pipe((0, _operators.switchMap)(({
    activeEra
  }) => {
    const stashIds = accountIds.map(accountId => api.registry.createType('AccountId', accountId));
    return ((0, _util.isFunction)(api.query.staking.erasStakers) ? retrieveCurr(api, stashIds, activeEra, flags) : (0, _rxjs.combineLatest)(stashIds.map(stashId => retrievePrev(api, stashId)))).pipe((0, _operators.switchMap)(results => retrieveControllers(api, results.map(([optController]) => optController)).pipe((0, _operators.map)(stakingLedgerOpts => stashIds.map((stashId, index) => parseDetails(stashId, results[index], stakingLedgerOpts[index]))))));
  })) : (0, _rxjs.of)([]));
}