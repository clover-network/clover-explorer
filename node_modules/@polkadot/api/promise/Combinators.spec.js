"use strict";

var _Combinator = require("./Combinator");

// Copyright 2017-2020 @polkadot/api authors & contributors
// SPDX-License-Identifier: Apache-2.0
describe('Combinator', () => {
  let fns = []; // eslint-disable-next-line @typescript-eslint/require-await

  const storeFn = async cb => {
    fns.push(cb);
    return () => undefined;
  };

  beforeEach(() => {
    fns = [];
  });
  it('it triggers on all values', done => {
    let count = 0;
    const combinator = new _Combinator.Combinator([storeFn], value => {
      expect(value[0]).toEqual(`test${count}`);
      count++;

      if (count === 3) {
        done();
      }
    });
    fns[0]('test0');
    fns[0]('test1');
    fns[0]('test2');
    expect(combinator).toBeDefined();
  });
  it('combines values from 2 sources, firing when it has all results', done => {
    const combinator = new _Combinator.Combinator([storeFn, storeFn], value => {
      expect(value).toEqual(['test0', 'test1']);
      done();
    });
    fns[0]('test0');
    fns[1]('test1');
    expect(combinator).toBeDefined();
  });
  it('combines values from 2 sources, allowing multiple updates', done => {
    let count = 0;
    const combinator = new _Combinator.Combinator([storeFn, storeFn], value => {
      expect(value).toEqual(count === 0 ? ['test0', 'test1'] : ['test2', 'test1']);
      count++;

      if (count === 2) {
        done();
      }
    });
    fns[0]('test0');
    fns[1]('test1');
    fns[0]('test2');
    expect(combinator).toBeDefined();
  });
  it('unsubscribes as required', done => {
    // eslint-disable-next-line @typescript-eslint/require-await
    const mocker = async () => done;

    const combinator = new _Combinator.Combinator([mocker, // eslint-disable-next-line @typescript-eslint/require-await
    async () => () => undefined // eslint-disable-next-line @typescript-eslint/no-unused-vars
    ], value => {// ignore
    });
    combinator.unsubscribe();
  });
});