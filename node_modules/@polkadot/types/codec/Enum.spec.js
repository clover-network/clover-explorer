"use strict";

var _util = require("@polkadot/util");

var _create = require("../create");

var _primitive = require("../primitive");

var _ = require(".");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
describe('Enum', () => {
  const registry = new _create.TypeRegistry();
  describe('typed enum (previously EnumType)', () => {
    it('provides a clean toString() (value)', () => {
      expect(new _.Enum(registry, {
        Text: _primitive.Text,
        U32: _primitive.U32
      }, new Uint8Array([0, 2 << 2, 49, 50])).value.toString()).toEqual('12');
    });
    it('provides a clean toString() (enum)', () => {
      expect(new _.Enum(registry, {
        Text: _primitive.Text,
        U32: _primitive.U32
      }, new Uint8Array([1, 2 << 2, 49, 50])).toString()).toEqual('{"U32":3289352}');
    });
    it('decodes from a JSON input (lowercase)', () => {
      expect(new _.Enum(registry, {
        Text: _primitive.Text,
        U32: _primitive.U32
      }, {
        text: 'some text value'
      }).value.toString()).toEqual('some text value');
    });
    it('decodes reusing instanciated inputs', () => {
      const foo = new _primitive.Text(registry, 'bar');
      expect(new _.Enum(registry, {
        foo: _primitive.Text
      }, {
        foo
      }).value).toBe(foo);
      expect(new _.Enum(registry, {
        foo: _primitive.Text
      }, foo, 0).value).toBe(foo);
      expect(new _.Enum(registry, {
        foo: _primitive.Text
      }, new _.Enum(registry, {
        foo: _primitive.Text
      }, {
        foo
      })).value).toBe(foo);
    });
    it('decodes from hex', () => {
      expect(new _.Enum(registry, {
        Text: _primitive.Text,
        U32: _primitive.U32
      }, '0x0134120000').value.toString()).toEqual('4660'); // 0x1234 in decimal
    });
    it('decodes from hex (string types)', () => {
      expect(new _.Enum(registry, // eslint-disable-next-line sort-keys
      {
        foo: 'Text',
        bar: 'u32'
      }, '0x0134120000').value.toString()).toEqual('4660'); // 0x1234 in decimal
    });
    it('decodes from a JSON input (mixed case)', () => {
      expect(new _.Enum(registry, {
        Text: _primitive.Text,
        U32: _primitive.U32
      }, {
        U32: 42
      }).value.toString()).toEqual('42');
    });
    it('decodes from JSON string', () => {
      expect(new _.Enum(registry, {
        Null: _primitive.Null,
        U32: _primitive.U32
      }, 'null').type).toEqual('Null');
    });
    it('has correct isXyz/asXyz (Enum.with)', () => {
      const test = new (_.Enum.with({
        First: _primitive.Text,
        Second: _primitive.U32,
        Third: _primitive.U32
      }))(registry, {
        Second: 42
      });
      expect(test.isSecond).toEqual(true);
      expect(test.asSecond.toNumber()).toEqual(42);
      expect(() => test.asThird).toThrow(/Cannot convert 'Second' via asThird/);
    });
    it('stringifies with custom types', () => {
      class A extends _primitive.Null {}

      class B extends _primitive.Null {}

      class C extends _primitive.Null {}

      class Test extends _.Enum {
        constructor(registry, value, index) {
          super(registry, {
            a: A,
            b: B,
            c: C
          }, value, index);
        }

      }

      expect(new Test(registry).toJSON()).toEqual({
        a: null
      });
    });
    it('creates via with', () => {
      class A extends _primitive.Null {}

      class B extends _primitive.U32 {}

      class C extends _primitive.Null {}

      const Test = _.Enum.with({
        A,
        B,
        C
      });

      expect(new Test(registry).toJSON()).toEqual({
        A: null
      });
      expect(new Test(registry, 1234, 1).toJSON()).toEqual({
        B: 1234
      });
      expect(new Test(registry, 0x1234, 1).toU8a()).toEqual(new Uint8Array([1, 0x34, 0x12, 0x00, 0x00]));
      expect(new Test(registry, 0x1234, 1).toU8a(true)).toEqual(new Uint8Array([0x34, 0x12, 0x00, 0x00]));
    });
    it('allows accessing the type and value', () => {
      const text = new _primitive.Text(registry, 'foo');
      const enumType = new _.Enum(registry, {
        Text: _primitive.Text,
        U32: _primitive.U32
      }, {
        Text: text
      });
      expect(enumType.type).toBe('Text');
      expect(enumType.value).toEqual(text);
    });
    describe('utils', () => {
      const DEF = {
        num: _primitive.U32,
        str: _primitive.Text
      };
      const u8a = new Uint8Array([1, 3 << 2, 88, 89, 90]);
      const test = new _.Enum(registry, DEF, u8a);
      it('compares against index', () => {
        expect(test.eq(1)).toBe(true);
      });
      it('compares against u8a', () => {
        expect(test.eq(u8a)).toBe(true);
      });
      it('compares against hex', () => {
        expect(test.eq((0, _util.u8aToHex)(u8a))).toBe(true);
      });
      it('compares against another enum', () => {
        expect(test.eq(new _.Enum(registry, DEF, u8a))).toBe(true);
      });
      it('compares against another object', () => {
        expect(test.eq({
          str: 'XYZ'
        })).toBe(true);
      });
      it('compares against values', () => {
        expect(test.eq('XYZ')).toBe(true);
      });
      it('compares basic enum on string', () => {
        expect(new _.Enum(registry, ['A', 'B', 'C'], 1).eq('B')).toBe(true);
      });
    });
  });
  describe('string-only construction (old Enum)', () => {
    const testDecode = (type, input, expected) => it(`can decode from ${type}`, () => {
      const e = new _.Enum(registry, ['foo', 'bar'], input);
      expect(e.toString()).toBe(expected);
    });

    const testEncode = (to, expected) => it(`can encode ${to}`, () => {
      const e = new _.Enum(registry, ['Foo', 'Bar'], 1);
      expect(e[to]()).toEqual(expected);
    });

    testDecode('Enum', undefined, 'foo');
    testDecode('Enum', new _.Enum(registry, ['foo', 'bar'], 1), 'bar');
    testDecode('number', 0, 'foo');
    testDecode('number', 1, 'bar');
    testDecode('string', 'bar', 'bar');
    testDecode('Uint8Array', Uint8Array.from([0]), 'foo');
    testDecode('Uint8Array', Uint8Array.from([1]), 'bar');
    testEncode('toJSON', 'Bar');
    testEncode('toNumber', 1);
    testEncode('toString', 'Bar');
    testEncode('toU8a', Uint8Array.from([1]));
    it('provides a clean toString()', () => {
      expect(new _.Enum(registry, ['foo', 'bar']).toString()).toEqual('foo');
    });
    it('provides a clean toString() (enum)', () => {
      expect(new _.Enum(registry, ['foo', 'bar'], new _.Enum(registry, ['foo', 'bar'], 1)).toNumber()).toEqual(1);
    });
    it('converts to and from Uint8Array', () => {
      expect(new _.Enum(registry, ['foo', 'bar'], new Uint8Array([1])).toU8a()).toEqual(new Uint8Array([1]));
    });
    it('converts from JSON', () => {
      expect(new _.Enum(registry, ['foo', 'bar', 'baz', 'gaz', 'jaz'], 4).toNumber()).toEqual(4);
    });
    it('has correct isXyz getters (Enum.with)', () => {
      const test = new (_.Enum.with(['First', 'Second', 'Third']))(registry, 'Second');
      expect(test.isSecond).toEqual(true);
    });
    describe('utils', () => {
      it('compares against the index value', () => {
        expect(new _.Enum(registry, ['foo', 'bar'], 1).eq(1)).toBe(true);
      });
      it('compares against the index value (false)', () => {
        expect(new _.Enum(registry, ['foo', 'bar'], 1).eq(0)).toBe(false);
      });
      it('compares against the string value', () => {
        expect(new _.Enum(registry, ['foo', 'bar'], 1).eq('bar')).toBe(true);
      });
      it('compares against the string value (false)', () => {
        expect(new _.Enum(registry, ['foo', 'bar'], 1).eq('foo')).toBe(false);
      });
      it('has isNone set, with correct index (i.e. no values are used)', () => {
        const test = new _.Enum(registry, ['foo', 'bar'], 1);
        expect(test.isNone).toBe(true);
        expect(test.index).toEqual(1);
      });
    });
  });
  describe('index construction', () => {
    it('creates enum where index is specified', () => {
      const Test = _.Enum.with({
        A: _primitive.U32,
        B: _primitive.U32
      });

      const test = new Test(registry, new _primitive.U32(registry, 123), 1);
      expect(test.type).toEqual('B');
      expect(test.value.toNumber()).toEqual(123);
    });
    it('creates enum when value is an enum', () => {
      const Test = _.Enum.with({
        A: _primitive.U32,
        B: _primitive.U32
      });

      const test = new Test(registry, new Test(registry, 123, 1));
      expect(test.type).toEqual('B');
      expect(test.value.toNumber()).toEqual(123);
    });
    it('creates via enum with nested enums as the value', () => {
      const Nest = _.Enum.with({
        C: _primitive.U32,
        D: _primitive.U32
      });

      const Test = _.Enum.with({
        A: _primitive.U32,
        B: Nest
      });

      const test = new Test(registry, new Nest(registry, 123, 1), 1);
      expect(test.type).toEqual('B');
      expect(test.value.type).toEqual('D');
      expect(test.value.value.toNumber()).toEqual(123);
    });
  });
  describe('toRawType', () => {
    it('has a sane output for basic enums', () => {
      expect(new _.Enum(registry, ['foo', 'bar']).toRawType()).toEqual(JSON.stringify({
        _enum: ['foo', 'bar']
      }));
    });
    it('has a sane output for typed enums', () => {
      expect( // eslint-disable-next-line sort-keys
      new _.Enum(registry, {
        foo: _primitive.Text,
        bar: _primitive.U32
      }).toRawType() // eslint-disable-next-line sort-keys
      ).toEqual(JSON.stringify({
        _enum: {
          foo: 'Text',
          bar: 'u32'
        }
      }));
    });
    it('re-creates via rawType (c-like)', () => {
      const type = new _.Enum(registry, ['foo', 'bar']).toRawType();
      expect(registry.createType(type, 1).toString()).toEqual('bar');
    });
    it('re-creates via rawType (types)', () => {
      const type = new _.Enum(registry, {
        A: _primitive.Text,
        B: _primitive.U32,
        C: _primitive.U32
      }).toRawType();
      const value = registry.createType(type, {
        B: 123
      });
      expect(value.isB).toEqual(true);
      expect(value.asB.toNumber()).toEqual(123);
    });
  });
  describe('toHex', () => {
    it('has a proper hex representation & length', () => {
      const Test = _.Enum.with({
        A: _primitive.Text,
        B: _primitive.U32
      });

      const test = new Test(registry, 123, 1);
      expect(test.toHex()).toEqual('0x017b000000');
      expect(test.encodedLength).toEqual(1 + 4);
    });
    it('encodes a single entry correctly', () => {
      const Test = _.Enum.with({
        A: 'u32'
      });

      const test = new Test(registry, 0x44332211, 0);
      expect(test.toHex()).toEqual('0x' + '00' + // index
      '11223344' // u32 LE encoded
      );
    });
    it('encodes a single entry correctly (with embedded encoding)', () => {
      const Test = _.Enum.with({
        A: 'Address'
      });

      const test = new Test(registry, registry.createType('AccountId', '0x0001020304050607080910111213141516171819202122232425262728293031'), 0);
      expect(test.toHex()).toEqual('0x' + '00' + // index
      'ff' + // Address indicating an embedded AccountId
      '0001020304050607080910111213141516171819202122232425262728293031' // AccountId
      );
    });
  });
});