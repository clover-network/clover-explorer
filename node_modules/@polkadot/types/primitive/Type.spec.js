"use strict";

var _util = require("@polkadot/util");

var _create = require("../create");

var _ = require(".");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
describe('Type', () => {
  const registry = new _create.TypeRegistry();
  it('fails to cleanup invalid boxes', () => {
    expect(() => new _.Type(registry, 'Box<Proposal')).toThrow(/find closing matching/);
  });
  it('cleans up tuples with a single value', () => {
    expect(new _.Type(registry, '(AccountId)').toString()).toEqual('AccountId');
  });
  it('does not touch tuples with multiple values', () => {
    expect(new _.Type(registry, '(AccountId, Balance)').toString()).toEqual('(AccountId,Balance)');
  });
  it('handles nested types', () => {
    expect(new _.Type(registry, 'Box<Vec<AccountId>>').toString()).toEqual('Vec<AccountId>');
  });
  it('handles nested types (embedded)', () => {
    expect(new _.Type(registry, '(u32, Box<Vec<AccountId>>)').toString()).toEqual('(u32,Vec<AccountId>)');
  });
  it('handles aliasses, multiples per line', () => {
    expect(new _.Type(registry, '(Vec<u8>, AccountId, Vec<u8>)').toString()).toEqual('(Bytes,AccountId,Bytes)');
  });
  it('removes whitespaces', () => {
    expect(new _.Type(registry, 'T :: AccountId').toString()).toEqual('AccountId');
  });
  it('changes PairOf<T> -> (T, T)', () => {
    expect(new _.Type(registry, 'PairOf<T::Balance>').toString()).toEqual('(Balance,Balance)');
  });
  it('changes PairOf<T> (embedded) -> (T, T)', () => {
    expect(new _.Type(registry, '(Vec<u8>, PairOf<T::Balance>, Vec<AccountId>)').toString()).toEqual('(Bytes,(Balance,Balance),Vec<AccountId>)');
  });
  it('changes () -> ()', () => {
    expect(new _.Type(registry, '()').toString()).toEqual('()');
  });
  it('has the sanitized', () => {
    expect(new _.Type(registry, new _.Text(registry, ' Box<Proposal> ')).toString()).toEqual('Proposal'); // eslint-disable-line
  });
  it('unwraps compact', () => {
    expect(new _.Type(registry, '<T::Balance as HasCompact>::Type').toString()).toEqual('Compact<Balance>');
  });
  it('handles InherentOfflineReport', () => {
    expect(new _.Type(registry, '<T::InherentOfflineReport as InherentOfflineReport>::Inherent').toString()).toEqual('InherentOfflineReport');
  });
  it('encodes correctly via toU8a()', () => {
    const type = 'Compact<Balance>';
    expect(new _.Text(registry, type).toU8a()).toEqual((0, _util.u8aConcat)(new Uint8Array([type.length << 2]), (0, _util.stringToU8a)(type)));
  });
  it('creates a decodable U8a for sanitized types', () => {
    const original = '<T::InherentOfflineReport as InherentOfflineReport>::Inherent';
    const expected = 'InherentOfflineReport';
    const u8a = new _.Type(registry, original).toU8a();
    const decoded = new _.Type(registry, u8a);
    expect(decoded.encodedLength).toEqual(original.length + 1); // extra byte for length

    expect(decoded.toString()).toEqual(expected);
  });
  it('has the correct raw', () => {
    expect(new _.Type(registry).toRawType()).toEqual('Type');
  });
});