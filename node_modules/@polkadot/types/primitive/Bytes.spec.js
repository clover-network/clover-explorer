"use strict";

var _create = require("../create");

var _ = require(".");

// Copyright 2017-2020 @polkadot/types authors & contributors
// SPDX-License-Identifier: Apache-2.0
describe('Bytes', () => {
  const registry = new _create.TypeRegistry();
  const NUM = [0x3a, 0x63, 0x6f, 0x64, 0x65];
  const U8A = new Uint8Array([0x14, ...NUM]);
  const HEX = '0x3a636f6465';
  describe('construction', () => {
    it('decodes when input is string', () => {
      expect(new _.Bytes(registry, ':code').toU8a()).toEqual(U8A);
    });
    it('decodes when hex is not length prefixed', () => {
      expect(new _.Bytes(registry, HEX).toU8a()).toEqual(U8A);
    });
    it('decodes from UInt8Array', () => {
      expect(new _.Bytes(registry, U8A).toU8a()).toEqual(U8A);
    });
    it('decodes from number[]', () => {
      expect(new _.Bytes(registry, NUM).toU8a()).toEqual(U8A);
    });
    it('creates via storagedata (no prefix)', () => {
      expect(new _.Bytes(registry, registry.createType('StorageData', HEX)).toU8a()).toEqual(U8A);
    });
    it('encodes from itself', () => {
      expect(new _.Bytes(registry, new _.Bytes(registry, HEX)).toU8a()).toEqual(U8A);
    });
    it('strips length with toU8a(true)', () => {
      expect(new _.Bytes(registry, HEX).toU8a(true)).toEqual(U8A.subarray(1));
    });
    it('strips length with toHex', () => {
      expect(new _.Bytes(registry, HEX).toHex()).toEqual(HEX);
    });
  });
});