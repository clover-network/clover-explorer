"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.format = format;
exports.logger = logger;

var _formatDate = require("./format/formatDate");

var _bn = require("./is/bn");

var _function = require("./is/function");

var _object = require("./is/object");

var _u8a = require("./is/u8a");

var _toHex = require("./u8a/toHex");

var _toU8a = require("./u8a/toU8a");

var _is = require("./is");

// Copyright 2017-2020 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0
const logTo = {
  debug: 'log',
  error: 'error',
  log: 'log',
  warn: 'warn'
};

function formatOther(value) {
  if (value && (0, _object.isObject)(value) && value.constructor === Object) {
    return Object.keys(value).reduce((result, key) => {
      result[key] = format(value[key]);
      return result;
    }, {});
  }

  return value;
}

function format(value) {
  if (Array.isArray(value)) {
    return value.map(format);
  } else if ((0, _bn.isBn)(value)) {
    return value.toString();
  } else if ((0, _u8a.isU8a)(value) || (0, _is.isBuffer)(value)) {
    return (0, _toHex.u8aToHex)((0, _toU8a.u8aToU8a)(value));
  }

  return formatOther(value);
}

function apply(log, type, values) {
  if (values.length === 1 && (0, _function.isFunction)(values[0])) {
    const fnResult = values[0]();
    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult]);
  }

  console[logTo[log]]((0, _formatDate.formatDate)(new Date()), type, ...values.map(format));
}

function noop() {// noop
}
/**
 * @name Logger
 * @summary Creates a consistent log interface for messages
 * @description
 * Returns a `Logger` that has `.log`, `.error`, `.warn` and `.debug` (controlled with environment `DEBUG=typeA,typeB`) methods. Logging is done with a consistent prefix (type of logger, date) followed by the actual message using the underlying console.
 * @example
 * <BR>
 *
 * ```javascript
 * const l from '@polkadot/util/logger')('test');
 *
 * l.log('blah'); // <date>     TEST: blah
 * ```
 */


function logger(_type) {
  const type = `${_type.toUpperCase()}:`.padStart(16);
  let isDebug;

  try {
    const isTest = process.env.NODE_ENV === 'test';
    const debugList = (process.env.DEBUG || '').split(',');
    isDebug = isTest || !!debugList.find(entry => _type.startsWith(entry));
  } catch (error) {
    isDebug = false;
  }

  return {
    debug: isDebug ? (...values) => apply('debug', type, values) : noop,
    error: (...values) => apply('error', type, values),
    log: (...values) => apply('log', type, values),
    noop,
    warn: (...values) => apply('warn', type, values)
  };
}