import { __assign } from "tslib";
import { deepMix } from '@antv/util';
import Button from './timeButton';
var DEFAULT_RECT_FILL = '#ccc';
var DEFAULT_RECT_STROKE = 'green';
var DEFAULT_PLAYBTN_STYLE = {
  fill: '#607889',
  stroke: '#607889'
};
var DEFAULT_PREBTN_STYLE = {
  fill: '#fff'
};
var DEFAULT_NEXTBTN_STYLE = {
  fill: 'green'
};
var DEFAULT_CONTROLLER_CONFIG = {
  speed: 2,
  loop: false,
  fill: '#fff',
  stroke: '#fff',
  hiddleToggle: false,
  preBtnStyle: {
    fill: '#ccc',
    stroke: '#ccc'
  },
  nextBtnStyle: {
    fill: '#ccc',
    stroke: '#ccc'
  },
  playBtnStyle: {
    fill: '#fff',
    stroke: '#ccc'
  }
};
var SPEED_CONTROLLER_OFFSET = 110;
var TOGGLE_MODEL_OFFSET = 50;

var ControllerBtn =
/** @class */
function () {
  function ControllerBtn(cfg) {
    this.controllerCfg = deepMix({}, DEFAULT_CONTROLLER_CONFIG, cfg);
    this.group = cfg.group;
    this.speedAxisY = [];
    this.currentSpeed = this.controllerCfg.speed;
    this.currentType = 'range';
    this.init();
  }

  ControllerBtn.prototype.init = function () {
    this.renderPlayButton();
  };
  /** 获取播放键 marker path */


  ControllerBtn.prototype.getNextMarkerPath = function (x, y, len) {
    return [['M', x, y - len], ['L', x + len, y], ['L', x, y + len]];
  };

  ControllerBtn.prototype.getPreMarkerPath = function (x, y, len) {
    return [['M', x, y - len], ['L', x - len, y], ['L', x, y + len]];
  };

  ControllerBtn.prototype.renderPlayButton = function () {
    var controllerCfg = this.controllerCfg;
    var width = controllerCfg.width,
        height = controllerCfg.height,
        x = controllerCfg.x,
        y = controllerCfg.y,
        hiddleToggle = controllerCfg.hiddleToggle,
        _a = controllerCfg.fill,
        fill = _a === void 0 ? DEFAULT_RECT_FILL : _a,
        _b = controllerCfg.stroke,
        stroke = _b === void 0 ? DEFAULT_RECT_STROKE : _b,
        _c = controllerCfg.playBtnStyle,
        playBtnStyle = _c === void 0 ? DEFAULT_PLAYBTN_STYLE : _c,
        _d = controllerCfg.preBtnStyle,
        preBtnStyle = _d === void 0 ? DEFAULT_PREBTN_STYLE : _d,
        _e = controllerCfg.nextBtnStyle,
        nextBtnStyle = _e === void 0 ? DEFAULT_NEXTBTN_STYLE : _e;
    var r = height / 2 - 5;
    var realY = y + 10; // 绘制最外层的矩形包围框

    var container = this.group.addShape('rect', {
      attrs: {
        x: x,
        y: realY,
        width: width,
        height: height,
        stroke: stroke,
        fill: fill
      },
      name: 'container-rect'
    });

    if (this.playButton) {
      this.playButton.update({
        x: width / 2,
        y: realY,
        r: r
      });
    } else {
      this.playButton = new Button({
        group: this.group,
        x: width / 2,
        y: realY + r + 5,
        r: r,
        isPlay: this.isPlay,
        style: playBtnStyle
      });
    } // 后退按钮


    this.group.addShape('path', {
      attrs: __assign({
        path: this.getPreMarkerPath(width / 2 - 5 * r, realY + r + 5, r * 0.5)
      }, preBtnStyle),
      name: 'preStepBtn'
    });
    this.group.addShape('path', {
      attrs: __assign({
        path: this.getPreMarkerPath(width / 2 - 4.5 * r, realY + r + 5, r * 0.5)
      }, preBtnStyle),
      name: 'preStepBtn'
    }); // 前进按钮

    this.group.addShape('path', {
      attrs: __assign({
        path: this.getNextMarkerPath(width / 2 + 5 * r, realY + r + 5, r * 0.5)
      }, nextBtnStyle),
      name: 'nextStepBtn'
    });
    this.group.addShape('path', {
      attrs: __assign({
        path: this.getNextMarkerPath(width / 2 + 4.5 * r, realY + r + 5, r * 0.5)
      }, nextBtnStyle),
      name: 'nextStepBtn'
    });
    container.toBack(); // 调节speed的按钮

    this.renderSpeedBtn();

    if (!hiddleToggle) {
      this.renderToggleTime();
    }

    this.bindEvent();
  };

  ControllerBtn.prototype.renderSpeedBtn = function () {
    var _a = this.controllerCfg,
        y = _a.y,
        width = _a.width,
        hiddleToggle = _a.hiddleToggle;
    var speedGroup = this.group.addGroup({
      name: 'speed-group'
    });
    this.speedGroup = speedGroup;
    var count = 1;
    var speedNum = [];
    var maxSpeed = 9; // 增加speed刻度

    for (var i = 0; i < 5; i++) {
      var axisY = y + 15 + i * (i + 1) + count; // 灰色刻度

      speedGroup.addShape('rect', {
        attrs: {
          x: width - (!hiddleToggle ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET),
          y: axisY,
          width: 15,
          height: 2,
          fill: '#ccc'
        },
        speed: maxSpeed,
        name: 'speed-rect'
      });
      this.speedAxisY.push(axisY);
      speedNum.push(maxSpeed);
      maxSpeed = maxSpeed - 2;
      count++;
    }

    for (var i = 0; i < 4; i++) {
      // 灰色刻度
      speedGroup.addShape('rect', {
        attrs: {
          x: width - (!hiddleToggle ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET),
          y: this.speedAxisY[i] + 2,
          width: 15,
          height: 2 * i + 1,
          fill: '#fff',
          opacity: 0.3
        },
        speed: speedNum[i] - 1,
        name: 'speed-rect'
      });
    } // 速度文本


    this.speedText = speedGroup.addShape('text', {
      attrs: {
        x: width - (!hiddleToggle ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET) + 20,
        y: this.speedAxisY[1] + 15,
        text: "1.0X",
        fill: '#ccc'
      }
    });
    this.speedPoint = speedGroup.addShape('path', {
      attrs: {
        path: this.getPath(width - (!hiddleToggle ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET), this.speedAxisY[4]),
        fill: '#ccc'
      }
    });
  };

  ControllerBtn.prototype.getPath = function (x, y) {
    return [['M', x, y], ['L', x - 12, y - 6], ['L', x - 12, y + 6], ['Z']];
  };

  ControllerBtn.prototype.renderToggleTime = function () {
    var width = this.controllerCfg.width;
    this.toggleGroup = this.group.addGroup({
      name: 'toggle-group'
    });
    this.toggleGroup.addShape('rect', {
      attrs: {
        width: 14,
        height: 14,
        x: width - TOGGLE_MODEL_OFFSET,
        y: this.speedAxisY[1],
        fill: '#fff',
        stroke: '#ccc',
        lineWidth: 2,
        radius: 3
      },
      isChecked: false,
      name: 'toggle-model'
    });
    this.checkedIcon = this.toggleGroup.addShape('path', {
      attrs: {
        path: [['M', width - TOGGLE_MODEL_OFFSET + 3, this.speedAxisY[1] + 6], ['L', width - TOGGLE_MODEL_OFFSET + 7, this.speedAxisY[1] + 10], ['L', width - TOGGLE_MODEL_OFFSET + 12, this.speedAxisY[1] + 4]],
        stroke: 'green',
        lineWidth: 3
      },
      capture: false
    });
    this.checkedIcon.hide();
    this.checkedText = this.toggleGroup.addShape('text', {
      attrs: {
        text: '单一时间',
        x: width - TOGGLE_MODEL_OFFSET + 20,
        y: this.speedAxisY[1] + 15,
        fill: '#ccc'
      }
    });
  };

  ControllerBtn.prototype.bindEvent = function () {
    var _this = this;

    var _a = this.controllerCfg,
        width = _a.width,
        hiddleToggle = _a.hiddleToggle;
    this.speedGroup.on('speed-rect:click', function (evt) {
      _this.speedPoint.attr('path', _this.getPath(width - (!hiddleToggle ? SPEED_CONTROLLER_OFFSET : TOGGLE_MODEL_OFFSET), evt.y));

      _this.currentSpeed = evt.target.get('speed');

      _this.speedText.attr('text', _this.currentSpeed + ".0X");

      _this.group.emit('timebarConfigChanged', {
        speed: _this.currentSpeed,
        type: _this.currentType
      });
    });

    if (this.toggleGroup) {
      this.toggleGroup.on('toggle-model:click', function (evt) {
        var isChecked = evt.target.get('isChecked');

        if (!isChecked) {
          _this.checkedIcon.show();

          _this.checkedText.attr('text', '时间范围');

          _this.currentType = 'single';
        } else {
          _this.checkedIcon.hide();

          _this.checkedText.attr('text', '单一时间');

          _this.currentType = 'range';
        }

        evt.target.set('isChecked', !isChecked);

        _this.group.emit('timebarConfigChanged', {
          type: _this.currentType,
          speed: _this.currentSpeed
        });
      });
    }
  };

  ControllerBtn.prototype.destroy = function () {
    this.speedGroup.off('speed-rect:click');

    if (this.toggleGroup) {
      this.toggleGroup.off('toggle-model:click');
      this.toggleGroup.destroy();
    }

    this.speedGroup.destroy();
  };

  return ControllerBtn;
}();

export default ControllerBtn;