import * as MathUtil from './math';
import * as GraphicUtil from './graphic';
import mix from '@antv/util/lib/mix';
declare const Util: {
    mixColor: (backColor: any, frontColor: any, frontAlpha: any) => any;
    getColorsWithSubjectColor: (subjectColor: any, backColor?: string, theme?: "default" | "dark", disableColor?: string) => {
        mainStroke: any;
        mainFill: any;
        activeStroke: any;
        activeFill: any;
        inactiveStroke: any;
        inactiveFill: any;
        selectedStroke: any;
        selectedFill: string;
        highlightStroke: any;
        highlightFill: any;
        disableStroke: any;
        disableFill: any;
        edgeMainStroke: any;
        edgeActiveStroke: any;
        edgeInactiveStroke: any;
        edgeSelectedStroke: any;
        edgeHighlightStroke: any;
        edgeDisableStroke: any;
        comboMainStroke: any;
        comboMainFill: any;
        comboActiveStroke: any;
        comboActiveFill: any;
        comboInactiveStroke: any;
        comboInactiveFill: any;
        comboSelectedStroke: any;
        comboSelectedFill: any;
        comboHighlightStroke: any;
        comboHighlightFill: any;
        comboDisableStroke: any;
        comboDisableFill: any;
    };
    getLineIntersect: (p0: import("@antv/g-base").Point, p1: import("@antv/g-base").Point, p2: import("@antv/g-base").Point, p3: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    getRectIntersectByPoint: (rect: import("../types").IRect, point: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    getCircleIntersectByPoint: (circle: import("../types").ICircle, point: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    getEllipseIntersectByPoint: (ellipse: import("../types").IEllipse, point: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    applyMatrix: (point: import("@antv/g-base").Point, matrix: import("../types").Matrix, tag?: 0 | 1) => import("@antv/g-base").Point;
    invertMatrix: (point: import("@antv/g-base").Point, matrix: import("../types").Matrix, tag?: 0 | 1) => import("@antv/g-base").Point;
    getCircleCenterByPoints: (p1: import("@antv/g-base").Point, p2: import("@antv/g-base").Point, p3: import("@antv/g-base").Point) => import("@antv/g-base").Point;
    distance: (p1: import("@antv/g-base").Point, p2: import("@antv/g-base").Point) => number;
    scaleMatrix: (matrix: import("../types").Matrix[], ratio: number) => import("../types").Matrix[];
    floydWarshall: (adjMatrix: import("../types").Matrix[]) => import("../types").Matrix[];
    getAdjMatrix: (data: import("../types").GraphData, directed: boolean) => import("../types").Matrix[];
    translate: (group: import("@antv/g-base").IGroup, vec: import("@antv/g-base").Point) => void;
    move: (group: import("@antv/g-base").IGroup, point: import("@antv/g-base").Point) => void;
    scale: (group: import("@antv/g-base").IGroup, ratio: number | number[]) => void;
    rotate: (group: import("@antv/g-base").IGroup, angle: number) => void;
    getDegree: (n: number, nodeIdxMap: import("../types").NodeIdxMap, edges: import("../types").EdgeConfig[]) => number[];
    isPointInPolygon: (points: number[][], x: number, y: number) => boolean;
    intersectBBox: (box1: Partial<import("../types").IBBox>, box2: Partial<import("../types").IBBox>) => boolean;
    isPolygonsIntersect: (points1: number[][], points2: number[][]) => boolean;
    Line: typeof MathUtil.Line;
    getBBoxBoundLine: (bbox: import("../types").IBBox, direction: string) => any;
    itemIntersectByLine: (item: import("../types").Item, line: MathUtil.Line) => [import("../types").IPoint[], number];
    fractionToLine: (item: import("../types").Item, line: MathUtil.Line) => number;
    getPointsCenter: (points: import("../types").IPoint[]) => import("../types").IPoint;
    squareDist: (a: import("../types").IPoint, b: import("../types").IPoint) => number;
    pointLineSquareDist: (point: import("../types").IPoint, line: MathUtil.Line) => number;
    isPointsOverlap: (p1: any, p2: any, e?: number) => boolean;
    pointRectSquareDist: (point: import("@antv/g-base").Point, rect: import("../types").IRect) => number;
    roundedHull(polyPoints: number[][], padding: number): string;
    paddedHull(polyPoints: number[][], padding: number): string | {
        x: number;
        y: number;
    }[];
    getSpline: (points: import("../types").IPoint[]) => any[][];
    getControlPoint: (startPoint: import("../types").IPoint, endPoint: import("../types").IPoint, percent?: number, offset?: number) => import("../types").IPoint;
    pointsToPolygon: (points: import("../types").IPoint[], z?: boolean) => string;
    pathToPoints: (path: any[]) => any[];
    getClosedSpline: (points: import("../types").IPoint[]) => any[];
    getBBox: (element: import("../types").IShapeBase, group: import("@antv/g-canvas/lib/group").default) => import("../types").IBBox;
    getLoopCfgs: (cfg: import("../types").EdgeData) => import("../types").EdgeData;
    getLabelPosition: (pathShape: import("@antv/g-canvas/lib/shape/path").default, percent: number, refX: number, refY: number, rotate: boolean) => Partial<{
        rotate: number;
        textAlign: string;
        angle: number;
        x: number;
        y: number;
        text: string;
        stroke: string;
        opacity: number;
        fontSize: number;
        fontStyle: string;
        fill: string;
        rotateCenter: string;
        lineWidth?: number;
        shadowColor?: string;
        shadowBlur?: number;
        shadowOffsetX?: number;
        shadowOffsetY?: number;
        position: string;
        textBaseline: string;
        offset: number;
        background?: {
            fill?: string;
            stroke?: string;
            lineWidth?: number;
            radius?: number | number[];
            padding?: number | number[];
        };
    }>;
    traverseTree: <T extends {
        children?: T[];
    }>(data: T, fn: (param: T) => boolean) => void;
    traverseTreeUp: <T_1 extends {
        children?: T_1[];
    }>(data: T_1, fn: (param: T_1) => boolean) => void;
    radialLayout: (data: GraphicUtil.TreeGraphDataWithPosition, layout?: string) => GraphicUtil.TreeGraphDataWithPosition;
    getLetterWidth: (letter: any, fontSize: any) => number;
    getTextSize: (text: any, fontSize: any) => any[];
    plainCombosToTrees: (array: import("../types").ComboConfig[], nodes?: import("../types").NodeConfig[]) => import("../types").ComboTree[];
    reconstructTree: (trees: import("../types").ComboTree[], subtreeId?: string, newParentId?: string) => import("../types").ComboTree[];
    getComboBBox: (children: import("../types").ComboTree[], graph: import("../interface/graph").IGraph) => import("@antv/g-math/lib/types").BBox;
    getChartRegion: (params: {
        group: import("@antv/g-canvas/lib/group").default;
        width: number;
        height: number;
        x: number;
        y: number;
    }) => {
        start: {
            x: number;
            y: number;
        };
        end: {
            x: number;
            y: number;
        };
    };
    formatPadding: (padding: import("../types").Padding) => number[];
    cloneEvent: (e: import("../types").IG6GraphEvent) => import("../interface/behavior").G6GraphEvent;
    isViewportChanged: (matrix: import("../types").Matrix) => boolean;
    isNaN: (input: any) => boolean;
    calculationItemsBBox: (items: import("../types").Item[]) => {
        x: number;
        y: number;
        width: number;
        height: number;
        minX: number;
        minY: number;
        maxX: number;
        maxY: number;
    };
    processParallelEdges: (edges: any, offsetDiff?: number) => any;
    mat3: any;
    mix: typeof mix;
    deepMix: (rst: any, ...args: any[]) => any;
    transform: (m: any, ts: any) => any;
};
export default Util;
