var dijkstra = function dijkstra(graph, source, directed, weightPropertyName) {
  var nodes = graph.getNodes();
  var nodeIds = [];
  var marks = {};
  var D = {};
  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）

  nodes.forEach(function (node, i) {
    var id = node.getID();
    nodeIds.push(id);
    D[id] = Infinity;
    if (id === source) D[id] = 0;
  });
  var nodeNum = nodes.length;

  var _loop_1 = function _loop_1(i) {
    // Process the vertices
    var minNode = minVertex(D, nodes, marks);
    var minNodId = minNode.get('id');
    marks[minNodId] = true;
    if (D[minNodId] === Infinity) return "continue"; // Unreachable vertices cannot be the intermediate point

    var relatedEdges = [];
    if (directed) relatedEdges = minNode.getOutEdges();else relatedEdges = minNode.getEdges();
    relatedEdges.forEach(function (e) {
      var edgeTarget = e.getTarget().getID();
      var edgeSource = e.getSource().getID();
      var w = edgeTarget === minNodId ? edgeSource : edgeTarget;
      var weight = weightPropertyName && e.getModel()[weightPropertyName] ? e.getModel()[weightPropertyName] : 1;

      if (D[w] > D[minNode.get('id')] + weight) {
        D[w] = D[minNode.get('id')] + weight;
        prevs[w] = minNode.get('id');
      }
    });
  };

  for (var i = 0; i < nodeNum; i++) {
    _loop_1(i);
  }

  var path = {};

  for (var target in D) {
    path[target] = [target];
    var prev = prevs[target];

    while (prev !== undefined) {
      path[target].unshift(prev);
      prev = prevs[prev];
    }
  }

  return {
    length: D,
    path: path
  };
};

function minVertex(D, nodes, marks) {
  // 找出最小的点
  var minDis = Infinity;
  var minNode;

  for (var i = 0; i < nodes.length; i++) {
    var nodeId = nodes[i].get('id');

    if (!marks[nodeId] && D[nodeId] <= minDis) {
      minDis = D[nodeId];
      minNode = nodes[i];
    }
  }

  return minNode;
}

export default dijkstra;