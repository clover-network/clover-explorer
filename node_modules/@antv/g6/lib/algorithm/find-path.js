"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.findAllPath = exports.findShortestPath = void 0;

var _util = require("@antv/util");

var _dijkstra = _interopRequireDefault(require("./dijkstra"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var findShortestPath = function findShortestPath(graph, start, end, directed, weightPropertyName) {
  if ((0, _util.isString)(start)) start = graph.findById(start);
  if ((0, _util.isString)(end)) end = graph.findById(end);

  var _a = (0, _dijkstra.default)(graph, start.get('id'), directed, weightPropertyName),
      length = _a.length,
      path = _a.path;

  return {
    length: length[end.get('id')],
    path: path[end.get('id')]
  };
};

exports.findShortestPath = findShortestPath;

var findAllPath = function findAllPath(graph, start, end, directed) {
  var _a;

  if ((0, _util.isString)(start)) start = graph.findById(start);
  if ((0, _util.isString)(end)) end = graph.findById(end);
  if (directed === undefined) directed = graph.get('directed');
  if (start === end) return [[start.get('id')]];
  var visited = [start];
  var isVisited = (_a = {}, _a[start.get('id')] = true, _a);
  var stack = []; // 辅助栈，用于存储访问过的节点的邻居节点

  var allPaths = [];
  var neighbors = directed ? start.getNeighbors('target') : start.getNeighbors();
  stack.push(neighbors);

  while (visited.length > 0 && stack.length > 0) {
    var children = stack[stack.length - 1];

    if (children.length) {
      var child = children.shift();

      if (child) {
        visited.push(child);
        isVisited[child.get('id')] = true;
        neighbors = directed ? child.getNeighbors('target') : child.getNeighbors();
        stack.push(neighbors.filter(function (neighbor) {
          return !isVisited[neighbor.get('id')];
        }));
      }
    } else {
      var node = visited.pop();
      isVisited[node.get('id')] = false;
      stack.pop();
      continue;
    }

    if (visited[visited.length - 1] === end) {
      var path = visited.map(function (node) {
        return node.get('id');
      });
      allPaths.push(path);
      var node = visited.pop();
      isVisited[node.get('id')] = false;
      stack.pop();
    }
  }

  return allPaths;
};

exports.findAllPath = findAllPath;