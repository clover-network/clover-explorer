"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _tslib = require("tslib");

var _canvas = _interopRequireDefault(require("@antv/g-canvas/lib/canvas"));

var _canvas2 = _interopRequireDefault(require("@antv/g-svg/lib/canvas"));

var _createDom = _interopRequireDefault(require("@antv/dom-util/lib/create-dom"));

var _modifyCss = _interopRequireDefault(require("@antv/dom-util/lib/modify-css"));

var _base = _interopRequireDefault(require("../base"));

var _trendTimeBar = _interopRequireDefault(require("./trendTimeBar"));

var _timeBarSlice = _interopRequireDefault(require("./timeBarSlice"));

var _constant = require("./constant");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * 基于 G 的时间轴组件
 */
// simple 版本默认高度
var DEFAULT_SIMPLE_HEIGHT = 8; // trend 版本默认高度

var DEFAULT_TREND_HEIGHT = 26;

var TimeBar =
/** @class */
function (_super) {
  (0, _tslib.__extends)(TimeBar, _super);

  function TimeBar() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  TimeBar.prototype.getDefaultCfgs = function () {
    return {
      container: null,
      className: 'g6-component-timebar',
      padding: 10,
      type: 'trend',
      trend: {
        data: [],
        isArea: false,
        smooth: true
      },
      controllerCfg: {
        speed: 2,
        loop: false
      },
      slider: {
        start: 0.1,
        end: 0.9,
        minText: 'min',
        maxText: 'max'
      },
      tick: {
        start: 0.1,
        end: 0.9,
        data: []
      }
    };
  };
  /**
   * 初始化 TimeBar 的容器
   */


  TimeBar.prototype.initContainer = function () {
    var graph = this.get('graph');
    var _a = this._cfgs,
        width = _a.width,
        height = _a.height;
    var className = this.get('className') || 'g6-component-timebar';
    var container = this.get('container');
    var graphContainer = this.get('graph').get('container');
    var timeBarContainer;

    if (!container) {
      timeBarContainer = (0, _createDom.default)("<div class='" + className + "'></div>");
      (0, _modifyCss.default)(timeBarContainer, {
        position: 'relative'
      });
    } else {
      timeBarContainer = container;
    }

    graphContainer.appendChild(timeBarContainer);
    this.set('timeBarContainer', timeBarContainer);
    var canvas;
    var renderer = graph.get('renderer');

    if (renderer === 'SVG') {
      canvas = new _canvas2.default({
        container: timeBarContainer,
        width: width,
        height: height
      });
    } else {
      canvas = new _canvas.default({
        container: timeBarContainer,
        width: width,
        height: height
      });
    }

    this.set('canvas', canvas);
  };

  TimeBar.prototype.init = function () {
    this.initContainer();
    var canvas = this.get('canvas');
    var timeBarGroup = canvas.addGroup({
      name: 'timebar-group'
    });
    this.set('timeBarGroup', timeBarGroup);
    this.renderTrend();
    this.initEvent();
  };

  TimeBar.prototype.renderTrend = function () {
    var _a = this._cfgs,
        width = _a.width,
        x = _a.x,
        y = _a.y,
        padding = _a.padding,
        type = _a.type,
        trend = _a.trend,
        slider = _a.slider,
        controllerCfg = _a.controllerCfg;
    var data = trend.data,
        other = (0, _tslib.__rest)(trend, ["data"]);
    var realWidth = width - 2 * padding;
    var defaultHeight = type === 'trend' ? DEFAULT_TREND_HEIGHT : DEFAULT_SIMPLE_HEIGHT;
    var graph = this.get('graph');
    var group = this.get('timeBarGroup');
    var canvas = this.get('canvas');
    var timebar = null;

    if (type === 'trend' || type === 'simple') {
      timebar = new _trendTimeBar.default((0, _tslib.__assign)((0, _tslib.__assign)({
        graph: graph,
        canvas: canvas,
        group: group,
        type: type,
        x: x + padding,
        y: type === 'trend' ? y + padding : y + padding + 15,
        width: realWidth,
        height: defaultHeight,
        padding: padding,
        trendCfg: (0, _tslib.__assign)((0, _tslib.__assign)({}, other), {
          data: data.map(function (d) {
            return d.value;
          })
        })
      }, slider), {
        ticks: data.map(function (d) {
          return d.date;
        }),
        handlerStyle: (0, _tslib.__assign)((0, _tslib.__assign)({}, slider.handlerStyle), {
          height: slider.height || defaultHeight
        }),
        controllerCfg: controllerCfg
      }));
    } else if (type === 'tick') {
      var tick = this._cfgs.tick; // 刻度时间轴

      timebar = new _timeBarSlice.default((0, _tslib.__assign)({
        graph: graph,
        canvas: canvas,
        group: group,
        x: x + padding,
        y: y + padding
      }, tick));
    }

    this.set('timebar', timebar);
  };

  TimeBar.prototype.filterData = function (evt) {
    var value = evt.value;
    var trendData = null;
    var type = this._cfgs.type;

    if (type === 'trend' || type === 'simple') {
      trendData = this._cfgs.trend.data;
    } else if (type === 'tick') {
      trendData = this._cfgs.tick.data;
    }

    if (!trendData || trendData.length === 0) {
      console.warn('请配置 TimeBar 组件的数据');
      return;
    }

    var rangeChange = this.get('rangeChange');
    var graph = this.get('graph');
    var min = Math.round(trendData.length * value[0]);
    var max = Math.round(trendData.length * value[1]);
    max = max >= trendData.length ? trendData.length - 1 : max;
    var minText = trendData[min].date;
    var maxText = trendData[max].date;

    if (type !== 'tick') {
      var timebar = this.get('timebar');
      timebar.setText(minText, maxText);
    }

    if (rangeChange) {
      rangeChange(graph, minText, maxText);
    } else {
      // 自动过滤数据，并渲染 graph
      var graphData = graph.save();

      if (!this.cacheGraphData || this.cacheGraphData.nodes && this.cacheGraphData.nodes.length === 0) {
        this.cacheGraphData = graphData;
      } // 过滤不在 min 和 max 范围内的节点


      var filterData = this.cacheGraphData.nodes.filter(function (d) {
        return d.date >= minText && d.date <= maxText;
      });
      var nodeIds_1 = filterData.map(function (node) {
        return node.id;
      }); // 过滤 source 或 target 不在 min 和 max 范围内的边

      var fileterEdges = this.cacheGraphData.edges.filter(function (edge) {
        return nodeIds_1.includes(edge.source) && nodeIds_1.includes(edge.target);
      });
      graph.changeData({
        nodes: filterData,
        edges: fileterEdges
      });
    }
  };

  TimeBar.prototype.initEvent = function () {
    var _this = this;

    var start = 0;
    var end = 0;
    var type = this._cfgs.type;

    if (!type || type === 'trend' || type === 'simple') {
      start = this._cfgs.slider.start;
      end = this._cfgs.slider.end;
    } else if (type === 'tick') {
      start = this._cfgs.tick.start;
      end = this._cfgs.tick.end;
    }

    var graph = this.get('graph');
    graph.on('afterrender', function () {
      _this.filterData({
        value: [start, end]
      });
    }); // 时间轴的值发生改变的事件

    graph.on(_constant.VALUE_CHANGE, function (evt) {
      // 范围变化
      _this.filterData(evt);
    });
  };

  TimeBar.prototype.destroy = function () {
    var timebar = this.get('timebar');

    if (timebar && timebar.destory) {
      timebar.destory();
    }

    _super.prototype.destroy.call(this);

    var timeBarContainer = this.get('timeBarContainer');

    if (timeBarContainer) {
      var container = this.get('container');

      if (!container) {
        container = this.get('graph').get('container');
      }

      container.removeChild(timeBarContainer);
    }
  };

  return TimeBar;
}(_base.default);

var _default = TimeBar;
exports.default = _default;