"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathFinder = exports.octolinearCfg = void 0;

var _deepMix = _interopRequireDefault(require("@antv/util/lib/deep-mix"));

var _math = require("../../util/math");

var _polylineUtil = require("./polyline-util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var manhattanDist = function manhattanDist(p1, p2) {
  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
};

var eucliDist = function eucliDist(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
};

var straightPath = function straightPath(start, end) {
  // console.warn('fallbackRoute: straight path');
  return [start, end];
};

var simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {
  // console.warn('fallbackRoute: simple polyline path');
  return (0, _polylineUtil.simplifyPolyline)((0, _polylineUtil.getPolylinePoints)(start, end, startNode, endNode, cfg.offset));
}; // getPolylinePoints


var defaultCfg = {
  offset: 20,
  maxAllowedDirectionChange: 90,
  maximumLoops: 2000,
  gridSize: 10,
  directions: [{
    stepX: 1,
    stepY: 0
  }, {
    stepX: -1,
    stepY: 0
  }, {
    stepX: 0,
    stepY: 1
  }, {
    stepX: 0,
    stepY: -1
  }],

  get penalties() {
    return {
      0: 0,
      45: this.gridSize / 2,
      90: this.gridSize / 2
    };
  },

  distFunc: manhattanDist,
  fallbackRoute: simplePolyline
};
var octolinearCfg = {
  maxAllowedDirectionChange: 45,
  // 8 个方向: 上下左右 + 45度斜线方向
  directions: [{
    stepX: 1,
    stepY: 0
  }, {
    stepX: 1,
    stepY: 1
  }, {
    stepX: 0,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 1
  }, {
    stepX: -1,
    stepY: 0
  }, {
    stepX: -1,
    stepY: -1
  }, {
    stepX: 0,
    stepY: -1
  }, {
    stepX: 1,
    stepY: -1
  }],
  distFunc: eucliDist,
  fallbackRoute: straightPath
};
exports.octolinearCfg = octolinearCfg;

var pos2GridIx = function pos2GridIx(pos, gridSize) {
  var gridIx = Math.floor(pos / gridSize);
  return gridIx < 0 ? 0 : gridIx;
};

var getObstacleMap = function getObstacleMap(items, gridSize, offset) {
  var map = {};
  items.forEach(function (item) {
    // create-edge 时，当边类型为 polyline 时 endNode 为 null
    if (item) {
      var bbox = (0, _polylineUtil.getExpandedBBox)(item.getBBox(), offset);

      for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {
        for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {
          var gridKey = x + "-" + y;
          map[gridKey] = true;
        }
      }
    }
  });
  return map;
};
/**
 * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）
 * @param p1 PolyPoint
 * @param p2 PolyPoint
 */


var getDirectionAngle = function getDirectionAngle(p1, p2) {
  var deltaX = p2.x - p1.x;
  var deltaY = p2.y - p1.y;
  if (!deltaX && !deltaY) return 0;
  var angle = (360 + Math.atan2(deltaY, deltaX) * 180 / Math.PI) % 360;
  return angle;
};
/**
 * 方向角的改变，取小于180度角
 * @param angle1
 * @param angle2
 */


var getAngleDiff = function getAngleDiff(angle1, angle2) {
  var directionChange = Math.abs(angle1 - angle2);
  return directionChange > 180 ? 360 - directionChange : directionChange;
}; // Path finder //


var estimateCost = function estimateCost(from, endPoints, distFunc) {
  var min = Infinity;

  for (var i = 0, len = endPoints.length; i < len; i++) {
    var cost = distFunc(from, endPoints[i]);

    if (cost < min) {
      min = cost;
    }
  }

  return min;
}; // 计算考虑 offset 后的 BBox 上的连接点


var getBoxPoints = function getBoxPoints(point, node, cfg) {
  var points = []; // create-edge 生成边的过程中，endNode 为 null

  if (!node) {
    return points;
  }

  var directions = cfg.directions,
      offset = cfg.offset;
  var bbox = node.getBBox();
  var expandBBox = (0, _polylineUtil.getExpandedBBox)(node.getBBox(), offset);

  for (var i in expandBBox) {
    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);
  }

  var isInside = point.x > pos2GridIx(bbox.minX, cfg.gridSize) && point.x < pos2GridIx(bbox.maxX, cfg.gridSize) && point.y > pos2GridIx(bbox.minY, cfg.gridSize) && point.y < pos2GridIx(bbox.maxY, cfg.gridSize);

  if (isInside) {
    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点
    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {
      var dir = directions_1[_i];
      var bounds = [[{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.minY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.minY
      }, {
        x: expandBBox.minX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.maxX,
        y: expandBBox.minY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }], [{
        x: expandBBox.minX,
        y: expandBBox.maxY
      }, {
        x: expandBBox.maxX,
        y: expandBBox.maxY
      }]];

      for (var i = 0; i < 4; i++) {
        var boundLine = bounds[i];
        var insterctP = (0, _math.getLineIntersect)(point, {
          x: point.x + dir.stepX * expandBBox.width,
          y: point.y + dir.stepY * expandBBox.height
        }, boundLine[0], boundLine[1]);

        if (insterctP && !(0, _polylineUtil.isSegmentCrossingBBox)(point, insterctP, node.getBBox())) {
          insterctP.id = insterctP.x + "-" + insterctP.y;
          points.push(insterctP);
        }
      }
    }
  } else {
    // 如果 anchorPoint 在节点上，只有一个可选方向
    var insterctP = (0, _polylineUtil.getExpandedBBoxPoint)(expandBBox, point);
    insterctP.id = insterctP.x + "-" + insterctP.y;
    points.push(insterctP);
  }

  return points;
};

var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {
  var cfg = (0, _deepMix.default)(defaultCfg, routerCfg);
  cfg.obstacles = cfg.obstacles || [];
  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), cfg.gridSize, cfg.offset);
  var scaleStartPoint = {
    x: pos2GridIx(startPoint.x, cfg.gridSize),
    y: pos2GridIx(startPoint.y, cfg.gridSize)
  };
  var scaleEndPoint = {
    x: pos2GridIx(endPoint.x, cfg.gridSize),
    y: pos2GridIx(endPoint.y, cfg.gridSize)
  };
  startPoint.id = scaleStartPoint.x + "-" + scaleStartPoint.y;
  endPoint.id = scaleEndPoint.x + "-" + scaleEndPoint.y;
  var startPoints = getBoxPoints(scaleStartPoint, startNode, cfg);
  var endPoints = getBoxPoints(scaleEndPoint, endNode, cfg);
  startPoints.forEach(function (point) {
    delete map[point.id];
  });
  endPoints.forEach(function (point) {
    delete map[point.id];
  });
  var openSet = {};
  var closedSet = {};
  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity

  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity

  var fScore = {}; // initialize

  for (var i = 0; i < startPoints.length; i++) {
    var firstStep = startPoints[i];
    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;

    gScore[firstStep.id] = 0;
    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);
  }

  var getDirectionChange = function getDirectionChange(current, neighbor) {
    var directionAngle = getDirectionAngle(current, neighbor);
    var directionChange;

    if (!cameFrom[current.id]) {
      var startAngle = getDirectionAngle(scaleStartPoint, current);
      directionChange = getAngleDiff(startAngle, directionAngle);
    } else {
      var prevDirectionAngle = getDirectionAngle({
        x: parseFloat(cameFrom[current.id].split('-')[0]),
        y: parseFloat(cameFrom[current.id].split('-')[1])
      }, current);
      directionChange = getAngleDiff(prevDirectionAngle, directionAngle);
    }

    return directionChange;
  };

  var getControlPoints = function getControlPoints(currentId) {
    var controlPoints = [endPoint];
    var lastPoint = {
      x: parseFloat(currentId.split('-')[0]),
      y: parseFloat(currentId.split('-')[1]),
      id: currentId
    };

    if (getDirectionChange(lastPoint, scaleEndPoint)) {
      controlPoints.unshift({
        x: lastPoint.x === scaleEndPoint.x ? endPoint.x : lastPoint.x * cfg.gridSize,
        y: lastPoint.y === scaleEndPoint.y ? endPoint.y : lastPoint.y * cfg.gridSize
      });
    }

    while (cameFrom[currentId] && cameFrom[currentId] !== currentId) {
      var point = {
        x: parseFloat(currentId.split('-')[0]),
        y: parseFloat(currentId.split('-')[1]),
        id: currentId
      };
      var preId = cameFrom[currentId];
      var prePoint = {
        x: parseFloat(preId.split('-')[0]),
        y: parseFloat(preId.split('-')[1]),
        id: preId
      };
      var directionChange = getDirectionChange(prePoint, point);

      if (directionChange) {
        controlPoints.unshift({
          x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * cfg.gridSize,
          y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * cfg.gridSize
        });
      }

      currentId = preId;
    } // 和startNode对齐


    var firstPoint = {
      x: parseFloat(currentId.split('-')[0]),
      y: parseFloat(currentId.split('-')[1]),
      id: currentId
    };
    controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;
    controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;
    controlPoints.unshift(startPoint);
    return controlPoints;
  };

  var remainLoops = cfg.maximumLoops;

  var _loop_1 = function _loop_1() {
    var current;
    var curCost = Infinity; // 找到 openSet 中 fScore 最小的点

    for (var id in openSet) {
      if (fScore[id] <= curCost) {
        curCost = fScore[id];
        current = openSet[id];
      }
    }

    if (!current) return "break"; // 如果 fScore 最小的点就是终点

    if (endPoints.findIndex(function (point) {
      return point.x === current.x && point.y === current.y;
    }) > -1) {
      var controlPoints = getControlPoints(current.id);
      return {
        value: controlPoints
      };
    }

    delete openSet[current.id];
    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点
    // 沿候选方向走一步

    for (var i = 0; i < cfg.directions.length; i++) {
      var direction = cfg.directions[i];
      var neighbor = {
        x: current.x + direction.stepX,
        y: current.y + direction.stepY,
        id: current.x + direction.stepX + "-" + (current.y + direction.stepY)
      };
      if (closedSet[neighbor.id]) continue;
      var directionChange = getDirectionChange(current, neighbor);
      if (directionChange > cfg.maxAllowedDirectionChange) continue;
      if (map[neighbor.id]) continue; // 如果交叉则跳过
      // 将候选点加入 openSet, 并计算每个候选点的 cost

      if (!openSet[neighbor.id]) {
        openSet[neighbor.id] = neighbor;
      }

      var neighborCost = cfg.distFunc(current, neighbor) + (isNaN(cfg.penalties[directionChange]) ? cfg.gridSize : cfg.penalties[directionChange]);
      var costFromStart = gScore[current.id] + neighborCost;

      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {
        continue;
      }

      cameFrom[neighbor.id] = current.id;
      gScore[neighbor.id] = costFromStart;
      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);
    }

    remainLoops -= 1;
  };

  while (Object.keys(openSet).length > 0 && remainLoops > 0) {
    var state_1 = _loop_1();

    if (_typeof(state_1) === "object") return state_1.value;
    if (state_1 === "break") break;
  }

  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);
};

exports.pathFinder = pathFinder;