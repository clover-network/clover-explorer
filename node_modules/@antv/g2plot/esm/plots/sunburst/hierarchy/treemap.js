import * as d3Hierarchy from 'd3-hierarchy';
import { assign, isArray } from '@antv/util';
import { getField, getAllNodes } from './util';
var DEFAULT_OPTIONS = {
    field: 'value',
    tile: 'treemapSquarify',
    size: [1, 1],
    round: false,
    padding: 0,
    paddingInner: 0,
    paddingOuter: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    as: ['x', 'y'],
};
export function treemap(data, options) {
    options = assign({}, DEFAULT_OPTIONS, options);
    var as = options.as;
    if (!isArray(as) || as.length !== 2) {
        throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
    }
    var field;
    try {
        field = getField(options);
    }
    catch (e) {
        console.warn(e);
    }
    var partition = function (data) {
        return d3Hierarchy
            .treemap()
            .tile(d3Hierarchy[options.tile])
            .size(options.size)
            .round(options.round)
            .padding(options.padding)
            .paddingInner(options.paddingInner)
            .paddingOuter(options.paddingOuter)
            .paddingTop(options.paddingTop)
            .paddingRight(options.paddingRight)
            .paddingBottom(options.paddingBottom)
            .paddingLeft(options.paddingLeft)(d3Hierarchy.hierarchy(data).sum(function (d) { return d[field]; }));
    };
    var root = partition(data);
    /*
     * points:
     *   3  2
     *   0  1
     */
    var x = as[0];
    var y = as[1];
    root.each(function (node) {
        node[x] = [node.x0, node.x1, node.x1, node.x0];
        node[y] = [node.y1, node.y1, node.y0, node.y0];
        ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {
            if (as.indexOf(prop) === -1) {
                delete node[prop];
            }
        });
    });
    return getAllNodes(root);
}
//# sourceMappingURL=treemap.js.map