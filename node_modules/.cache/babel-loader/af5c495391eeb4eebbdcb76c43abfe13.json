{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar number_1 = require(\"../../util/number\");\n\nfunction createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {\n  var rect = cartesian.getArea();\n  var x = rect.x;\n  var y = rect.y;\n  var width = rect.width;\n  var height = rect.height;\n  var lineWidth = seriesModel.get(['lineStyle', 'width']) || 2;\n  x -= lineWidth / 2;\n  y -= lineWidth / 2;\n  width += lineWidth;\n  height += lineWidth;\n  x = Math.floor(x);\n  width = Math.round(width);\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = baseAxis.isHorizontal();\n    var isAxisInversed = baseAxis.inverse;\n\n    if (isHorizontal) {\n      if (isAxisInversed) {\n        clipPath.shape.x += width;\n      }\n\n      clipPath.shape.width = 0;\n    } else {\n      if (!isAxisInversed) {\n        clipPath.shape.y += height;\n      }\n\n      clipPath.shape.height = 0;\n    }\n\n    var duringCb = typeof during === 'function' ? function (percent) {\n      during(percent, clipPath);\n    } : null;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      }\n    }, seriesModel, null, done, duringCb);\n  }\n\n  return clipPath;\n}\n\nexports.createGridClipPath = createGridClipPath;\n\nfunction createPolarClipPath(polar, hasAnimation, seriesModel) {\n  var sectorArea = polar.getArea();\n  var r0 = number_1.round(sectorArea.r0, 1);\n  var r = number_1.round(sectorArea.r, 1);\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: number_1.round(polar.cx, 1),\n      cy: number_1.round(polar.cy, 1),\n      r0: r0,\n      r: r,\n      startAngle: sectorArea.startAngle,\n      endAngle: sectorArea.endAngle,\n      clockwise: sectorArea.clockwise\n    }\n  });\n\n  if (hasAnimation) {\n    var isRadial = polar.getBaseAxis().dim === 'angle';\n\n    if (isRadial) {\n      clipPath.shape.endAngle = sectorArea.startAngle;\n    } else {\n      clipPath.shape.r = r0;\n    }\n\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: sectorArea.endAngle,\n        r: r\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nexports.createPolarClipPath = createPolarClipPath;\n\nfunction createClipPath(coordSys, hasAnimation, seriesModel, done, during) {\n  if (!coordSys) {\n    return null;\n  } else if (coordSys.type === 'polar') {\n    return createPolarClipPath(coordSys, hasAnimation, seriesModel);\n  } else if (coordSys.type === 'cartesian2d') {\n    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);\n  }\n\n  return null;\n}\n\nexports.createClipPath = createClipPath;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/chart/helper/createClipPathFromCoordSys.js"],"names":["exports","__esModule","graphic","require","number_1","createGridClipPath","cartesian","hasAnimation","seriesModel","done","during","rect","getArea","x","y","width","height","lineWidth","get","Math","floor","round","clipPath","Rect","shape","baseAxis","getBaseAxis","isHorizontal","isAxisInversed","inverse","duringCb","percent","initProps","createPolarClipPath","polar","sectorArea","r0","r","Sector","cx","cy","startAngle","endAngle","clockwise","isRadial","dim","createClipPath","coordSys","type"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar graphic = require(\"../../util/graphic\");\n\nvar number_1 = require(\"../../util/number\");\n\nfunction createGridClipPath(cartesian, hasAnimation, seriesModel, done, during) {\n  var rect = cartesian.getArea();\n  var x = rect.x;\n  var y = rect.y;\n  var width = rect.width;\n  var height = rect.height;\n  var lineWidth = seriesModel.get(['lineStyle', 'width']) || 2;\n  x -= lineWidth / 2;\n  y -= lineWidth / 2;\n  width += lineWidth;\n  height += lineWidth;\n  x = Math.floor(x);\n  width = Math.round(width);\n  var clipPath = new graphic.Rect({\n    shape: {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (hasAnimation) {\n    var baseAxis = cartesian.getBaseAxis();\n    var isHorizontal = baseAxis.isHorizontal();\n    var isAxisInversed = baseAxis.inverse;\n\n    if (isHorizontal) {\n      if (isAxisInversed) {\n        clipPath.shape.x += width;\n      }\n\n      clipPath.shape.width = 0;\n    } else {\n      if (!isAxisInversed) {\n        clipPath.shape.y += height;\n      }\n\n      clipPath.shape.height = 0;\n    }\n\n    var duringCb = typeof during === 'function' ? function (percent) {\n      during(percent, clipPath);\n    } : null;\n    graphic.initProps(clipPath, {\n      shape: {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n      }\n    }, seriesModel, null, done, duringCb);\n  }\n\n  return clipPath;\n}\n\nexports.createGridClipPath = createGridClipPath;\n\nfunction createPolarClipPath(polar, hasAnimation, seriesModel) {\n  var sectorArea = polar.getArea();\n  var r0 = number_1.round(sectorArea.r0, 1);\n  var r = number_1.round(sectorArea.r, 1);\n  var clipPath = new graphic.Sector({\n    shape: {\n      cx: number_1.round(polar.cx, 1),\n      cy: number_1.round(polar.cy, 1),\n      r0: r0,\n      r: r,\n      startAngle: sectorArea.startAngle,\n      endAngle: sectorArea.endAngle,\n      clockwise: sectorArea.clockwise\n    }\n  });\n\n  if (hasAnimation) {\n    var isRadial = polar.getBaseAxis().dim === 'angle';\n\n    if (isRadial) {\n      clipPath.shape.endAngle = sectorArea.startAngle;\n    } else {\n      clipPath.shape.r = r0;\n    }\n\n    graphic.initProps(clipPath, {\n      shape: {\n        endAngle: sectorArea.endAngle,\n        r: r\n      }\n    }, seriesModel);\n  }\n\n  return clipPath;\n}\n\nexports.createPolarClipPath = createPolarClipPath;\n\nfunction createClipPath(coordSys, hasAnimation, seriesModel, done, during) {\n  if (!coordSys) {\n    return null;\n  } else if (coordSys.type === 'polar') {\n    return createPolarClipPath(coordSys, hasAnimation, seriesModel);\n  } else if (coordSys.type === 'cartesian2d') {\n    return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during);\n  }\n\n  return null;\n}\n\nexports.createClipPath = createClipPath;"]},"metadata":{},"sourceType":"script"}