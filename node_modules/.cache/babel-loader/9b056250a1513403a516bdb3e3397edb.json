{"ast":null,"code":"import { mat3, transform, vec3 } from '@antv/matrix-util';\nimport isArray from '@antv/util/lib/is-array';\nimport { each } from '@antv/util';\n/**\n * 是否在区间内\n * @param   {number}       value  值\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\nvar isBetween = function isBetween(value, min, max) {\n  return value >= min && value <= max;\n};\n/**\n * 获取两条线段的交点\n * @param  {Point}  p0 第一条线段起点\n * @param  {Point}  p1 第一条线段终点\n * @param  {Point}  p2 第二条线段起点\n * @param  {Point}  p3 第二条线段终点\n * @return {Point}  交点\n */\n\n\nexport var getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\n  var tolerance = 0.001;\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n  var point = null;\n\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) / kross;\n    var t = (E.x * D0.y - E.y * D0.x) / kross;\n\n    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {\n      point = {\n        x: p0.x + s * D0.x,\n        y: p0.y + s * D0.y\n      };\n    }\n  }\n\n  return point;\n};\n/**\n * point and rectangular intersection point\n * @param  {IRect} rect  rect\n * @param  {Point} point point\n * @return {PointPoint} rst;\n */\n\nexport var getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\n  var x = rect.x,\n      y = rect.y,\n      width = rect.width,\n      height = rect.height;\n  var cx = x + width / 2;\n  var cy = y + height / 2;\n  var points = [];\n  var center = {\n    x: cx,\n    y: cy\n  };\n  points.push({\n    x: x,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y\n  });\n  var rst = null;\n\n  for (var i = 1; i < points.length; i++) {\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\n\n    if (rst) {\n      break;\n    }\n  }\n\n  return rst;\n};\n/**\n * get point and circle inIntersect\n * @param {ICircle} circle 圆点，x,y,r\n * @param {Point} point 点 x,y\n * @return {Point} applied point\n */\n\nexport var getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\n  var cx = circle.x,\n      cy = circle.y,\n      r = circle.r;\n  var x = point.x,\n      y = point.y;\n  var dx = x - cx;\n  var dy = y - cy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n\n  if (d < r) {\n    return null;\n  }\n\n  var signX = Math.sign(dx);\n  var signY = Math.sign(dy);\n  var angle = Math.atan(dy / dx);\n  return {\n    x: cx + Math.abs(r * Math.cos(angle)) * signX,\n    y: cy + Math.abs(r * Math.sin(angle)) * signY\n  };\n};\n/**\n * get point and ellipse inIntersect\n * @param {Object} ellipse 椭圆 x,y,rx,ry\n * @param {Object} point 点 x,y\n * @return {object} applied point\n */\n\nexport var getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\n  var a = ellipse.rx;\n  var b = ellipse.ry;\n  var cx = ellipse.x;\n  var cy = ellipse.y;\n  var dx = point.x - cx;\n  var dy = point.y - cy; // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\n\n  var angle = Math.atan2(dy / b, dx / a);\n\n  if (angle < 0) {\n    angle += 2 * Math.PI; // 转换到 0，2PI\n  }\n\n  return {\n    x: cx + a * Math.cos(angle),\n    y: cy + b * Math.sin(angle)\n  };\n};\n/**\n * coordinate matrix transformation\n * @param  {number} point   coordinate\n * @param  {Matrix} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {Point} transformed point\n */\n\nexport var applyMatrix = function applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  var vector = [point.x, point.y, tag];\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n * coordinate matrix invert transformation\n * @param  {number} point   coordinate\n * @param  {number} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {object} transformed point\n */\n\nexport var invertMatrix = function invertMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var inversedMatrix = mat3.invert([], matrix);\n\n  if (!inversedMatrix) {\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var vector = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, inversedMatrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n *\n * @param p1 First coordinate\n * @param p2 second coordinate\n * @param p3 three coordinate\n */\n\nexport var getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\n  var a = p1.x - p2.x;\n  var b = p1.y - p2.y;\n  var c = p1.x - p3.x;\n  var d = p1.y - p3.y;\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\n  var denominator = b * c - a * d;\n  return {\n    x: -(d * e - b * f) / denominator,\n    y: -(a * f - c * e) / denominator\n  };\n};\n/**\n * get distance by two points\n * @param p1 first point\n * @param p2 second point\n */\n\nexport var distance = function distance(p1, p2) {\n  var vx = p1.x - p2.x;\n  var vy = p1.y - p2.y;\n  return Math.sqrt(vx * vx + vy * vy);\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\nexport var scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * Floyd Warshall algorithm for shortest path distances matrix\n * @param  {array} adjMatrix   adjacency matrix\n * @return {array} distances   shortest path distances matrix\n */\n\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\n/**\n * get adjacency matrix\n * @param data graph data\n * @param directed whether it's a directed graph\n */\n\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n          target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\n * 平移group\n * @param group Group 实例\n * @param vec 移动向量\n */\n\nexport var translate = function translate(group, vec) {\n  group.translate(vec.x, vec.y);\n};\n/**\n * 移动到指定坐标点\n * @param group Group 实例\n * @param point 移动到的坐标点\n */\n\nexport var move = function move(group, point) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var bbox = group.getCanvasBBox();\n  var vx = point.x - bbox.minX;\n  var vy = point.y - bbox.minY;\n  var movedMatrix = transform(matrix, [['t', vx, vy]]);\n  group.setMatrix(movedMatrix);\n};\n/**\n * 缩放 group\n * @param group Group 实例\n * @param point 在x 和 y 方向上的缩放比例\n */\n\nexport var scale = function scale(group, ratio) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var scaleXY = ratio;\n\n  if (!isArray(ratio)) {\n    scaleXY = [ratio, ratio];\n  }\n\n  if (isArray(ratio) && ratio.length === 1) {\n    scaleXY = [ratio[0], ratio[0]];\n  }\n\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\n  group.setMatrix(matrix);\n};\n/**\n *\n * @param group Group 实例\n * @param ratio 选择角度\n */\n\nexport var rotate = function rotate(group, angle) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  matrix = transform(matrix, [['r', angle]]);\n  group.setMatrix(matrix);\n};\nexport var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n}; // 判断点Q是否在p1和p2的线段上\n\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\n * @param points\n * @param x\n * @param y\n */\n\n\nexport var isPointInPolygon = function isPointInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length; // 判断两个double在eps精度下的大小关系\n\n  var tolerance = 1e-6;\n\n  function dcmp(xValue) {\n    if (Math.abs(xValue) < tolerance) {\n      return 0;\n    }\n\n    return xValue < 0 ? -1 : 1;\n  }\n\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    } // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n\n\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n\n  return isHit;\n}; // 判断两个BBox是否相交\n\nexport var intersectBBox = function intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n};\n\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n/**\n * 判断两个polygon是否相交。\n * borrow from @antv/path-util\n * @param points1 polygon1的顶点数组\n * @param points2 polygon2的顶点数组\n */\n\n\nexport var isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\n  var getBBox = function getBBox(points) {\n    var xArr = points.map(function (p) {\n      return p[0];\n    });\n    var yArr = points.map(function (p) {\n      return p[1];\n    });\n    return {\n      minX: Math.min.apply(null, xArr),\n      maxX: Math.max.apply(null, xArr),\n      minY: Math.min.apply(null, yArr),\n      maxY: Math.max.apply(null, yArr)\n    };\n  };\n\n  var parseToLines = function parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n\n    for (var i = 0; i < count - 1; i++) {\n      var point = points[i];\n      var next = points[i + 1];\n      lines.push({\n        from: {\n          x: point[0],\n          y: point[1]\n        },\n        to: {\n          x: next[0],\n          y: next[1]\n        }\n      });\n    }\n\n    if (lines.length > 1) {\n      var first = points[0];\n      var last = points[count - 1];\n      lines.push({\n        from: {\n          x: last[0],\n          y: last[1]\n        },\n        to: {\n          x: first[0],\n          y: first[1]\n        }\n      });\n    }\n\n    return lines;\n  }; // 空数组，或者一个点返回 false\n\n\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2); // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n\n  var isIn = false; // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n\nvar Line =\n/** @class */\nfunction () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  Line.prototype.getBBox = function () {\n    var minX = Math.min(this.x1, this.x2);\n    var minY = Math.min(this.y1, this.y2);\n    var maxX = Math.max(this.x1, this.x2);\n    var maxY = Math.max(this.y1, this.y2);\n    var res = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return res;\n  };\n\n  return Line;\n}();\n\nexport { Line };\nexport var getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\n  var bounds = {\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\n  };\n  return bounds[direction];\n};\n/**\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\n */\n\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n\n  if (uB) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return ua;\n    }\n  }\n\n  return Number.POSITIVE_INFINITY;\n};\n\nexport var itemIntersectByLine = function itemIntersectByLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var countIntersections = 0;\n  var intersections = [];\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    intersections[i] = getLineIntersect({\n      x: line.x1,\n      y: line.y1\n    }, {\n      x: line.x2,\n      y: line.y2\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x2,\n      y: y2\n    });\n\n    if (intersections[i]) {\n      countIntersections += 1;\n    }\n  }\n\n  return [intersections, countIntersections];\n};\nexport var fractionToLine = function fractionToLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var minDistance = Number.POSITIVE_INFINITY;\n  var countIntersections = 0;\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\n    testDistance = Math.abs(testDistance - 0.5);\n\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections += 1;\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\n    }\n  }\n\n  if (countIntersections === 0) return -1;\n  return minDistance;\n};\nexport var getPointsCenter = function getPointsCenter(points) {\n  var centerX = 0;\n  var centerY = 0;\n\n  if (points.length > 0) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      centerX += point.x;\n      centerY += point.y;\n    }\n\n    centerX /= points.length;\n    centerY /= points.length;\n  }\n\n  return {\n    x: centerX,\n    y: centerY\n  };\n};\nexport var squareDist = function squareDist(a, b) {\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n};\nexport var pointLineSquareDist = function pointLineSquareDist(point, line) {\n  var x1 = line.x1;\n  var y1 = line.y1;\n  var x2 = line.x2 - x1;\n  var y2 = line.y2 - y1;\n  var px = point.x - x1;\n  var py = point.y - y1;\n  var dotprod = px * x2 + py * y2;\n  var projlenSq;\n\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n\n  var lenSq = px * px + py * py - projlenSq;\n\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n\n  return lenSq;\n};\nexport var isPointsOverlap = function isPointsOverlap(p1, p2, e) {\n  if (e === void 0) {\n    e = 1e-3;\n  }\n\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\n};\n/**\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\n * @param point IPoint\n * @param rect IRect\n */\n\nexport var pointRectSquareDist = function pointRectSquareDist(point, rect) {\n  var isLeft = point.x < rect.x;\n  var isRight = point.x > rect.x + rect.width;\n  var isTop = point.y > rect.y + rect.height;\n  var isBottom = point.y < rect.y;\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\n\n  if (!isPointOutside) {\n    return 0;\n  }\n\n  if (isTop && !isLeft && !isRight) {\n    return Math.pow(rect.y + rect.height - point.y, 2);\n  }\n\n  if (isBottom && !isLeft && !isRight) {\n    return Math.pow(point.y - rect.y, 2);\n  }\n\n  if (isLeft && !isTop && !isBottom) {\n    return Math.pow(rect.x - point.x, 2);\n  }\n\n  if (isRight && !isTop && !isBottom) {\n    return Math.pow(rect.x + rect.width - point.x, 2);\n  }\n\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\n  return dx * dx + dy * dy;\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/util/math.js"],"names":["mat3","transform","vec3","isArray","each","isBetween","value","min","max","getLineIntersect","p0","p1","p2","p3","tolerance","E","x","y","D0","D1","kross","sqrKross","sqrLen0","sqrLen1","point","s","t","getRectIntersectByPoint","rect","width","height","cx","cy","points","center","push","rst","i","length","getCircleIntersectByPoint","circle","r","dx","dy","d","Math","sqrt","signX","sign","signY","angle","atan","abs","cos","sin","getEllipseIntersectByPoint","ellipse","a","rx","b","ry","atan2","PI","applyMatrix","matrix","tag","vector","isNaN","transformMat3","invertMatrix","inversedMatrix","invert","getCircleCenterByPoints","c","e","f","denominator","distance","vx","vy","scaleMatrix","ratio","result","forEach","row","newRow","v","floydWarshall","adjMatrix","dist","size","j","Infinity","k","getAdjMatrix","data","directed","nodes","edges","nodeMap","Error","node","id","source","target","sIndex","tIndex","translate","group","vec","move","getMatrix","bbox","getCanvasBBox","minX","minY","movedMatrix","setMatrix","scale","scaleXY","rotate","getDegree","n","nodeIdxMap","degrees","onSegment","q","isPointInPolygon","isHit","dcmp","xValue","intersectBBox","box1","box2","maxX","maxY","lineIntersectPolygon","lines","line","isIntersect","l","from","to","isPolygonsIntersect","points1","points2","getBBox","xArr","map","p","yArr","apply","parseToLines","count","next","first","last","bbox1","bbox2","isIn","lines1","lines2","Line","x1","y1","x2","y2","prototype","res","getBBoxBoundLine","direction","bounds","top","left","bottom","right","fractionAlongLineA","la","lb","uaT","ubT","uB","ua","ub","Number","POSITIVE_INFINITY","itemIntersectByLine","item","directions","countIntersections","intersections","_a","fractionToLine","minDistance","testDistance","getPointsCenter","centerX","centerY","_i","points_1","squareDist","pow","pointLineSquareDist","px","py","dotprod","projlenSq","lenSq","isPointsOverlap","pointRectSquareDist","isLeft","isRight","isTop","isBottom","isPointOutside"],"mappings":"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","sourcesContent":["import { mat3, transform, vec3 } from '@antv/matrix-util';\nimport isArray from '@antv/util/lib/is-array';\nimport { each } from '@antv/util';\n/**\n * 是否在区间内\n * @param   {number}       value  值\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\nvar isBetween = function isBetween(value, min, max) {\n  return value >= min && value <= max;\n};\n/**\n * 获取两条线段的交点\n * @param  {Point}  p0 第一条线段起点\n * @param  {Point}  p1 第一条线段终点\n * @param  {Point}  p2 第二条线段起点\n * @param  {Point}  p3 第二条线段终点\n * @return {Point}  交点\n */\n\n\nexport var getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\n  var tolerance = 0.001;\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n  var point = null;\n\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) / kross;\n    var t = (E.x * D0.y - E.y * D0.x) / kross;\n\n    if (isBetween(s, 0, 1) && isBetween(t, 0, 1)) {\n      point = {\n        x: p0.x + s * D0.x,\n        y: p0.y + s * D0.y\n      };\n    }\n  }\n\n  return point;\n};\n/**\n * point and rectangular intersection point\n * @param  {IRect} rect  rect\n * @param  {Point} point point\n * @return {PointPoint} rst;\n */\n\nexport var getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\n  var x = rect.x,\n      y = rect.y,\n      width = rect.width,\n      height = rect.height;\n  var cx = x + width / 2;\n  var cy = y + height / 2;\n  var points = [];\n  var center = {\n    x: cx,\n    y: cy\n  };\n  points.push({\n    x: x,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y\n  });\n  var rst = null;\n\n  for (var i = 1; i < points.length; i++) {\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\n\n    if (rst) {\n      break;\n    }\n  }\n\n  return rst;\n};\n/**\n * get point and circle inIntersect\n * @param {ICircle} circle 圆点，x,y,r\n * @param {Point} point 点 x,y\n * @return {Point} applied point\n */\n\nexport var getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\n  var cx = circle.x,\n      cy = circle.y,\n      r = circle.r;\n  var x = point.x,\n      y = point.y;\n  var dx = x - cx;\n  var dy = y - cy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n\n  if (d < r) {\n    return null;\n  }\n\n  var signX = Math.sign(dx);\n  var signY = Math.sign(dy);\n  var angle = Math.atan(dy / dx);\n  return {\n    x: cx + Math.abs(r * Math.cos(angle)) * signX,\n    y: cy + Math.abs(r * Math.sin(angle)) * signY\n  };\n};\n/**\n * get point and ellipse inIntersect\n * @param {Object} ellipse 椭圆 x,y,rx,ry\n * @param {Object} point 点 x,y\n * @return {object} applied point\n */\n\nexport var getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\n  var a = ellipse.rx;\n  var b = ellipse.ry;\n  var cx = ellipse.x;\n  var cy = ellipse.y;\n  var dx = point.x - cx;\n  var dy = point.y - cy; // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\n\n  var angle = Math.atan2(dy / b, dx / a);\n\n  if (angle < 0) {\n    angle += 2 * Math.PI; // 转换到 0，2PI\n  }\n\n  return {\n    x: cx + a * Math.cos(angle),\n    y: cy + b * Math.sin(angle)\n  };\n};\n/**\n * coordinate matrix transformation\n * @param  {number} point   coordinate\n * @param  {Matrix} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {Point} transformed point\n */\n\nexport var applyMatrix = function applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  var vector = [point.x, point.y, tag];\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n * coordinate matrix invert transformation\n * @param  {number} point   coordinate\n * @param  {number} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {object} transformed point\n */\n\nexport var invertMatrix = function invertMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var inversedMatrix = mat3.invert([], matrix);\n\n  if (!inversedMatrix) {\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var vector = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, inversedMatrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n *\n * @param p1 First coordinate\n * @param p2 second coordinate\n * @param p3 three coordinate\n */\n\nexport var getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\n  var a = p1.x - p2.x;\n  var b = p1.y - p2.y;\n  var c = p1.x - p3.x;\n  var d = p1.y - p3.y;\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\n  var denominator = b * c - a * d;\n  return {\n    x: -(d * e - b * f) / denominator,\n    y: -(a * f - c * e) / denominator\n  };\n};\n/**\n * get distance by two points\n * @param p1 first point\n * @param p2 second point\n */\n\nexport var distance = function distance(p1, p2) {\n  var vx = p1.x - p2.x;\n  var vy = p1.y - p2.y;\n  return Math.sqrt(vx * vx + vy * vy);\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\nexport var scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * Floyd Warshall algorithm for shortest path distances matrix\n * @param  {array} adjMatrix   adjacency matrix\n * @return {array} distances   shortest path distances matrix\n */\n\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\n/**\n * get adjacency matrix\n * @param data graph data\n * @param directed whether it's a directed graph\n */\n\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n          target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\n * 平移group\n * @param group Group 实例\n * @param vec 移动向量\n */\n\nexport var translate = function translate(group, vec) {\n  group.translate(vec.x, vec.y);\n};\n/**\n * 移动到指定坐标点\n * @param group Group 实例\n * @param point 移动到的坐标点\n */\n\nexport var move = function move(group, point) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var bbox = group.getCanvasBBox();\n  var vx = point.x - bbox.minX;\n  var vy = point.y - bbox.minY;\n  var movedMatrix = transform(matrix, [['t', vx, vy]]);\n  group.setMatrix(movedMatrix);\n};\n/**\n * 缩放 group\n * @param group Group 实例\n * @param point 在x 和 y 方向上的缩放比例\n */\n\nexport var scale = function scale(group, ratio) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var scaleXY = ratio;\n\n  if (!isArray(ratio)) {\n    scaleXY = [ratio, ratio];\n  }\n\n  if (isArray(ratio) && ratio.length === 1) {\n    scaleXY = [ratio[0], ratio[0]];\n  }\n\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\n  group.setMatrix(matrix);\n};\n/**\n *\n * @param group Group 实例\n * @param ratio 选择角度\n */\n\nexport var rotate = function rotate(group, angle) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  matrix = transform(matrix, [['r', angle]]);\n  group.setMatrix(matrix);\n};\nexport var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n}; // 判断点Q是否在p1和p2的线段上\n\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\n * @param points\n * @param x\n * @param y\n */\n\n\nexport var isPointInPolygon = function isPointInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length; // 判断两个double在eps精度下的大小关系\n\n  var tolerance = 1e-6;\n\n  function dcmp(xValue) {\n    if (Math.abs(xValue) < tolerance) {\n      return 0;\n    }\n\n    return xValue < 0 ? -1 : 1;\n  }\n\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    } // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n\n\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n\n  return isHit;\n}; // 判断两个BBox是否相交\n\nexport var intersectBBox = function intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n};\n\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n/**\n * 判断两个polygon是否相交。\n * borrow from @antv/path-util\n * @param points1 polygon1的顶点数组\n * @param points2 polygon2的顶点数组\n */\n\n\nexport var isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\n  var getBBox = function getBBox(points) {\n    var xArr = points.map(function (p) {\n      return p[0];\n    });\n    var yArr = points.map(function (p) {\n      return p[1];\n    });\n    return {\n      minX: Math.min.apply(null, xArr),\n      maxX: Math.max.apply(null, xArr),\n      minY: Math.min.apply(null, yArr),\n      maxY: Math.max.apply(null, yArr)\n    };\n  };\n\n  var parseToLines = function parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n\n    for (var i = 0; i < count - 1; i++) {\n      var point = points[i];\n      var next = points[i + 1];\n      lines.push({\n        from: {\n          x: point[0],\n          y: point[1]\n        },\n        to: {\n          x: next[0],\n          y: next[1]\n        }\n      });\n    }\n\n    if (lines.length > 1) {\n      var first = points[0];\n      var last = points[count - 1];\n      lines.push({\n        from: {\n          x: last[0],\n          y: last[1]\n        },\n        to: {\n          x: first[0],\n          y: first[1]\n        }\n      });\n    }\n\n    return lines;\n  }; // 空数组，或者一个点返回 false\n\n\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2); // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n\n  var isIn = false; // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n\nvar Line =\n/** @class */\nfunction () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  Line.prototype.getBBox = function () {\n    var minX = Math.min(this.x1, this.x2);\n    var minY = Math.min(this.y1, this.y2);\n    var maxX = Math.max(this.x1, this.x2);\n    var maxY = Math.max(this.y1, this.y2);\n    var res = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return res;\n  };\n\n  return Line;\n}();\n\nexport { Line };\nexport var getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\n  var bounds = {\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\n  };\n  return bounds[direction];\n};\n/**\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\n */\n\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n\n  if (uB) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return ua;\n    }\n  }\n\n  return Number.POSITIVE_INFINITY;\n};\n\nexport var itemIntersectByLine = function itemIntersectByLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var countIntersections = 0;\n  var intersections = [];\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    intersections[i] = getLineIntersect({\n      x: line.x1,\n      y: line.y1\n    }, {\n      x: line.x2,\n      y: line.y2\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x2,\n      y: y2\n    });\n\n    if (intersections[i]) {\n      countIntersections += 1;\n    }\n  }\n\n  return [intersections, countIntersections];\n};\nexport var fractionToLine = function fractionToLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var minDistance = Number.POSITIVE_INFINITY;\n  var countIntersections = 0;\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\n    testDistance = Math.abs(testDistance - 0.5);\n\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections += 1;\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\n    }\n  }\n\n  if (countIntersections === 0) return -1;\n  return minDistance;\n};\nexport var getPointsCenter = function getPointsCenter(points) {\n  var centerX = 0;\n  var centerY = 0;\n\n  if (points.length > 0) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      centerX += point.x;\n      centerY += point.y;\n    }\n\n    centerX /= points.length;\n    centerY /= points.length;\n  }\n\n  return {\n    x: centerX,\n    y: centerY\n  };\n};\nexport var squareDist = function squareDist(a, b) {\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n};\nexport var pointLineSquareDist = function pointLineSquareDist(point, line) {\n  var x1 = line.x1;\n  var y1 = line.y1;\n  var x2 = line.x2 - x1;\n  var y2 = line.y2 - y1;\n  var px = point.x - x1;\n  var py = point.y - y1;\n  var dotprod = px * x2 + py * y2;\n  var projlenSq;\n\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n\n  var lenSq = px * px + py * py - projlenSq;\n\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n\n  return lenSq;\n};\nexport var isPointsOverlap = function isPointsOverlap(p1, p2, e) {\n  if (e === void 0) {\n    e = 1e-3;\n  }\n\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\n};\n/**\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\n * @param point IPoint\n * @param rect IRect\n */\n\nexport var pointRectSquareDist = function pointRectSquareDist(point, rect) {\n  var isLeft = point.x < rect.x;\n  var isRight = point.x > rect.x + rect.width;\n  var isTop = point.y > rect.y + rect.height;\n  var isBottom = point.y < rect.y;\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\n\n  if (!isPointOutside) {\n    return 0;\n  }\n\n  if (isTop && !isLeft && !isRight) {\n    return Math.pow(rect.y + rect.height - point.y, 2);\n  }\n\n  if (isBottom && !isLeft && !isRight) {\n    return Math.pow(point.y - rect.y, 2);\n  }\n\n  if (isLeft && !isTop && !isBottom) {\n    return Math.pow(rect.x - point.x, 2);\n  }\n\n  if (isRight && !isTop && !isBottom) {\n    return Math.pow(rect.x + rect.width - point.x, 2);\n  }\n\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\n  return dx * dx + dy * dy;\n};"]},"metadata":{},"sourceType":"module"}