{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar tslib_1 = require(\"tslib\");\n\nvar BoundingRect_1 = require(\"zrender/lib/core/BoundingRect\");\n\nvar Cartesian_1 = require(\"./Cartesian\");\n\nvar matrix_1 = require(\"zrender/lib/core/matrix\");\n\nvar vector_1 = require(\"zrender/lib/core/vector\");\n\nexports.cartesian2DDimensions = ['x', 'y'];\n\nfunction canCalculateAffineTransform(scale) {\n  return scale.type === 'interval' || scale.type === 'time';\n}\n\nvar Cartesian2D = function (_super) {\n  tslib_1.__extends(Cartesian2D, _super);\n\n  function Cartesian2D() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'cartesian2d';\n    _this.dimensions = exports.cartesian2DDimensions;\n    return _this;\n  }\n\n  Cartesian2D.prototype.calcAffineTransform = function () {\n    this._transform = this._invTransform = null;\n    var xAxisScale = this.getAxis('x').scale;\n    var yAxisScale = this.getAxis('y').scale;\n\n    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n      return;\n    }\n\n    var xScaleExtent = xAxisScale.getExtent();\n    var yScaleExtent = yAxisScale.getExtent();\n    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n\n    if (!xScaleSpan || !yScaleSpan) {\n      return;\n    }\n\n    var scaleX = (end[0] - start[0]) / xScaleSpan;\n    var scaleY = (end[1] - start[1]) / yScaleSpan;\n    var translateX = start[0] - xScaleExtent[0] * scaleX;\n    var translateY = start[1] - yScaleExtent[0] * scaleY;\n    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n    this._invTransform = matrix_1.invert([], m);\n  };\n\n  Cartesian2D.prototype.getBaseAxis = function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  };\n\n  Cartesian2D.prototype.containPoint = function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  };\n\n  Cartesian2D.prototype.containData = function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  };\n\n  Cartesian2D.prototype.dataToPoint = function (data, reserved, out) {\n    out = out || [];\n    var xVal = data[0];\n    var yVal = data[1];\n\n    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n      return vector_1.applyTransform(out, data, this._transform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal));\n    return out;\n  };\n\n  Cartesian2D.prototype.clampData = function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  };\n\n  Cartesian2D.prototype.pointToData = function (point, out) {\n    out = out || [];\n\n    if (this._invTransform) {\n      return vector_1.applyTransform(out, point, this._invTransform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n    return out;\n  };\n\n  Cartesian2D.prototype.getOtherAxis = function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  };\n\n  Cartesian2D.prototype.getArea = function () {\n    var xExtent = this.getAxis('x').getGlobalExtent();\n    var yExtent = this.getAxis('y').getGlobalExtent();\n    var x = Math.min(xExtent[0], xExtent[1]);\n    var y = Math.min(yExtent[0], yExtent[1]);\n    var width = Math.max(xExtent[0], xExtent[1]) - x;\n    var height = Math.max(yExtent[0], yExtent[1]) - y;\n    return new BoundingRect_1[\"default\"](x, y, width, height);\n  };\n\n  return Cartesian2D;\n}(Cartesian_1[\"default\"]);\n\n;\nexports[\"default\"] = Cartesian2D;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/coord/cartesian/Cartesian2D.js"],"names":["exports","__esModule","tslib_1","require","BoundingRect_1","Cartesian_1","matrix_1","vector_1","cartesian2DDimensions","canCalculateAffineTransform","scale","type","Cartesian2D","_super","__extends","_this","apply","arguments","dimensions","prototype","calcAffineTransform","_transform","_invTransform","xAxisScale","getAxis","yAxisScale","xScaleExtent","getExtent","yScaleExtent","start","dataToPoint","end","xScaleSpan","yScaleSpan","scaleX","scaleY","translateX","translateY","m","invert","getBaseAxis","getAxesByScale","containPoint","point","axisX","axisY","contain","toLocalCoord","containData","data","reserved","out","xVal","yVal","isFinite","applyTransform","xAxis","yAxis","toGlobalCoord","dataToCoord","clampData","xScale","yScale","xAxisExtent","yAxisExtent","x","parse","y","Math","min","max","pointToData","coordToData","getOtherAxis","axis","dim","getArea","xExtent","getGlobalExtent","yExtent","width","height"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEA,IAAIC,cAAc,GAAGD,OAAO,CAAC,+BAAD,CAA5B;;AAEA,IAAIE,WAAW,GAAGF,OAAO,CAAC,aAAD,CAAzB;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,yBAAD,CAAtB;;AAEA,IAAII,QAAQ,GAAGJ,OAAO,CAAC,yBAAD,CAAtB;;AAEAH,OAAO,CAACQ,qBAAR,GAAgC,CAAC,GAAD,EAAM,GAAN,CAAhC;;AAEA,SAASC,2BAAT,CAAqCC,KAArC,EAA4C;AAC1C,SAAOA,KAAK,CAACC,IAAN,KAAe,UAAf,IAA6BD,KAAK,CAACC,IAAN,KAAe,MAAnD;AACD;;AAED,IAAIC,WAAW,GAAG,UAAUC,MAAV,EAAkB;AAClCX,EAAAA,OAAO,CAACY,SAAR,CAAkBF,WAAlB,EAA+BC,MAA/B;;AAEA,WAASD,WAAT,GAAuB;AACrB,QAAIG,KAAK,GAAGF,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACG,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AAEAF,IAAAA,KAAK,CAACJ,IAAN,GAAa,aAAb;AACAI,IAAAA,KAAK,CAACG,UAAN,GAAmBlB,OAAO,CAACQ,qBAA3B;AACA,WAAOO,KAAP;AACD;;AAEDH,EAAAA,WAAW,CAACO,SAAZ,CAAsBC,mBAAtB,GAA4C,YAAY;AACtD,SAAKC,UAAL,GAAkB,KAAKC,aAAL,GAAqB,IAAvC;AACA,QAAIC,UAAU,GAAG,KAAKC,OAAL,CAAa,GAAb,EAAkBd,KAAnC;AACA,QAAIe,UAAU,GAAG,KAAKD,OAAL,CAAa,GAAb,EAAkBd,KAAnC;;AAEA,QAAI,CAACD,2BAA2B,CAACc,UAAD,CAA5B,IAA4C,CAACd,2BAA2B,CAACgB,UAAD,CAA5E,EAA0F;AACxF;AACD;;AAED,QAAIC,YAAY,GAAGH,UAAU,CAACI,SAAX,EAAnB;AACA,QAAIC,YAAY,GAAGH,UAAU,CAACE,SAAX,EAAnB;AACA,QAAIE,KAAK,GAAG,KAAKC,WAAL,CAAiB,CAACJ,YAAY,CAAC,CAAD,CAAb,EAAkBE,YAAY,CAAC,CAAD,CAA9B,CAAjB,CAAZ;AACA,QAAIG,GAAG,GAAG,KAAKD,WAAL,CAAiB,CAACJ,YAAY,CAAC,CAAD,CAAb,EAAkBE,YAAY,CAAC,CAAD,CAA9B,CAAjB,CAAV;AACA,QAAII,UAAU,GAAGN,YAAY,CAAC,CAAD,CAAZ,GAAkBA,YAAY,CAAC,CAAD,CAA/C;AACA,QAAIO,UAAU,GAAGL,YAAY,CAAC,CAAD,CAAZ,GAAkBA,YAAY,CAAC,CAAD,CAA/C;;AAEA,QAAI,CAACI,UAAD,IAAe,CAACC,UAApB,EAAgC;AAC9B;AACD;;AAED,QAAIC,MAAM,GAAG,CAACH,GAAG,CAAC,CAAD,CAAH,GAASF,KAAK,CAAC,CAAD,CAAf,IAAsBG,UAAnC;AACA,QAAIG,MAAM,GAAG,CAACJ,GAAG,CAAC,CAAD,CAAH,GAASF,KAAK,CAAC,CAAD,CAAf,IAAsBI,UAAnC;AACA,QAAIG,UAAU,GAAGP,KAAK,CAAC,CAAD,CAAL,GAAWH,YAAY,CAAC,CAAD,CAAZ,GAAkBQ,MAA9C;AACA,QAAIG,UAAU,GAAGR,KAAK,CAAC,CAAD,CAAL,GAAWD,YAAY,CAAC,CAAD,CAAZ,GAAkBO,MAA9C;AACA,QAAIG,CAAC,GAAG,KAAKjB,UAAL,GAAkB,CAACa,MAAD,EAAS,CAAT,EAAY,CAAZ,EAAeC,MAAf,EAAuBC,UAAvB,EAAmCC,UAAnC,CAA1B;AACA,SAAKf,aAAL,GAAqBhB,QAAQ,CAACiC,MAAT,CAAgB,EAAhB,EAAoBD,CAApB,CAArB;AACD,GA1BD;;AA4BA1B,EAAAA,WAAW,CAACO,SAAZ,CAAsBqB,WAAtB,GAAoC,YAAY;AAC9C,WAAO,KAAKC,cAAL,CAAoB,SAApB,EAA+B,CAA/B,KAAqC,KAAKA,cAAL,CAAoB,MAApB,EAA4B,CAA5B,CAArC,IAAuE,KAAKjB,OAAL,CAAa,GAAb,CAA9E;AACD,GAFD;;AAIAZ,EAAAA,WAAW,CAACO,SAAZ,CAAsBuB,YAAtB,GAAqC,UAAUC,KAAV,EAAiB;AACpD,QAAIC,KAAK,GAAG,KAAKpB,OAAL,CAAa,GAAb,CAAZ;AACA,QAAIqB,KAAK,GAAG,KAAKrB,OAAL,CAAa,GAAb,CAAZ;AACA,WAAOoB,KAAK,CAACE,OAAN,CAAcF,KAAK,CAACG,YAAN,CAAmBJ,KAAK,CAAC,CAAD,CAAxB,CAAd,KAA+CE,KAAK,CAACC,OAAN,CAAcD,KAAK,CAACE,YAAN,CAAmBJ,KAAK,CAAC,CAAD,CAAxB,CAAd,CAAtD;AACD,GAJD;;AAMA/B,EAAAA,WAAW,CAACO,SAAZ,CAAsB6B,WAAtB,GAAoC,UAAUC,IAAV,EAAgB;AAClD,WAAO,KAAKzB,OAAL,CAAa,GAAb,EAAkBwB,WAAlB,CAA8BC,IAAI,CAAC,CAAD,CAAlC,KAA0C,KAAKzB,OAAL,CAAa,GAAb,EAAkBwB,WAAlB,CAA8BC,IAAI,CAAC,CAAD,CAAlC,CAAjD;AACD,GAFD;;AAIArC,EAAAA,WAAW,CAACO,SAAZ,CAAsBW,WAAtB,GAAoC,UAAUmB,IAAV,EAAgBC,QAAhB,EAA0BC,GAA1B,EAA+B;AACjEA,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACA,QAAIC,IAAI,GAAGH,IAAI,CAAC,CAAD,CAAf;AACA,QAAII,IAAI,GAAGJ,IAAI,CAAC,CAAD,CAAf;;AAEA,QAAI,KAAK5B,UAAL,IAAmB+B,IAAI,IAAI,IAA3B,IAAmCE,QAAQ,CAACF,IAAD,CAA3C,IAAqDC,IAAI,IAAI,IAA7D,IAAqEC,QAAQ,CAACD,IAAD,CAAjF,EAAyF;AACvF,aAAO9C,QAAQ,CAACgD,cAAT,CAAwBJ,GAAxB,EAA6BF,IAA7B,EAAmC,KAAK5B,UAAxC,CAAP;AACD;;AAED,QAAImC,KAAK,GAAG,KAAKhC,OAAL,CAAa,GAAb,CAAZ;AACA,QAAIiC,KAAK,GAAG,KAAKjC,OAAL,CAAa,GAAb,CAAZ;AACA2B,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASK,KAAK,CAACE,aAAN,CAAoBF,KAAK,CAACG,WAAN,CAAkBP,IAAlB,CAApB,CAAT;AACAD,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASM,KAAK,CAACC,aAAN,CAAoBD,KAAK,CAACE,WAAN,CAAkBN,IAAlB,CAApB,CAAT;AACA,WAAOF,GAAP;AACD,GAdD;;AAgBAvC,EAAAA,WAAW,CAACO,SAAZ,CAAsByC,SAAtB,GAAkC,UAAUX,IAAV,EAAgBE,GAAhB,EAAqB;AACrD,QAAIU,MAAM,GAAG,KAAKrC,OAAL,CAAa,GAAb,EAAkBd,KAA/B;AACA,QAAIoD,MAAM,GAAG,KAAKtC,OAAL,CAAa,GAAb,EAAkBd,KAA/B;AACA,QAAIqD,WAAW,GAAGF,MAAM,CAAClC,SAAP,EAAlB;AACA,QAAIqC,WAAW,GAAGF,MAAM,CAACnC,SAAP,EAAlB;AACA,QAAIsC,CAAC,GAAGJ,MAAM,CAACK,KAAP,CAAajB,IAAI,CAAC,CAAD,CAAjB,CAAR;AACA,QAAIkB,CAAC,GAAGL,MAAM,CAACI,KAAP,CAAajB,IAAI,CAAC,CAAD,CAAjB,CAAR;AACAE,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACAA,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASiB,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASF,IAAI,CAACC,GAAL,CAASN,WAAW,CAAC,CAAD,CAApB,EAAyBA,WAAW,CAAC,CAAD,CAApC,CAAT,EAAmDE,CAAnD,CAAT,EAAgEG,IAAI,CAACE,GAAL,CAASP,WAAW,CAAC,CAAD,CAApB,EAAyBA,WAAW,CAAC,CAAD,CAApC,CAAhE,CAAT;AACAZ,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASiB,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASF,IAAI,CAACC,GAAL,CAASL,WAAW,CAAC,CAAD,CAApB,EAAyBA,WAAW,CAAC,CAAD,CAApC,CAAT,EAAmDG,CAAnD,CAAT,EAAgEC,IAAI,CAACE,GAAL,CAASN,WAAW,CAAC,CAAD,CAApB,EAAyBA,WAAW,CAAC,CAAD,CAApC,CAAhE,CAAT;AACA,WAAOb,GAAP;AACD,GAXD;;AAaAvC,EAAAA,WAAW,CAACO,SAAZ,CAAsBoD,WAAtB,GAAoC,UAAU5B,KAAV,EAAiBQ,GAAjB,EAAsB;AACxDA,IAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;;AAEA,QAAI,KAAK7B,aAAT,EAAwB;AACtB,aAAOf,QAAQ,CAACgD,cAAT,CAAwBJ,GAAxB,EAA6BR,KAA7B,EAAoC,KAAKrB,aAAzC,CAAP;AACD;;AAED,QAAIkC,KAAK,GAAG,KAAKhC,OAAL,CAAa,GAAb,CAAZ;AACA,QAAIiC,KAAK,GAAG,KAAKjC,OAAL,CAAa,GAAb,CAAZ;AACA2B,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASK,KAAK,CAACgB,WAAN,CAAkBhB,KAAK,CAACT,YAAN,CAAmBJ,KAAK,CAAC,CAAD,CAAxB,CAAlB,CAAT;AACAQ,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASM,KAAK,CAACe,WAAN,CAAkBf,KAAK,CAACV,YAAN,CAAmBJ,KAAK,CAAC,CAAD,CAAxB,CAAlB,CAAT;AACA,WAAOQ,GAAP;AACD,GAZD;;AAcAvC,EAAAA,WAAW,CAACO,SAAZ,CAAsBsD,YAAtB,GAAqC,UAAUC,IAAV,EAAgB;AACnD,WAAO,KAAKlD,OAAL,CAAakD,IAAI,CAACC,GAAL,KAAa,GAAb,GAAmB,GAAnB,GAAyB,GAAtC,CAAP;AACD,GAFD;;AAIA/D,EAAAA,WAAW,CAACO,SAAZ,CAAsByD,OAAtB,GAAgC,YAAY;AAC1C,QAAIC,OAAO,GAAG,KAAKrD,OAAL,CAAa,GAAb,EAAkBsD,eAAlB,EAAd;AACA,QAAIC,OAAO,GAAG,KAAKvD,OAAL,CAAa,GAAb,EAAkBsD,eAAlB,EAAd;AACA,QAAIb,CAAC,GAAGG,IAAI,CAACC,GAAL,CAASQ,OAAO,CAAC,CAAD,CAAhB,EAAqBA,OAAO,CAAC,CAAD,CAA5B,CAAR;AACA,QAAIV,CAAC,GAAGC,IAAI,CAACC,GAAL,CAASU,OAAO,CAAC,CAAD,CAAhB,EAAqBA,OAAO,CAAC,CAAD,CAA5B,CAAR;AACA,QAAIC,KAAK,GAAGZ,IAAI,CAACE,GAAL,CAASO,OAAO,CAAC,CAAD,CAAhB,EAAqBA,OAAO,CAAC,CAAD,CAA5B,IAAmCZ,CAA/C;AACA,QAAIgB,MAAM,GAAGb,IAAI,CAACE,GAAL,CAASS,OAAO,CAAC,CAAD,CAAhB,EAAqBA,OAAO,CAAC,CAAD,CAA5B,IAAmCZ,CAAhD;AACA,WAAO,IAAI/D,cAAc,CAAC,SAAD,CAAlB,CAA8B6D,CAA9B,EAAiCE,CAAjC,EAAoCa,KAApC,EAA2CC,MAA3C,CAAP;AACD,GARD;;AAUA,SAAOrE,WAAP;AACD,CA/GiB,CA+GhBP,WAAW,CAAC,SAAD,CA/GK,CAAlB;;AAiHA;AACAL,OAAO,CAAC,SAAD,CAAP,GAAqBY,WAArB","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar tslib_1 = require(\"tslib\");\n\nvar BoundingRect_1 = require(\"zrender/lib/core/BoundingRect\");\n\nvar Cartesian_1 = require(\"./Cartesian\");\n\nvar matrix_1 = require(\"zrender/lib/core/matrix\");\n\nvar vector_1 = require(\"zrender/lib/core/vector\");\n\nexports.cartesian2DDimensions = ['x', 'y'];\n\nfunction canCalculateAffineTransform(scale) {\n  return scale.type === 'interval' || scale.type === 'time';\n}\n\nvar Cartesian2D = function (_super) {\n  tslib_1.__extends(Cartesian2D, _super);\n\n  function Cartesian2D() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'cartesian2d';\n    _this.dimensions = exports.cartesian2DDimensions;\n    return _this;\n  }\n\n  Cartesian2D.prototype.calcAffineTransform = function () {\n    this._transform = this._invTransform = null;\n    var xAxisScale = this.getAxis('x').scale;\n    var yAxisScale = this.getAxis('y').scale;\n\n    if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {\n      return;\n    }\n\n    var xScaleExtent = xAxisScale.getExtent();\n    var yScaleExtent = yAxisScale.getExtent();\n    var start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]]);\n    var end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]]);\n    var xScaleSpan = xScaleExtent[1] - xScaleExtent[0];\n    var yScaleSpan = yScaleExtent[1] - yScaleExtent[0];\n\n    if (!xScaleSpan || !yScaleSpan) {\n      return;\n    }\n\n    var scaleX = (end[0] - start[0]) / xScaleSpan;\n    var scaleY = (end[1] - start[1]) / yScaleSpan;\n    var translateX = start[0] - xScaleExtent[0] * scaleX;\n    var translateY = start[1] - yScaleExtent[0] * scaleY;\n    var m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY];\n    this._invTransform = matrix_1.invert([], m);\n  };\n\n  Cartesian2D.prototype.getBaseAxis = function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  };\n\n  Cartesian2D.prototype.containPoint = function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  };\n\n  Cartesian2D.prototype.containData = function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  };\n\n  Cartesian2D.prototype.dataToPoint = function (data, reserved, out) {\n    out = out || [];\n    var xVal = data[0];\n    var yVal = data[1];\n\n    if (this._transform && xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {\n      return vector_1.applyTransform(out, data, this._transform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal));\n    out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal));\n    return out;\n  };\n\n  Cartesian2D.prototype.clampData = function (data, out) {\n    var xScale = this.getAxis('x').scale;\n    var yScale = this.getAxis('y').scale;\n    var xAxisExtent = xScale.getExtent();\n    var yAxisExtent = yScale.getExtent();\n    var x = xScale.parse(data[0]);\n    var y = yScale.parse(data[1]);\n    out = out || [];\n    out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]));\n    out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]));\n    return out;\n  };\n\n  Cartesian2D.prototype.pointToData = function (point, out) {\n    out = out || [];\n\n    if (this._invTransform) {\n      return vector_1.applyTransform(out, point, this._invTransform);\n    }\n\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]));\n    out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]));\n    return out;\n  };\n\n  Cartesian2D.prototype.getOtherAxis = function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  };\n\n  Cartesian2D.prototype.getArea = function () {\n    var xExtent = this.getAxis('x').getGlobalExtent();\n    var yExtent = this.getAxis('y').getGlobalExtent();\n    var x = Math.min(xExtent[0], xExtent[1]);\n    var y = Math.min(yExtent[0], yExtent[1]);\n    var width = Math.max(xExtent[0], xExtent[1]) - x;\n    var height = Math.max(yExtent[0], yExtent[1]) - y;\n    return new BoundingRect_1[\"default\"](x, y, width, height);\n  };\n\n  return Cartesian2D;\n}(Cartesian_1[\"default\"]);\n\n;\nexports[\"default\"] = Cartesian2D;"]},"metadata":{},"sourceType":"script"}