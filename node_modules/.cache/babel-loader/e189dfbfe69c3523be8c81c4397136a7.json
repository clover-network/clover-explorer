{"ast":null,"code":"\"use strict\";\n/**\n * @fileoverview 圆\n * @author dxq613@gmail.com\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n\nvar base_1 = require(\"./base\");\n\nvar util_1 = require(\"../util/util\"); // TODO: 暂时不需要圆的工具方法，后续如果需要支持 pointAt，tangentAngle 时再引入\n// import CircleUtil from '@antv/g-math/lib/circle';\n\n\nvar Circle =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Circle, _super);\n\n  function Circle() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Circle.prototype.getDefaultAttrs = function () {\n    var attrs = _super.prototype.getDefaultAttrs.call(this);\n\n    return tslib_1.__assign(tslib_1.__assign({}, attrs), {\n      x: 0,\n      y: 0,\n      r: 0\n    });\n  };\n\n  Circle.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n    var attrs = this.attr();\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var r = attrs.r;\n    var halfLineWidth = lineWidth / 2;\n    var absDistance = util_1.distance(cx, cy, x, y); // 直接用距离，如果同时存在边和填充时，可以减少两次计算\n\n    if (isFill && isStroke) {\n      return absDistance <= r + halfLineWidth;\n    }\n\n    if (isFill) {\n      return absDistance <= r;\n    }\n\n    if (isStroke) {\n      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n    }\n\n    return false;\n  };\n\n  Circle.prototype.createPath = function (context) {\n    var attrs = this.attr();\n    var cx = attrs.x;\n    var cy = attrs.y;\n    var r = attrs.r;\n    context.beginPath();\n    context.arc(cx, cy, r, 0, Math.PI * 2, false);\n    context.closePath();\n  };\n\n  return Circle;\n}(base_1.default);\n\nexports.default = Circle;","map":{"version":3,"sources":["../../src/shape/circle.ts"],"names":[],"mappings":";AAAA;;;AAGG;;;;;;;;AAEH,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,cAAA,CAAA,C,CAEA;AACA;;;AAEA,IAAA,MAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AAAqB,EAAA,OAAA,CAAA,SAAA,CAAA,MAAA,EAAA,MAAA;;AAArB,WAAA,MAAA,GAAA;;AAwCC;;AAvCC,EAAA,MAAA,CAAA,SAAA,CAAA,eAAA,GAAA,YAAA;AACE,QAAM,KAAK,GAAG,MAAA,CAAA,SAAA,CAAM,eAAN,CAAqB,IAArB,CAAqB,IAArB,CAAd;;AACA,WAAA,OAAA,CAAA,QAAA,CAAA,OAAA,CAAA,QAAA,CAAA,EAAA,EACK,KADL,CAAA,EACU;AACR,MAAA,CAAC,EAAE,CADK;AAER,MAAA,CAAC,EAAE,CAFK;AAGR,MAAA,CAAC,EAAE;AAHK,KADV,CAAA;AAMD,GARD;;AAUA,EAAA,MAAA,CAAA,SAAA,CAAA,gBAAA,GAAA,UAAiB,CAAjB,EAAoB,CAApB,EAAuB,QAAvB,EAAiC,MAAjC,EAAyC,SAAzC,EAAkD;AAChD,QAAM,KAAK,GAAG,KAAK,IAAL,EAAd;AACA,QAAM,EAAE,GAAG,KAAK,CAAC,CAAjB;AACA,QAAM,EAAE,GAAG,KAAK,CAAC,CAAjB;AACA,QAAM,CAAC,GAAG,KAAK,CAAC,CAAhB;AACA,QAAM,aAAa,GAAG,SAAS,GAAG,CAAlC;AACA,QAAM,WAAW,GAAG,MAAA,CAAA,QAAA,CAAS,EAAT,EAAa,EAAb,EAAiB,CAAjB,EAAoB,CAApB,CAApB,CANgD,CAOhD;;AACA,QAAI,MAAM,IAAI,QAAd,EAAwB;AACtB,aAAO,WAAW,IAAI,CAAC,GAAG,aAA1B;AACD;;AACD,QAAI,MAAJ,EAAY;AACV,aAAO,WAAW,IAAI,CAAtB;AACD;;AACD,QAAI,QAAJ,EAAc;AACZ,aAAO,WAAW,IAAI,CAAC,GAAG,aAAnB,IAAoC,WAAW,IAAI,CAAC,GAAG,aAA9D;AACD;;AACD,WAAO,KAAP;AACD,GAlBD;;AAoBA,EAAA,MAAA,CAAA,SAAA,CAAA,UAAA,GAAA,UAAW,OAAX,EAAkB;AAChB,QAAM,KAAK,GAAG,KAAK,IAAL,EAAd;AACA,QAAM,EAAE,GAAG,KAAK,CAAC,CAAjB;AACA,QAAM,EAAE,GAAG,KAAK,CAAC,CAAjB;AACA,QAAM,CAAC,GAAG,KAAK,CAAC,CAAhB;AACA,IAAA,OAAO,CAAC,SAAR;AACA,IAAA,OAAO,CAAC,GAAR,CAAY,EAAZ,EAAgB,EAAhB,EAAoB,CAApB,EAAuB,CAAvB,EAA0B,IAAI,CAAC,EAAL,GAAU,CAApC,EAAuC,KAAvC;AACA,IAAA,OAAO,CAAC,SAAR;AACD,GARD;;AASF,SAAA,MAAA;AAAC,CAxCD,CAAqB,MAAA,CAAA,OAArB,CAAA;;AA0CA,OAAA,CAAA,OAAA,GAAe,MAAf","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * @fileoverview 圆\n * @author dxq613@gmail.com\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar base_1 = require(\"./base\");\nvar util_1 = require(\"../util/util\");\n// TODO: 暂时不需要圆的工具方法，后续如果需要支持 pointAt，tangentAngle 时再引入\n// import CircleUtil from '@antv/g-math/lib/circle';\nvar Circle = /** @class */ (function (_super) {\n    tslib_1.__extends(Circle, _super);\n    function Circle() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Circle.prototype.getDefaultAttrs = function () {\n        var attrs = _super.prototype.getDefaultAttrs.call(this);\n        return tslib_1.__assign(tslib_1.__assign({}, attrs), { x: 0, y: 0, r: 0 });\n    };\n    Circle.prototype.isInStrokeOrPath = function (x, y, isStroke, isFill, lineWidth) {\n        var attrs = this.attr();\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var r = attrs.r;\n        var halfLineWidth = lineWidth / 2;\n        var absDistance = util_1.distance(cx, cy, x, y);\n        // 直接用距离，如果同时存在边和填充时，可以减少两次计算\n        if (isFill && isStroke) {\n            return absDistance <= r + halfLineWidth;\n        }\n        if (isFill) {\n            return absDistance <= r;\n        }\n        if (isStroke) {\n            return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;\n        }\n        return false;\n    };\n    Circle.prototype.createPath = function (context) {\n        var attrs = this.attr();\n        var cx = attrs.x;\n        var cy = attrs.y;\n        var r = attrs.r;\n        context.beginPath();\n        context.arc(cx, cy, r, 0, Math.PI * 2, false);\n        context.closePath();\n    };\n    return Circle;\n}(base_1.default));\nexports.default = Circle;\n//# sourceMappingURL=circle.js.map"]},"metadata":{},"sourceType":"script"}