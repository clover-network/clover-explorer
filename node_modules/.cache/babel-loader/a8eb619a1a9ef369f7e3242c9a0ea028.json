{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar Group_1 = require(\"../graphic/Group\");\n\nvar Image_1 = require(\"../graphic/Image\");\n\nvar Circle_1 = require(\"../graphic/shape/Circle\");\n\nvar Rect_1 = require(\"../graphic/shape/Rect\");\n\nvar Ellipse_1 = require(\"../graphic/shape/Ellipse\");\n\nvar Line_1 = require(\"../graphic/shape/Line\");\n\nvar Path_1 = require(\"../graphic/Path\");\n\nvar Polygon_1 = require(\"../graphic/shape/Polygon\");\n\nvar Polyline_1 = require(\"../graphic/shape/Polyline\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar path_1 = require(\"./path\");\n\nvar util_1 = require(\"../core/util\");\n\nvar LinearGradient_1 = require(\"../graphic/LinearGradient\");\n\nvar TSpan_1 = require(\"../graphic/TSpan\");\n\nvar DILIMITER_REG = /[\\s,]+/;\n\nfunction parseXML(svg) {\n  if (util_1.isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  }\n\n  var svgNode = svg;\n\n  if (svgNode.nodeType === 9) {\n    svgNode = svgNode.firstChild;\n  }\n\n  while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n    svgNode = svgNode.nextSibling;\n  }\n\n  return svgNode;\n}\n\nexports.parseXML = parseXML;\nvar nodeParsers;\n\nvar SVGParser = function () {\n  function SVGParser() {\n    this._defs = {};\n    this._root = null;\n    this._isDefine = false;\n    this._isText = false;\n  }\n\n  SVGParser.prototype.parse = function (xml, opt) {\n    opt = opt || {};\n    var svg = parseXML(xml);\n\n    if (!svg) {\n      throw new Error('Illegal svg');\n    }\n\n    var root = new Group_1[\"default\"]();\n    this._root = root;\n    var viewBox = svg.getAttribute('viewBox') || '';\n    var width = parseFloat(svg.getAttribute('width') || opt.width);\n    var height = parseFloat(svg.getAttribute('height') || opt.height);\n    isNaN(width) && (width = null);\n    isNaN(height) && (height = null);\n    parseAttributes(svg, root, null, true);\n    var child = svg.firstChild;\n\n    while (child) {\n      this._parseNode(child, root);\n\n      child = child.nextSibling;\n    }\n\n    var viewBoxRect;\n    var viewBoxTransform;\n\n    if (viewBox) {\n      var viewBoxArr = util_1.trim(viewBox).split(DILIMITER_REG);\n\n      if (viewBoxArr.length >= 4) {\n        viewBoxRect = {\n          x: parseFloat(viewBoxArr[0] || 0),\n          y: parseFloat(viewBoxArr[1] || 0),\n          width: parseFloat(viewBoxArr[2]),\n          height: parseFloat(viewBoxArr[3])\n        };\n      }\n    }\n\n    if (viewBoxRect && width != null && height != null) {\n      viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n      if (!opt.ignoreViewBox) {\n        var elRoot = root;\n        root = new Group_1[\"default\"]();\n        root.add(elRoot);\n        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n        elRoot.x = viewBoxTransform.x;\n        elRoot.y = viewBoxTransform.y;\n      }\n    }\n\n    if (!opt.ignoreRootClip && width != null && height != null) {\n      root.setClipPath(new Rect_1[\"default\"]({\n        shape: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      }));\n    }\n\n    return {\n      root: root,\n      width: width,\n      height: height,\n      viewBoxRect: viewBoxRect,\n      viewBoxTransform: viewBoxTransform\n    };\n  };\n\n  SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n    var nodeName = xmlNode.nodeName.toLowerCase();\n\n    if (nodeName === 'defs') {\n      this._isDefine = true;\n    } else if (nodeName === 'text') {\n      this._isText = true;\n    }\n\n    var el;\n\n    if (this._isDefine) {\n      var parser = defineParsers[nodeName];\n\n      if (parser) {\n        var def = parser.call(this, xmlNode);\n        var id = xmlNode.getAttribute('id');\n\n        if (id) {\n          this._defs[id] = def;\n        }\n      }\n    } else {\n      var parser = nodeParsers[nodeName];\n\n      if (parser) {\n        el = parser.call(this, xmlNode, parentGroup);\n        parentGroup.add(el);\n      }\n    }\n\n    if (el) {\n      var child = xmlNode.firstChild;\n\n      while (child) {\n        if (child.nodeType === 1) {\n          this._parseNode(child, el);\n        }\n\n        if (child.nodeType === 3 && this._isText) {\n          this._parseText(child, el);\n        }\n\n        child = child.nextSibling;\n      }\n    }\n\n    if (nodeName === 'defs') {\n      this._isDefine = false;\n    } else if (nodeName === 'text') {\n      this._isText = false;\n    }\n  };\n\n  SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n    if (xmlNode.nodeType === 1) {\n      var dx = xmlNode.getAttribute('dx') || 0;\n      var dy = xmlNode.getAttribute('dy') || 0;\n      this._textX += parseFloat(dx);\n      this._textY += parseFloat(dy);\n    }\n\n    var text = new TSpan_1[\"default\"]({\n      style: {\n        text: xmlNode.textContent\n      },\n      x: this._textX || 0,\n      y: this._textY || 0\n    });\n    inheritStyle(parentGroup, text);\n    parseAttributes(xmlNode, text, this._defs);\n    var textStyle = text.style;\n    var fontSize = textStyle.fontSize;\n\n    if (fontSize && fontSize < 9) {\n      textStyle.fontSize = 9;\n      text.scaleX *= fontSize / 9;\n      text.scaleY *= fontSize / 9;\n    }\n\n    var font = (textStyle.fontSize || textStyle.fontFamily) && [textStyle.fontStyle, textStyle.fontWeight, (textStyle.fontSize || 12) + 'px', textStyle.fontFamily || 'sans-serif'].join(' ');\n    textStyle.font = font;\n    var rect = text.getBoundingRect();\n    this._textX += rect.width;\n    parentGroup.add(text);\n    return text;\n  };\n\n  SVGParser.internalField = function () {\n    nodeParsers = {\n      'g': function (xmlNode, parentGroup) {\n        var g = new Group_1[\"default\"]();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'rect': function (xmlNode, parentGroup) {\n        var rect = new Rect_1[\"default\"]();\n        inheritStyle(parentGroup, rect);\n        parseAttributes(xmlNode, rect, this._defs);\n        rect.setShape({\n          x: parseFloat(xmlNode.getAttribute('x') || '0'),\n          y: parseFloat(xmlNode.getAttribute('y') || '0'),\n          width: parseFloat(xmlNode.getAttribute('width') || '0'),\n          height: parseFloat(xmlNode.getAttribute('height') || '0')\n        });\n        return rect;\n      },\n      'circle': function (xmlNode, parentGroup) {\n        var circle = new Circle_1[\"default\"]();\n        inheritStyle(parentGroup, circle);\n        parseAttributes(xmlNode, circle, this._defs);\n        circle.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          r: parseFloat(xmlNode.getAttribute('r') || '0')\n        });\n        return circle;\n      },\n      'line': function (xmlNode, parentGroup) {\n        var line = new Line_1[\"default\"]();\n        inheritStyle(parentGroup, line);\n        parseAttributes(xmlNode, line, this._defs);\n        line.setShape({\n          x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n          y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n          x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n          y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n        });\n        return line;\n      },\n      'ellipse': function (xmlNode, parentGroup) {\n        var ellipse = new Ellipse_1[\"default\"]();\n        inheritStyle(parentGroup, ellipse);\n        parseAttributes(xmlNode, ellipse, this._defs);\n        ellipse.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n          ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n        });\n        return ellipse;\n      },\n      'polygon': function (xmlNode, parentGroup) {\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polygon = new Polygon_1[\"default\"]({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        inheritStyle(parentGroup, polygon);\n        parseAttributes(xmlNode, polygon, this._defs);\n        return polygon;\n      },\n      'polyline': function (xmlNode, parentGroup) {\n        var path = new Path_1[\"default\"]();\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polyline = new Polyline_1[\"default\"]({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        return polyline;\n      },\n      'image': function (xmlNode, parentGroup) {\n        var img = new Image_1[\"default\"]();\n        inheritStyle(parentGroup, img);\n        parseAttributes(xmlNode, img, this._defs);\n        img.setStyle({\n          image: xmlNode.getAttribute('xlink:href'),\n          x: +xmlNode.getAttribute('x'),\n          y: +xmlNode.getAttribute('y'),\n          width: +xmlNode.getAttribute('width'),\n          height: +xmlNode.getAttribute('height')\n        });\n        return img;\n      },\n      'text': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x') || '0';\n        var y = xmlNode.getAttribute('y') || '0';\n        var dx = xmlNode.getAttribute('dx') || '0';\n        var dy = xmlNode.getAttribute('dy') || '0';\n        this._textX = parseFloat(x) + parseFloat(dx);\n        this._textY = parseFloat(y) + parseFloat(dy);\n        var g = new Group_1[\"default\"]();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'tspan': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x');\n        var y = xmlNode.getAttribute('y');\n\n        if (x != null) {\n          this._textX = parseFloat(x);\n        }\n\n        if (y != null) {\n          this._textY = parseFloat(y);\n        }\n\n        var dx = xmlNode.getAttribute('dx') || 0;\n        var dy = xmlNode.getAttribute('dy') || 0;\n        var g = new Group_1[\"default\"]();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        this._textX += dx;\n        this._textY += dy;\n        return g;\n      },\n      'path': function (xmlNode, parentGroup) {\n        var d = xmlNode.getAttribute('d') || '';\n        var path = path_1.createFromString(d);\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        return path;\n      }\n    };\n  }();\n\n  return SVGParser;\n}();\n\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n    var gradient = new LinearGradient_1[\"default\"](x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  }\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offsetStr = stop.getAttribute('offset');\n      var offset = void 0;\n\n      if (offsetStr.indexOf('%') > 0) {\n        offset = parseInt(offsetStr, 10) / 100;\n      } else if (offsetStr) {\n        offset = parseFloat(offsetStr);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.colorStops.push({\n        offset: offset,\n        color: stopColor\n      });\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    util_1.defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = util_1.trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var disp = el;\n  var zrStyle = disp.__inheritedStyle || {};\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    util_1.extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  disp.style = disp.style || {};\n  zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n  util_1.each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  util_1.each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    disp.style.lineDash = util_1.map(util_1.trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n      return parseFloat(str);\n    });\n  }\n\n  disp.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = util_1.trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var transformOps_1 = [];\n    var m = null;\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps_1.push(type, value);\n      return '';\n    });\n\n    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n      var value = transformOps_1[i];\n      var type = transformOps_1[i - 1];\n      var valueArr = void 0;\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n          break;\n\n        case 'scale':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n          break;\n\n        case 'rotate':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(valueArr[0]));\n          break;\n\n        case 'skew':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          valueArr = util_1.trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(valueArr[0]);\n          m[1] = parseFloat(valueArr[1]);\n          m[2] = parseFloat(valueArr[2]);\n          m[3] = parseFloat(valueArr[3]);\n          m[4] = parseFloat(valueArr[4]);\n          m[5] = parseFloat(valueArr[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n}\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY);\n  return {\n    scale: scale,\n    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n  };\n}\n\nexports.makeViewBoxTransform = makeViewBoxTransform;\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseSVG = parseSVG;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/zrender/lib/tool/parseSVG.js"],"names":["exports","__esModule","Group_1","require","Image_1","Circle_1","Rect_1","Ellipse_1","Line_1","Path_1","Polygon_1","Polyline_1","matrix","path_1","util_1","LinearGradient_1","TSpan_1","DILIMITER_REG","parseXML","svg","isString","parser","DOMParser","parseFromString","svgNode","nodeType","firstChild","nodeName","toLowerCase","nextSibling","nodeParsers","SVGParser","_defs","_root","_isDefine","_isText","prototype","parse","xml","opt","Error","root","viewBox","getAttribute","width","parseFloat","height","isNaN","parseAttributes","child","_parseNode","viewBoxRect","viewBoxTransform","viewBoxArr","trim","split","length","x","y","makeViewBoxTransform","ignoreViewBox","elRoot","add","scaleX","scaleY","scale","ignoreRootClip","setClipPath","shape","xmlNode","parentGroup","el","defineParsers","def","call","id","_parseText","dx","dy","_textX","_textY","text","style","textContent","inheritStyle","textStyle","fontSize","font","fontFamily","fontStyle","fontWeight","join","rect","getBoundingRect","internalField","g","setShape","circle","cx","cy","r","line","x1","y1","x2","y2","ellipse","rx","ry","pointsStr","pointsArr","parsePoints","polygon","points","path","polyline","img","setStyle","image","d","createFromString","parseInt","gradient","_parseGradientColorStops","stop","offsetStr","offset","indexOf","stopColor","colorStops","push","color","parent","__inheritedStyle","defaults","pointsString","list","i","attributesMap","defs","onlyInlineStyle","disp","zrStyle","parseTransformAttribute","extend","parseStyleAttribute","svgAttrName","hasOwnProperty","attrValue","fill","getPaint","stroke","each","propName","textBaseline","textAlign","lineDash","map","str","urlRegex","urlMatch","match","url","transformRegex","node","transform","replace","transformOps_1","m","type","value","valueArr","create","translate","rotate","console","warn","setLocalTransform","styleRegex","result","styleList","lastIndex","styleRegResult","exec","Math","min","parseSVG"],"mappings":"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","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar Group_1 = require(\"../graphic/Group\");\nvar Image_1 = require(\"../graphic/Image\");\nvar Circle_1 = require(\"../graphic/shape/Circle\");\nvar Rect_1 = require(\"../graphic/shape/Rect\");\nvar Ellipse_1 = require(\"../graphic/shape/Ellipse\");\nvar Line_1 = require(\"../graphic/shape/Line\");\nvar Path_1 = require(\"../graphic/Path\");\nvar Polygon_1 = require(\"../graphic/shape/Polygon\");\nvar Polyline_1 = require(\"../graphic/shape/Polyline\");\nvar matrix = require(\"../core/matrix\");\nvar path_1 = require(\"./path\");\nvar util_1 = require(\"../core/util\");\nvar LinearGradient_1 = require(\"../graphic/LinearGradient\");\nvar TSpan_1 = require(\"../graphic/TSpan\");\nvar DILIMITER_REG = /[\\s,]+/;\nfunction parseXML(svg) {\n    if (util_1.isString(svg)) {\n        var parser = new DOMParser();\n        svg = parser.parseFromString(svg, 'text/xml');\n    }\n    var svgNode = svg;\n    if (svgNode.nodeType === 9) {\n        svgNode = svgNode.firstChild;\n    }\n    while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n        svgNode = svgNode.nextSibling;\n    }\n    return svgNode;\n}\nexports.parseXML = parseXML;\nvar nodeParsers;\nvar SVGParser = (function () {\n    function SVGParser() {\n        this._defs = {};\n        this._root = null;\n        this._isDefine = false;\n        this._isText = false;\n    }\n    SVGParser.prototype.parse = function (xml, opt) {\n        opt = opt || {};\n        var svg = parseXML(xml);\n        if (!svg) {\n            throw new Error('Illegal svg');\n        }\n        var root = new Group_1[\"default\"]();\n        this._root = root;\n        var viewBox = svg.getAttribute('viewBox') || '';\n        var width = parseFloat((svg.getAttribute('width') || opt.width));\n        var height = parseFloat((svg.getAttribute('height') || opt.height));\n        isNaN(width) && (width = null);\n        isNaN(height) && (height = null);\n        parseAttributes(svg, root, null, true);\n        var child = svg.firstChild;\n        while (child) {\n            this._parseNode(child, root);\n            child = child.nextSibling;\n        }\n        var viewBoxRect;\n        var viewBoxTransform;\n        if (viewBox) {\n            var viewBoxArr = util_1.trim(viewBox).split(DILIMITER_REG);\n            if (viewBoxArr.length >= 4) {\n                viewBoxRect = {\n                    x: parseFloat((viewBoxArr[0] || 0)),\n                    y: parseFloat((viewBoxArr[1] || 0)),\n                    width: parseFloat(viewBoxArr[2]),\n                    height: parseFloat(viewBoxArr[3])\n                };\n            }\n        }\n        if (viewBoxRect && width != null && height != null) {\n            viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n            if (!opt.ignoreViewBox) {\n                var elRoot = root;\n                root = new Group_1[\"default\"]();\n                root.add(elRoot);\n                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n                elRoot.x = viewBoxTransform.x;\n                elRoot.y = viewBoxTransform.y;\n            }\n        }\n        if (!opt.ignoreRootClip && width != null && height != null) {\n            root.setClipPath(new Rect_1[\"default\"]({\n                shape: { x: 0, y: 0, width: width, height: height }\n            }));\n        }\n        return {\n            root: root,\n            width: width,\n            height: height,\n            viewBoxRect: viewBoxRect,\n            viewBoxTransform: viewBoxTransform\n        };\n    };\n    SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n        var nodeName = xmlNode.nodeName.toLowerCase();\n        if (nodeName === 'defs') {\n            this._isDefine = true;\n        }\n        else if (nodeName === 'text') {\n            this._isText = true;\n        }\n        var el;\n        if (this._isDefine) {\n            var parser = defineParsers[nodeName];\n            if (parser) {\n                var def = parser.call(this, xmlNode);\n                var id = xmlNode.getAttribute('id');\n                if (id) {\n                    this._defs[id] = def;\n                }\n            }\n        }\n        else {\n            var parser = nodeParsers[nodeName];\n            if (parser) {\n                el = parser.call(this, xmlNode, parentGroup);\n                parentGroup.add(el);\n            }\n        }\n        if (el) {\n            var child = xmlNode.firstChild;\n            while (child) {\n                if (child.nodeType === 1) {\n                    this._parseNode(child, el);\n                }\n                if (child.nodeType === 3 && this._isText) {\n                    this._parseText(child, el);\n                }\n                child = child.nextSibling;\n            }\n        }\n        if (nodeName === 'defs') {\n            this._isDefine = false;\n        }\n        else if (nodeName === 'text') {\n            this._isText = false;\n        }\n    };\n    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n        if (xmlNode.nodeType === 1) {\n            var dx = xmlNode.getAttribute('dx') || 0;\n            var dy = xmlNode.getAttribute('dy') || 0;\n            this._textX += parseFloat(dx);\n            this._textY += parseFloat(dy);\n        }\n        var text = new TSpan_1[\"default\"]({\n            style: {\n                text: xmlNode.textContent\n            },\n            x: this._textX || 0,\n            y: this._textY || 0\n        });\n        inheritStyle(parentGroup, text);\n        parseAttributes(xmlNode, text, this._defs);\n        var textStyle = text.style;\n        var fontSize = textStyle.fontSize;\n        if (fontSize && fontSize < 9) {\n            textStyle.fontSize = 9;\n            text.scaleX *= fontSize / 9;\n            text.scaleY *= fontSize / 9;\n        }\n        var font = (textStyle.fontSize || textStyle.fontFamily) && [\n            textStyle.fontStyle,\n            textStyle.fontWeight,\n            (textStyle.fontSize || 12) + 'px',\n            textStyle.fontFamily || 'sans-serif'\n        ].join(' ');\n        textStyle.font = font;\n        var rect = text.getBoundingRect();\n        this._textX += rect.width;\n        parentGroup.add(text);\n        return text;\n    };\n    SVGParser.internalField = (function () {\n        nodeParsers = {\n            'g': function (xmlNode, parentGroup) {\n                var g = new Group_1[\"default\"]();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'rect': function (xmlNode, parentGroup) {\n                var rect = new Rect_1[\"default\"]();\n                inheritStyle(parentGroup, rect);\n                parseAttributes(xmlNode, rect, this._defs);\n                rect.setShape({\n                    x: parseFloat(xmlNode.getAttribute('x') || '0'),\n                    y: parseFloat(xmlNode.getAttribute('y') || '0'),\n                    width: parseFloat(xmlNode.getAttribute('width') || '0'),\n                    height: parseFloat(xmlNode.getAttribute('height') || '0')\n                });\n                return rect;\n            },\n            'circle': function (xmlNode, parentGroup) {\n                var circle = new Circle_1[\"default\"]();\n                inheritStyle(parentGroup, circle);\n                parseAttributes(xmlNode, circle, this._defs);\n                circle.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    r: parseFloat(xmlNode.getAttribute('r') || '0')\n                });\n                return circle;\n            },\n            'line': function (xmlNode, parentGroup) {\n                var line = new Line_1[\"default\"]();\n                inheritStyle(parentGroup, line);\n                parseAttributes(xmlNode, line, this._defs);\n                line.setShape({\n                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n                });\n                return line;\n            },\n            'ellipse': function (xmlNode, parentGroup) {\n                var ellipse = new Ellipse_1[\"default\"]();\n                inheritStyle(parentGroup, ellipse);\n                parseAttributes(xmlNode, ellipse, this._defs);\n                ellipse.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n                });\n                return ellipse;\n            },\n            'polygon': function (xmlNode, parentGroup) {\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polygon = new Polygon_1[\"default\"]({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                inheritStyle(parentGroup, polygon);\n                parseAttributes(xmlNode, polygon, this._defs);\n                return polygon;\n            },\n            'polyline': function (xmlNode, parentGroup) {\n                var path = new Path_1[\"default\"]();\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polyline = new Polyline_1[\"default\"]({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                return polyline;\n            },\n            'image': function (xmlNode, parentGroup) {\n                var img = new Image_1[\"default\"]();\n                inheritStyle(parentGroup, img);\n                parseAttributes(xmlNode, img, this._defs);\n                img.setStyle({\n                    image: xmlNode.getAttribute('xlink:href'),\n                    x: +xmlNode.getAttribute('x'),\n                    y: +xmlNode.getAttribute('y'),\n                    width: +xmlNode.getAttribute('width'),\n                    height: +xmlNode.getAttribute('height')\n                });\n                return img;\n            },\n            'text': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x') || '0';\n                var y = xmlNode.getAttribute('y') || '0';\n                var dx = xmlNode.getAttribute('dx') || '0';\n                var dy = xmlNode.getAttribute('dy') || '0';\n                this._textX = parseFloat(x) + parseFloat(dx);\n                this._textY = parseFloat(y) + parseFloat(dy);\n                var g = new Group_1[\"default\"]();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'tspan': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x');\n                var y = xmlNode.getAttribute('y');\n                if (x != null) {\n                    this._textX = parseFloat(x);\n                }\n                if (y != null) {\n                    this._textY = parseFloat(y);\n                }\n                var dx = xmlNode.getAttribute('dx') || 0;\n                var dy = xmlNode.getAttribute('dy') || 0;\n                var g = new Group_1[\"default\"]();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                this._textX += dx;\n                this._textY += dy;\n                return g;\n            },\n            'path': function (xmlNode, parentGroup) {\n                var d = xmlNode.getAttribute('d') || '';\n                var path = path_1.createFromString(d);\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                return path;\n            }\n        };\n    })();\n    return SVGParser;\n}());\nvar defineParsers = {\n    'lineargradient': function (xmlNode) {\n        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n        var gradient = new LinearGradient_1[\"default\"](x1, y1, x2, y2);\n        _parseGradientColorStops(xmlNode, gradient);\n        return gradient;\n    }\n};\nfunction _parseGradientColorStops(xmlNode, gradient) {\n    var stop = xmlNode.firstChild;\n    while (stop) {\n        if (stop.nodeType === 1) {\n            var offsetStr = stop.getAttribute('offset');\n            var offset = void 0;\n            if (offsetStr.indexOf('%') > 0) {\n                offset = parseInt(offsetStr, 10) / 100;\n            }\n            else if (offsetStr) {\n                offset = parseFloat(offsetStr);\n            }\n            else {\n                offset = 0;\n            }\n            var stopColor = stop.getAttribute('stop-color') || '#000000';\n            gradient.colorStops.push({\n                offset: offset,\n                color: stopColor\n            });\n        }\n        stop = stop.nextSibling;\n    }\n}\nfunction inheritStyle(parent, child) {\n    if (parent && parent.__inheritedStyle) {\n        if (!child.__inheritedStyle) {\n            child.__inheritedStyle = {};\n        }\n        util_1.defaults(child.__inheritedStyle, parent.__inheritedStyle);\n    }\n}\nfunction parsePoints(pointsString) {\n    var list = util_1.trim(pointsString).split(DILIMITER_REG);\n    var points = [];\n    for (var i = 0; i < list.length; i += 2) {\n        var x = parseFloat(list[i]);\n        var y = parseFloat(list[i + 1]);\n        points.push([x, y]);\n    }\n    return points;\n}\nvar attributesMap = {\n    'fill': 'fill',\n    'stroke': 'stroke',\n    'stroke-width': 'lineWidth',\n    'opacity': 'opacity',\n    'fill-opacity': 'fillOpacity',\n    'stroke-opacity': 'strokeOpacity',\n    'stroke-dasharray': 'lineDash',\n    'stroke-dashoffset': 'lineDashOffset',\n    'stroke-linecap': 'lineCap',\n    'stroke-linejoin': 'lineJoin',\n    'stroke-miterlimit': 'miterLimit',\n    'font-family': 'fontFamily',\n    'font-size': 'fontSize',\n    'font-style': 'fontStyle',\n    'font-weight': 'fontWeight',\n    'text-align': 'textAlign',\n    'alignment-baseline': 'textBaseline'\n};\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n    var disp = el;\n    var zrStyle = disp.__inheritedStyle || {};\n    if (xmlNode.nodeType === 1) {\n        parseTransformAttribute(xmlNode, el);\n        util_1.extend(zrStyle, parseStyleAttribute(xmlNode));\n        if (!onlyInlineStyle) {\n            for (var svgAttrName in attributesMap) {\n                if (attributesMap.hasOwnProperty(svgAttrName)) {\n                    var attrValue = xmlNode.getAttribute(svgAttrName);\n                    if (attrValue != null) {\n                        zrStyle[attributesMap[svgAttrName]] = attrValue;\n                    }\n                }\n            }\n        }\n    }\n    disp.style = disp.style || {};\n    zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n    zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n    util_1.each([\n        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n    });\n    if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n        zrStyle.textBaseline = 'alphabetic';\n    }\n    if (zrStyle.textBaseline === 'alphabetic') {\n        zrStyle.textBaseline = 'bottom';\n    }\n    if (zrStyle.textAlign === 'start') {\n        zrStyle.textAlign = 'left';\n    }\n    if (zrStyle.textAlign === 'end') {\n        zrStyle.textAlign = 'right';\n    }\n    util_1.each(['lineDashOffset', 'lineCap', 'lineJoin',\n        'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n    });\n    if (zrStyle.lineDash) {\n        disp.style.lineDash = util_1.map(util_1.trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n            return parseFloat(str);\n        });\n    }\n    disp.__inheritedStyle = zrStyle;\n}\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\nfunction getPaint(str, defs) {\n    var urlMatch = defs && str && str.match(urlRegex);\n    if (urlMatch) {\n        var url = util_1.trim(urlMatch[1]);\n        var def = defs[url];\n        return def;\n    }\n    return str;\n}\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\nfunction parseTransformAttribute(xmlNode, node) {\n    var transform = xmlNode.getAttribute('transform');\n    if (transform) {\n        transform = transform.replace(/,/g, ' ');\n        var transformOps_1 = [];\n        var m = null;\n        transform.replace(transformRegex, function (str, type, value) {\n            transformOps_1.push(type, value);\n            return '';\n        });\n        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n            var value = transformOps_1[i];\n            var type = transformOps_1[i - 1];\n            var valueArr = void 0;\n            m = m || matrix.create();\n            switch (type) {\n                case 'translate':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n                    break;\n                case 'scale':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n                    break;\n                case 'rotate':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    matrix.rotate(m, m, parseFloat(valueArr[0]));\n                    break;\n                case 'skew':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    console.warn('Skew transform is not supported yet');\n                    break;\n                case 'matrix':\n                    valueArr = util_1.trim(value).split(DILIMITER_REG);\n                    m[0] = parseFloat(valueArr[0]);\n                    m[1] = parseFloat(valueArr[1]);\n                    m[2] = parseFloat(valueArr[2]);\n                    m[3] = parseFloat(valueArr[3]);\n                    m[4] = parseFloat(valueArr[4]);\n                    m[5] = parseFloat(valueArr[5]);\n                    break;\n            }\n        }\n        node.setLocalTransform(m);\n    }\n}\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\nfunction parseStyleAttribute(xmlNode) {\n    var style = xmlNode.getAttribute('style');\n    var result = {};\n    if (!style) {\n        return result;\n    }\n    var styleList = {};\n    styleRegex.lastIndex = 0;\n    var styleRegResult;\n    while ((styleRegResult = styleRegex.exec(style)) != null) {\n        styleList[styleRegResult[1]] = styleRegResult[2];\n    }\n    for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n            result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n        }\n    }\n    return result;\n}\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n    var scaleX = width / viewBoxRect.width;\n    var scaleY = height / viewBoxRect.height;\n    var scale = Math.min(scaleX, scaleY);\n    return {\n        scale: scale,\n        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n    };\n}\nexports.makeViewBoxTransform = makeViewBoxTransform;\nfunction parseSVG(xml, opt) {\n    var parser = new SVGParser();\n    return parser.parse(xml, opt);\n}\nexports.parseSVG = parseSVG;\n"]},"metadata":{},"sourceType":"script"}