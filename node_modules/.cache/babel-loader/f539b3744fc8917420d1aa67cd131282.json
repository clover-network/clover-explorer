{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar parseSVG_1 = require(\"zrender/lib/tool/parseSVG\");\n\nvar storage = util_1.createHashMap();\nexports[\"default\"] = {\n  registerMap: function (mapName, rawDef, rawSpecialAreas) {\n    var records;\n\n    if (util_1.isArray(rawDef)) {\n      records = rawDef;\n    } else if (rawDef.svg) {\n      records = [{\n        type: 'svg',\n        source: rawDef.svg,\n        specialAreas: rawDef.specialAreas\n      }];\n    } else {\n      var geoSource = rawDef.geoJson || rawDef.geoJSON;\n\n      if (geoSource && !rawDef.features) {\n        rawSpecialAreas = rawDef.specialAreas;\n        rawDef = geoSource;\n      }\n\n      records = [{\n        type: 'geoJSON',\n        source: rawDef,\n        specialAreas: rawSpecialAreas\n      }];\n    }\n\n    util_1.each(records, function (record) {\n      var type = record.type;\n      type === 'geoJson' && (type = record.type = 'geoJSON');\n      var parse = parsers[type];\n\n      if (process.env.NODE_ENV !== 'production') {\n        util_1.assert(parse, 'Illegal map type: ' + type);\n      }\n\n      parse(record);\n    });\n    return storage.set(mapName, records);\n  },\n  retrieveMap: function (mapName) {\n    return storage.get(mapName);\n  }\n};\nvar parsers = {\n  geoJSON: function (record) {\n    var source = record.source;\n    record.geoJSON = !util_1.isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();\n  },\n  svg: function (record) {\n    record.svgXML = parseSVG_1.parseXML(record.source);\n  }\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/coord/geo/mapDataStorage.js"],"names":["exports","__esModule","util_1","require","parseSVG_1","storage","createHashMap","registerMap","mapName","rawDef","rawSpecialAreas","records","isArray","svg","type","source","specialAreas","geoSource","geoJson","geoJSON","features","each","record","parse","parsers","process","env","NODE_ENV","assert","set","retrieveMap","get","isString","JSON","Function","svgXML","parseXML"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar parseSVG_1 = require(\"zrender/lib/tool/parseSVG\");\n\nvar storage = util_1.createHashMap();\nexports[\"default\"] = {\n  registerMap: function (mapName, rawDef, rawSpecialAreas) {\n    var records;\n\n    if (util_1.isArray(rawDef)) {\n      records = rawDef;\n    } else if (rawDef.svg) {\n      records = [{\n        type: 'svg',\n        source: rawDef.svg,\n        specialAreas: rawDef.specialAreas\n      }];\n    } else {\n      var geoSource = rawDef.geoJson || rawDef.geoJSON;\n\n      if (geoSource && !rawDef.features) {\n        rawSpecialAreas = rawDef.specialAreas;\n        rawDef = geoSource;\n      }\n\n      records = [{\n        type: 'geoJSON',\n        source: rawDef,\n        specialAreas: rawSpecialAreas\n      }];\n    }\n\n    util_1.each(records, function (record) {\n      var type = record.type;\n      type === 'geoJson' && (type = record.type = 'geoJSON');\n      var parse = parsers[type];\n\n      if (process.env.NODE_ENV !== 'production') {\n        util_1.assert(parse, 'Illegal map type: ' + type);\n      }\n\n      parse(record);\n    });\n    return storage.set(mapName, records);\n  },\n  retrieveMap: function (mapName) {\n    return storage.get(mapName);\n  }\n};\nvar parsers = {\n  geoJSON: function (record) {\n    var source = record.source;\n    record.geoJSON = !util_1.isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();\n  },\n  svg: function (record) {\n    record.svgXML = parseSVG_1.parseXML(record.source);\n  }\n};"]},"metadata":{},"sourceType":"script"}