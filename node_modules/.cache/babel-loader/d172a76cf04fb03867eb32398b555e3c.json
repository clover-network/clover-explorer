{"ast":null,"code":"import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { getField, getAllNodes } from './util';\nvar DEFAULT_OPTIONS = {\n  field: 'value',\n  tile: 'treemapSquarify',\n  size: [1, 1],\n  round: false,\n  padding: 0,\n  paddingInner: 0,\n  paddingOuter: 0,\n  paddingTop: 0,\n  paddingRight: 0,\n  paddingBottom: 0,\n  paddingLeft: 0,\n  as: ['x', 'y']\n};\nexport function treemap(data, options) {\n  options = assign({}, DEFAULT_OPTIONS, options);\n  var as = options.as;\n\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  var field;\n\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  var partition = function (data) {\n    return d3Hierarchy.treemap().tile(d3Hierarchy[options.tile]).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(d3Hierarchy.hierarchy(data).sum(function (d) {\n      return d[field];\n    }));\n  };\n\n  var root = partition(data);\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n\n  var x = as[0];\n  var y = as[1];\n  root.each(function (node) {\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    ['x0', 'x1', 'y0', 'y1'].forEach(function (prop) {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n  return getAllNodes(root);\n}","map":{"version":3,"sources":["../../../../src/plots/sunburst/hierarchy/treemap.ts"],"names":[],"mappings":"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","sourcesContent":["import * as d3Hierarchy from 'd3-hierarchy';\nimport { assign, isArray } from '@antv/util';\nimport { HierarchyOption } from '../types';\nimport { getField, getAllNodes } from './util';\n\nconst DEFAULT_OPTIONS: HierarchyOption = {\n  field: 'value',\n  tile: 'treemapSquarify', // treemapBinary, treemapDice, treemapSlice, treemapSliceDice, treemapSquarify, treemapResquarify\n  size: [1, 1], // width, height\n  round: false,\n  padding: 0,\n  paddingInner: 0,\n  paddingOuter: 0,\n  paddingTop: 0,\n  paddingRight: 0,\n  paddingBottom: 0,\n  paddingLeft: 0,\n  as: ['x', 'y'],\n};\n\nexport function treemap(data: any, options: HierarchyOption): any[] {\n  options = assign({} as HierarchyOption, DEFAULT_OPTIONS, options);\n  const as = options.as;\n  if (!isArray(as) || as.length !== 2) {\n    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ \"x\", \"y\" ])!');\n  }\n\n  let field;\n  try {\n    field = getField(options);\n  } catch (e) {\n    console.warn(e);\n  }\n\n  const partition = (data) =>\n    d3Hierarchy\n      .treemap()\n      .tile(d3Hierarchy[options.tile])\n      .size(options.size)\n      .round(options.round)\n      .padding(options.padding)\n      .paddingInner(options.paddingInner)\n      .paddingOuter(options.paddingOuter)\n      .paddingTop(options.paddingTop)\n      .paddingRight(options.paddingRight)\n      .paddingBottom(options.paddingBottom)\n      .paddingLeft(options.paddingLeft)(d3Hierarchy.hierarchy(data).sum((d) => d[field]));\n  const root = partition(data);\n\n  /*\n   * points:\n   *   3  2\n   *   0  1\n   */\n  const x = as[0];\n  const y = as[1];\n  root.each((node) => {\n    node[x] = [node.x0, node.x1, node.x1, node.x0];\n    node[y] = [node.y1, node.y1, node.y0, node.y0];\n    ['x0', 'x1', 'y0', 'y1'].forEach((prop) => {\n      if (as.indexOf(prop) === -1) {\n        delete node[prop];\n      }\n    });\n  });\n\n  return getAllNodes(root);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}