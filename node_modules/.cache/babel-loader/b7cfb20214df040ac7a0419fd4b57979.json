{"ast":null,"code":"import { __spreadArrays } from \"tslib\";\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head } from '@antv/util';\nimport { isArray } from 'util';\n/**\n * 点数组转 path\n * @param points\n */\n\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n        y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\n\n\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\n\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n\n  var _a = head(points),\n      x = _a[0],\n      y = _a[1];\n\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\n\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height) {\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: 5\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\n\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\n\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArrays(path);\n\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }]; // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/plugins/timeBar/path.js"],"names":["__spreadArrays","pathUtil","Category","Linear","map","each","isEqual","head","isArray","pointsToPath","points","p","idx","command","x","y","getLinePath","getSmoothLinePath","length","data","slice","push","path","catmullRom2Bezier","_a","unshift","dataToPath","width","height","smooth","values","v","scale","dataToRectPath","rectPoints","i","point","param","y0","size","rectPoint","getRectPoints","apply","getRectPath","getAreaLineY","lineY","Math","max","min","linePathToAreaPath","areaPath","lineYPx","pointInfo","yMin","yMax","xMin","xMax","isClosed","firstPoint","len"],"mappings":"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","sourcesContent":["import { __spreadArrays } from \"tslib\";\nimport * as pathUtil from '@antv/path-util';\nimport { Category, Linear } from '@antv/scale';\nimport { map, each, isEqual, head } from '@antv/util';\nimport { isArray } from 'util';\n/**\n * 点数组转 path\n * @param points\n */\n\nfunction pointsToPath(points) {\n  return map(points, function (p, idx) {\n    var command = idx === 0 ? 'M' : 'L';\n    var x = p[0],\n        y = p[1];\n    return [command, x, y];\n  });\n}\n/**\n * 将点连接成路径 path\n * @param points\n */\n\n\nexport function getLinePath(points) {\n  return pointsToPath(points);\n}\n/**\n * 将点连成平滑的曲线\n * @param points\n */\n\nexport function getSmoothLinePath(points) {\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return getLinePath(points);\n  }\n\n  var data = [];\n  each(points, function (p) {\n    // 当前点和上一个点一样的时候，忽略掉\n    if (!isEqual(p, data.slice(data.length - 2))) {\n      data.push(p[0], p[1]);\n    }\n  });\n  var path = pathUtil.catmullRom2Bezier(data, false);\n\n  var _a = head(points),\n      x = _a[0],\n      y = _a[1];\n\n  path.unshift(['M', x, y]);\n  return path;\n}\n/**\n * 将数据转成 path，利用 scale 的归一化能力\n * @param data\n * @param width\n * @param height\n * @param smooth\n */\n\nexport function dataToPath(data, width, height, smooth) {\n  if (smooth === void 0) {\n    smooth = true;\n  } // 利用 scale 来获取 y 上的映射\n\n\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  return smooth ? getSmoothLinePath(points) : getLinePath(points);\n}\nexport function dataToRectPath(data, width, height) {\n  // 利用 scale 来获取 y 上的映射\n  var y = new Linear({\n    values: data\n  });\n  var x = new Category({\n    values: map(data, function (v, idx) {\n      return idx;\n    })\n  });\n  var points = map(data, function (v, idx) {\n    return [x.scale(idx) * width, height - y.scale(v) * height];\n  });\n  var rectPoints = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n    var param = {\n      x: point[0],\n      y: point[1],\n      y0: height,\n      size: 5\n    };\n    var rectPoint = getRectPoints(param);\n    rectPoints.push.apply(rectPoints, rectPoint);\n  }\n\n  return getRectPath(rectPoints);\n}\n/**\n * 获得 area 面积的横向连接线的 px 位置\n * @param data\n * @param width\n * @param height\n */\n\nexport function getAreaLineY(data, height) {\n  var y = new Linear({\n    values: data\n  });\n  var lineY = Math.max(0, y.min);\n  return height - y.scale(lineY) * height;\n}\n/**\n * 线 path 转 area path\n * @param path\n * @param width\n * @param height\n */\n\nexport function linePathToAreaPath(path, width, height, data) {\n  var areaPath = __spreadArrays(path);\n\n  var lineYPx = getAreaLineY(data, height);\n  areaPath.push(['L', width, lineYPx]);\n  areaPath.push(['L', 0, lineYPx]);\n  areaPath.push(['Z']);\n  return areaPath;\n}\n/**\n * @ignore\n * 根据数据点生成矩形的四个关键点\n * @param pointInfo 数据点信息\n * @returns rect points 返回矩形四个顶点信息\n */\n\nexport function getRectPoints(pointInfo) {\n  var x = pointInfo.x,\n      y = pointInfo.y,\n      y0 = pointInfo.y0,\n      size = pointInfo.size; // 有 4 种情况，\n  // 1. x, y 都不是数组\n  // 2. y是数组，x不是\n  // 3. x是数组，y不是\n  // 4. x, y 都是数组\n\n  var yMin;\n  var yMax;\n\n  if (isArray(y)) {\n    yMin = y[0], yMax = y[1];\n  } else {\n    yMin = y0;\n    yMax = y;\n  }\n\n  var xMin;\n  var xMax;\n\n  if (isArray(x)) {\n    xMin = x[0], xMax = x[1];\n  } else {\n    xMin = x - size / 2;\n    xMax = x + size / 2;\n  }\n\n  var points = [{\n    x: xMin,\n    y: yMin\n  }, {\n    x: xMin,\n    y: yMax\n  }]; // 矩形的四个关键点，结构如下（左下角顺时针连接）\n  // 1 ---- 2\n  // |      |\n  // 0 ---- 3\n\n  points.push({\n    x: xMax,\n    y: yMax\n  }, {\n    x: xMax,\n    y: yMin\n  });\n  return points;\n}\n/**\n * @ignore\n * 根据矩形关键点绘制 path\n * @param points 关键点数组\n * @param isClosed path 是否需要闭合\n * @returns 返回矩形的 path\n */\n\nexport function getRectPath(points, isClosed) {\n  if (isClosed === void 0) {\n    isClosed = true;\n  }\n\n  var path = [];\n  var firstPoint = points[0];\n  path.push(['M', firstPoint.x, firstPoint.y]);\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    path.push(['L', points[i].x, points[i].y]);\n  } // 对于 shape=\"line\" path 不应该闭合，否则会造成 lineCap 绘图属性失效\n\n\n  if (isClosed) {\n    path.push(['L', firstPoint.x, firstPoint.y]); // 需要闭合\n\n    path.push(['z']);\n  }\n\n  return path;\n}"]},"metadata":{},"sourceType":"module"}