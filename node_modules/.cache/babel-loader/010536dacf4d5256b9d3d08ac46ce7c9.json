{"ast":null,"code":"import { isNil, isFunction, assign } from '@antv/util';\nvar DEFAULT_OPTIONS = {\n  font: function () {\n    return 'serif';\n  },\n  padding: 1,\n  size: [500, 500],\n  spiral: 'archimedean',\n  // timeInterval: Infinity // max execute time\n  timeInterval: 3000\n};\n/**\n * 根据对应的数据对象，计算每个\n * 词语在画布中的渲染位置，并返回\n * 计算后的数据对象\n * @param words\n * @param options\n */\n\nexport function wordCloud(words, options) {\n  // 混入默认配置\n  options = assign({}, DEFAULT_OPTIONS, options);\n  return transform(words, options);\n}\n/**\n * 抛出没有混入默认配置的方法，用于测试。\n * @param words\n * @param options\n */\n\nexport function transform(words, options) {\n  // 布局对象\n  var layout = tagCloud();\n  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(function (key) {\n    if (!isNil(options[key])) {\n      layout[key](options[key]);\n    }\n  });\n  layout.words(words);\n\n  if (options.imageMask) {\n    layout.createMask(options.imageMask);\n  }\n\n  var result = layout.start();\n  var tags = result._tags;\n  tags.forEach(function (tag) {\n    tag.x += options.size[0] / 2;\n    tag.y += options.size[1] / 2;\n  });\n  var _a = options.size,\n      w = _a[0],\n      h = _a[1]; // 添加两个参照数据，分别表示左上角和右下角。\n  // 不添加的话不会按照真实的坐标渲染，而是以\n  // 数据中的边界坐标为边界进行拉伸，以铺满画布。\n  // 这样的后果会导致词语之间的重叠。\n\n  tags.push({\n    text: '',\n    value: 0,\n    x: 0,\n    y: 0,\n    opacity: 0\n  });\n  tags.push({\n    text: '',\n    value: 0,\n    x: w,\n    y: h,\n    opacity: 0\n  });\n  return tags;\n}\nvar cloudRadians = Math.PI / 180,\n    cw = 1 << 11 >> 5,\n    ch = 1 << 11;\n\nfunction cloudText(d) {\n  return d.text;\n}\n\nfunction cloudFont() {\n  return 'serif';\n}\n\nfunction cloudFontNormal() {\n  return 'normal';\n}\n\nfunction cloudFontSize(d) {\n  return d.value;\n}\n\nfunction cloudRotate() {\n  return ~~(Math.random() * 2) * 90;\n}\n\nfunction cloudPadding() {\n  return 1;\n} // Fetches a monochrome sprite bitmap for the specified text.\n// Load in batches for speed.\n\n\nfunction cloudSprite(contextAndRatio, d, data, di) {\n  if (d.sprite) return;\n  var c = contextAndRatio.context,\n      ratio = contextAndRatio.ratio;\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\n  var x = 0,\n      y = 0,\n      maxh = 0;\n  var n = data.length;\n  --di;\n\n  while (++di < n) {\n    d = data[di];\n    c.save();\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\n    var w = c.measureText(d.text + 'm').width * ratio,\n        h = d.size << 1;\n\n    if (d.rotate) {\n      var sr = Math.sin(d.rotate * cloudRadians),\n          cr = Math.cos(d.rotate * cloudRadians),\n          wcr = w * cr,\n          wsr = w * sr,\n          hcr = h * cr,\n          hsr = h * sr;\n      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\n    } else {\n      w = w + 0x1f >> 5 << 5;\n    }\n\n    if (h > maxh) maxh = h;\n\n    if (x + w >= cw << 5) {\n      x = 0;\n      y += maxh;\n      maxh = 0;\n    }\n\n    if (y + h >= ch) break;\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\n    c.fillText(d.text, 0, 0);\n\n    if (d.padding) {\n      c.lineWidth = 2 * d.padding;\n      c.strokeText(d.text, 0, 0);\n    }\n\n    c.restore();\n    d.width = w;\n    d.height = h;\n    d.xoff = x;\n    d.yoff = y;\n    d.x1 = w >> 1;\n    d.y1 = h >> 1;\n    d.x0 = -d.x1;\n    d.y0 = -d.y1;\n    d.hasText = true;\n    x += w;\n  }\n\n  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\n      sprite = [];\n\n  while (--di >= 0) {\n    d = data[di];\n    if (!d.hasText) continue;\n    var w = d.width,\n        w32 = w >> 5;\n    var h = d.y1 - d.y0; // Zero the buffer\n\n    for (var i = 0; i < h * w32; i++) sprite[i] = 0;\n\n    x = d.xoff;\n    if (x == null) return;\n    y = d.yoff;\n    var seen = 0,\n        seenRow = -1;\n\n    for (var j = 0; j < h; j++) {\n      for (var i = 0; i < w; i++) {\n        var k = w32 * j + (i >> 5),\n            m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;\n        sprite[k] |= m;\n        seen |= m;\n      }\n\n      if (seen) seenRow = j;else {\n        d.y0++;\n        h--;\n        j--;\n        y++;\n      }\n    }\n\n    d.y1 = d.y0 + seenRow;\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\n  }\n} // Use mask-based collision detection.\n\n\nfunction cloudCollide(tag, board, sw) {\n  sw >>= 5;\n  var sprite = tag.sprite,\n      w = tag.width >> 5,\n      lx = tag.x - (w << 4),\n      sx = lx & 0x7f,\n      msx = 32 - sx,\n      h = tag.y1 - tag.y0;\n  var x = (tag.y + tag.y0) * sw + (lx >> 5),\n      last;\n\n  for (var j = 0; j < h; j++) {\n    last = 0;\n\n    for (var i = 0; i <= w; i++) {\n      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\n    }\n\n    x += sw;\n  }\n\n  return false;\n}\n\nfunction cloudBounds(bounds, d) {\n  var b0 = bounds[0],\n      b1 = bounds[1];\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\n}\n\nfunction collideRects(a, b) {\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\n}\n\nfunction archimedeanSpiral(size) {\n  var e = size[0] / size[1];\n  return function (t) {\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\n  };\n}\n\nfunction rectangularSpiral(size) {\n  var dy = 4,\n      dx = dy * size[0] / size[1];\n  var x = 0,\n      y = 0;\n  return function (t) {\n    var sign = t < 0 ? -1 : 1; // See triangular numbers: T_n = n * (n + 1) / 2.\n\n    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {\n      case 0:\n        x += dx;\n        break;\n\n      case 1:\n        y += dy;\n        break;\n\n      case 2:\n        x -= dx;\n        break;\n\n      default:\n        y -= dy;\n        break;\n    }\n\n    return [x, y];\n  };\n} // TODO reuse arrays?\n\n\nfunction zeroArray(n) {\n  var a = [];\n  var i = -1;\n\n  while (++i < n) a[i] = 0;\n\n  return a;\n}\n\nfunction cloudCanvas() {\n  return document.createElement('canvas');\n}\n\nexport function functor(d) {\n  return isFunction(d) ? d : function () {\n    return d;\n  };\n}\nvar spirals = {\n  archimedean: archimedeanSpiral,\n  rectangular: rectangularSpiral\n};\n\nfunction tagCloud() {\n  var size = [256, 256],\n      font = cloudFont,\n      fontSize = cloudFontSize,\n      fontWeight = cloudFontNormal,\n      rotate = cloudRotate,\n      padding = cloudPadding,\n      spiral = archimedeanSpiral,\n      random = Math.random,\n      words = [],\n      timeInterval = Infinity;\n  var text = cloudText;\n  var fontStyle = cloudFontNormal;\n  var canvas = cloudCanvas;\n  var cloud = {};\n\n  cloud.start = function () {\n    var width = size[0],\n        height = size[1];\n    var contextAndRatio = getContext(canvas()),\n        board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\n        n = words.length,\n        tags = [],\n        data = words.map(function (d, i, data) {\n      d.text = text.call(this, d, i, data);\n      d.font = font.call(this, d, i, data);\n      d.style = fontStyle.call(this, d, i, data);\n      d.weight = fontWeight.call(this, d, i, data);\n      d.rotate = rotate.call(this, d, i, data);\n      d.size = ~~fontSize.call(this, d, i, data);\n      d.padding = padding.call(this, d, i, data);\n      return d;\n    }).sort(function (a, b) {\n      return b.size - a.size;\n    });\n    var i = -1,\n        bounds = !cloud.board ? null : [{\n      x: 0,\n      y: 0\n    }, {\n      x: width,\n      y: height\n    }];\n    step();\n\n    function step() {\n      var start = Date.now();\n\n      while (Date.now() - start < timeInterval && ++i < n) {\n        var d = data[i];\n        d.x = width * (random() + 0.5) >> 1;\n        d.y = height * (random() + 0.5) >> 1;\n        cloudSprite(contextAndRatio, d, data, i);\n\n        if (d.hasText && place(board, d, bounds)) {\n          tags.push(d);\n\n          if (bounds) {\n            if (!cloud.hasImage) {\n              // update bounds if image mask not set\n              cloudBounds(bounds, d);\n            }\n          } else {\n            bounds = [{\n              x: d.x + d.x0,\n              y: d.y + d.y0\n            }, {\n              x: d.x + d.x1,\n              y: d.y + d.y1\n            }];\n          } // Temporary hack\n\n\n          d.x -= size[0] >> 1;\n          d.y -= size[1] >> 1;\n        }\n      }\n\n      cloud._tags = tags;\n      cloud._bounds = bounds;\n    }\n\n    return cloud;\n  };\n\n  function getContext(canvas) {\n    canvas.width = canvas.height = 1;\n    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);\n    canvas.width = (cw << 5) / ratio;\n    canvas.height = ch / ratio;\n    var context = canvas.getContext('2d');\n    context.fillStyle = context.strokeStyle = 'red';\n    context.textAlign = 'center';\n    return {\n      context: context,\n      ratio: ratio\n    };\n  }\n\n  function place(board, tag, bounds) {\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\n    var startX = tag.x,\n        startY = tag.y,\n        maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\n        s = spiral(size),\n        dt = random() < 0.5 ? 1 : -1;\n    var dxdy,\n        t = -dt,\n        dx,\n        dy;\n\n    while (dxdy = s(t += dt)) {\n      dx = ~~dxdy[0];\n      dy = ~~dxdy[1];\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\n      tag.x = startX + dx;\n      tag.y = startY + dy;\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue; // TODO only check for collisions within current bounds.\n\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\n        if (!bounds || collideRects(tag, bounds)) {\n          var sprite = tag.sprite,\n              w = tag.width >> 5,\n              sw = size[0] >> 5,\n              lx = tag.x - (w << 4),\n              sx = lx & 0x7f,\n              msx = 32 - sx,\n              h = tag.y1 - tag.y0;\n          var last = void 0,\n              x = (tag.y + tag.y0) * sw + (lx >> 5);\n\n          for (var j = 0; j < h; j++) {\n            last = 0;\n\n            for (var i = 0; i <= w; i++) {\n              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\n            }\n\n            x += sw;\n          }\n\n          delete tag.sprite;\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  cloud.createMask = function (img) {\n    var can = document.createElement('canvas');\n    var width = size[0],\n        height = size[1]; // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\n\n    if (!width || !height) {\n      return;\n    }\n\n    var w32 = width >> 5;\n    var board = zeroArray((width >> 5) * height);\n    can.width = width;\n    can.height = height;\n    var cxt = can.getContext('2d');\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\n    var imageData = cxt.getImageData(0, 0, width, height).data;\n\n    for (var j = 0; j < height; j++) {\n      for (var i = 0; i < width; i++) {\n        var k = w32 * j + (i >> 5);\n        var tmp = j * width + i << 2;\n        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\n        var m = flag ? 1 << 31 - i % 32 : 0;\n        board[k] |= m;\n      }\n    }\n\n    cloud.board = board;\n    cloud.hasImage = true;\n  };\n\n  cloud.timeInterval = function (_) {\n    timeInterval = _ == null ? Infinity : _;\n  };\n\n  cloud.words = function (_) {\n    words = _;\n  };\n\n  cloud.size = function (_) {\n    size = [+_[0], +_[1]];\n  };\n\n  cloud.font = function (_) {\n    font = functor(_);\n  };\n\n  cloud.fontWeight = function (_) {\n    fontWeight = functor(_);\n  };\n\n  cloud.rotate = function (_) {\n    rotate = functor(_);\n  };\n\n  cloud.spiral = function (_) {\n    spiral = spirals[_] || _;\n  };\n\n  cloud.fontSize = function (_) {\n    fontSize = functor(_);\n  };\n\n  cloud.padding = function (_) {\n    padding = functor(_);\n  };\n\n  cloud.random = function (_) {\n    random = functor(_);\n  };\n\n  return cloud;\n}","map":{"version":3,"sources":["../../../src/utils/transform/word-cloud.ts"],"names":[],"mappings":"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","sourcesContent":["import { isNil, isFunction, assign } from '@antv/util';\r\nimport { Tag, Word } from '../../plots/word-cloud/types';\r\n\r\ntype FontWeight = number | 'normal' | 'bold' | 'bolder' | 'lighter';\r\n\r\nexport interface Options {\r\n  size: [number, number];\r\n  font?: string | ((row: Word, index?: number, words?: Word[]) => string);\r\n  fontSize?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  fontWeight?: FontWeight | ((row: Word, index?: number, words?: Word[]) => FontWeight);\r\n  rotate?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  padding?: number | ((row: Word, index?: number, words?: Word[]) => number);\r\n  spiral?: 'archimedean' | 'rectangular' | ((size: [number, number]) => (t: number) => number[]);\r\n  random?: number | (() => number);\r\n  timeInterval?: number;\r\n  imageMask?: HTMLImageElement;\r\n}\r\n\r\nconst DEFAULT_OPTIONS: Options = {\r\n  font: () => 'serif',\r\n  padding: 1,\r\n  size: [500, 500],\r\n  spiral: 'archimedean', // 'archimedean' || 'rectangular' || {function}\r\n  // timeInterval: Infinity // max execute time\r\n  timeInterval: 3000, // max execute time\r\n  // imageMask: '', // instance of Image, must be loaded\r\n};\r\n\r\n/**\r\n * 根据对应的数据对象，计算每个\r\n * 词语在画布中的渲染位置，并返回\r\n * 计算后的数据对象\r\n * @param words\r\n * @param options\r\n */\r\nexport function wordCloud(words: Word[], options?: Partial<Options>): Tag[] {\r\n  // 混入默认配置\r\n  options = assign({} as Options, DEFAULT_OPTIONS, options);\r\n  return transform(words, options as Options);\r\n}\r\n\r\n/**\r\n * 抛出没有混入默认配置的方法，用于测试。\r\n * @param words\r\n * @param options\r\n */\r\nexport function transform(words: Word[], options: Options) {\r\n  // 布局对象\r\n  const layout = tagCloud();\r\n  ['font', 'fontSize', 'fontWeight', 'padding', 'rotate', 'size', 'spiral', 'timeInterval', 'random'].forEach(\r\n    (key: string) => {\r\n      if (!isNil(options[key])) {\r\n        layout[key](options[key]);\r\n      }\r\n    }\r\n  );\r\n\r\n  layout.words(words);\r\n  if (options.imageMask) {\r\n    layout.createMask(options.imageMask);\r\n  }\r\n\r\n  const result = layout.start();\r\n  const tags: any[] = result._tags;\r\n\r\n  tags.forEach((tag) => {\r\n    tag.x += options.size[0] / 2;\r\n    tag.y += options.size[1] / 2;\r\n  });\r\n\r\n  const [w, h] = options.size;\r\n  // 添加两个参照数据，分别表示左上角和右下角。\r\n  // 不添加的话不会按照真实的坐标渲染，而是以\r\n  // 数据中的边界坐标为边界进行拉伸，以铺满画布。\r\n  // 这样的后果会导致词语之间的重叠。\r\n  tags.push({\r\n    text: '',\r\n    value: 0,\r\n    x: 0,\r\n    y: 0,\r\n    opacity: 0,\r\n  });\r\n  tags.push({\r\n    text: '',\r\n    value: 0,\r\n    x: w,\r\n    y: h,\r\n    opacity: 0,\r\n  });\r\n\r\n  return tags;\r\n}\r\n\r\n/*\r\n * Synchronous version of d3-cloud\r\n */\r\n// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/\r\n// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf\r\n/* eslint-disable no-return-assign, no-cond-assign */\r\n\r\ninterface Item {\r\n  value: number;\r\n  text: string;\r\n  sprite: boolean;\r\n}\r\n\r\nconst cloudRadians = Math.PI / 180,\r\n  cw = (1 << 11) >> 5,\r\n  ch = 1 << 11;\r\n\r\nfunction cloudText(d: Item) {\r\n  return d.text;\r\n}\r\n\r\nfunction cloudFont() {\r\n  return 'serif';\r\n}\r\n\r\nfunction cloudFontNormal() {\r\n  return 'normal';\r\n}\r\n\r\nfunction cloudFontSize(d: Item) {\r\n  return d.value;\r\n}\r\n\r\nfunction cloudRotate() {\r\n  return ~~(Math.random() * 2) * 90;\r\n}\r\n\r\nfunction cloudPadding() {\r\n  return 1;\r\n}\r\n\r\n// Fetches a monochrome sprite bitmap for the specified text.\r\n// Load in batches for speed.\r\nfunction cloudSprite(contextAndRatio, d, data, di) {\r\n  if (d.sprite) return;\r\n  const c = contextAndRatio.context,\r\n    ratio = contextAndRatio.ratio;\r\n\r\n  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);\r\n  let x = 0,\r\n    y = 0,\r\n    maxh = 0;\r\n  const n = data.length;\r\n  --di;\r\n  while (++di < n) {\r\n    d = data[di];\r\n    c.save();\r\n    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;\r\n    let w = c.measureText(d.text + 'm').width * ratio,\r\n      h = d.size << 1;\r\n    if (d.rotate) {\r\n      const sr = Math.sin(d.rotate * cloudRadians),\r\n        cr = Math.cos(d.rotate * cloudRadians),\r\n        wcr = w * cr,\r\n        wsr = w * sr,\r\n        hcr = h * cr,\r\n        hsr = h * sr;\r\n      w = ((Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f) >> 5) << 5;\r\n      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));\r\n    } else {\r\n      w = ((w + 0x1f) >> 5) << 5;\r\n    }\r\n    if (h > maxh) maxh = h;\r\n    if (x + w >= cw << 5) {\r\n      x = 0;\r\n      y += maxh;\r\n      maxh = 0;\r\n    }\r\n    if (y + h >= ch) break;\r\n    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);\r\n    if (d.rotate) c.rotate(d.rotate * cloudRadians);\r\n    c.fillText(d.text, 0, 0);\r\n    if (d.padding) {\r\n      c.lineWidth = 2 * d.padding;\r\n      c.strokeText(d.text, 0, 0);\r\n    }\r\n    c.restore();\r\n    d.width = w;\r\n    d.height = h;\r\n    d.xoff = x;\r\n    d.yoff = y;\r\n    d.x1 = w >> 1;\r\n    d.y1 = h >> 1;\r\n    d.x0 = -d.x1;\r\n    d.y0 = -d.y1;\r\n    d.hasText = true;\r\n    x += w;\r\n  }\r\n  const pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,\r\n    sprite = [];\r\n  while (--di >= 0) {\r\n    d = data[di];\r\n    if (!d.hasText) continue;\r\n    const w = d.width,\r\n      w32 = w >> 5;\r\n    let h = d.y1 - d.y0;\r\n    // Zero the buffer\r\n    for (let i = 0; i < h * w32; i++) sprite[i] = 0;\r\n    x = d.xoff;\r\n    if (x == null) return;\r\n    y = d.yoff;\r\n    let seen = 0,\r\n      seenRow = -1;\r\n    for (let j = 0; j < h; j++) {\r\n      for (let i = 0; i < w; i++) {\r\n        const k = w32 * j + (i >> 5),\r\n          m = pixels[((y + j) * (cw << 5) + (x + i)) << 2] ? 1 << (31 - (i % 32)) : 0;\r\n        sprite[k] |= m;\r\n        seen |= m;\r\n      }\r\n      if (seen) seenRow = j;\r\n      else {\r\n        d.y0++;\r\n        h--;\r\n        j--;\r\n        y++;\r\n      }\r\n    }\r\n    d.y1 = d.y0 + seenRow;\r\n    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);\r\n  }\r\n}\r\n\r\n// Use mask-based collision detection.\r\nfunction cloudCollide(tag, board, sw) {\r\n  sw >>= 5;\r\n  const sprite = tag.sprite,\r\n    w = tag.width >> 5,\r\n    lx = tag.x - (w << 4),\r\n    sx = lx & 0x7f,\r\n    msx = 32 - sx,\r\n    h = tag.y1 - tag.y0;\r\n  let x = (tag.y + tag.y0) * sw + (lx >> 5),\r\n    last;\r\n  for (let j = 0; j < h; j++) {\r\n    last = 0;\r\n    for (let i = 0; i <= w; i++) {\r\n      if (((last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;\r\n    }\r\n    x += sw;\r\n  }\r\n  return false;\r\n}\r\n\r\nfunction cloudBounds(bounds, d) {\r\n  const b0 = bounds[0],\r\n    b1 = bounds[1];\r\n  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;\r\n  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;\r\n  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;\r\n  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;\r\n}\r\n\r\nfunction collideRects(a, b) {\r\n  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;\r\n}\r\n\r\nfunction archimedeanSpiral(size) {\r\n  const e = size[0] / size[1];\r\n  return function (t) {\r\n    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];\r\n  };\r\n}\r\n\r\nfunction rectangularSpiral(size) {\r\n  const dy = 4,\r\n    dx = (dy * size[0]) / size[1];\r\n  let x = 0,\r\n    y = 0;\r\n  return function (t) {\r\n    const sign = t < 0 ? -1 : 1;\r\n    // See triangular numbers: T_n = n * (n + 1) / 2.\r\n    switch ((Math.sqrt(1 + 4 * sign * t) - sign) & 3) {\r\n      case 0:\r\n        x += dx;\r\n        break;\r\n      case 1:\r\n        y += dy;\r\n        break;\r\n      case 2:\r\n        x -= dx;\r\n        break;\r\n      default:\r\n        y -= dy;\r\n        break;\r\n    }\r\n    return [x, y];\r\n  };\r\n}\r\n\r\n// TODO reuse arrays?\r\nfunction zeroArray(n) {\r\n  const a = [];\r\n  let i = -1;\r\n  while (++i < n) a[i] = 0;\r\n  return a;\r\n}\r\n\r\nfunction cloudCanvas() {\r\n  return document.createElement('canvas');\r\n}\r\n\r\nexport function functor(d) {\r\n  return isFunction(d)\r\n    ? d\r\n    : function () {\r\n        return d;\r\n      };\r\n}\r\n\r\nconst spirals = {\r\n  archimedean: archimedeanSpiral,\r\n  rectangular: rectangularSpiral,\r\n};\r\n\r\nfunction tagCloud() {\r\n  let size = [256, 256],\r\n    font = cloudFont,\r\n    fontSize = cloudFontSize,\r\n    fontWeight = cloudFontNormal,\r\n    rotate = cloudRotate,\r\n    padding = cloudPadding,\r\n    spiral = archimedeanSpiral,\r\n    random = Math.random,\r\n    words = [],\r\n    timeInterval = Infinity;\r\n\r\n  const text = cloudText;\r\n  const fontStyle = cloudFontNormal;\r\n  const canvas = cloudCanvas;\r\n  const cloud: any = {};\r\n\r\n  cloud.start = function () {\r\n    const [width, height] = size;\r\n    const contextAndRatio = getContext(canvas()),\r\n      board = cloud.board ? cloud.board : zeroArray((size[0] >> 5) * size[1]),\r\n      n = words.length,\r\n      tags = [],\r\n      data = words\r\n        .map(function (d, i, data) {\r\n          d.text = text.call(this, d, i, data);\r\n          d.font = font.call(this, d, i, data);\r\n          d.style = fontStyle.call(this, d, i, data);\r\n          d.weight = fontWeight.call(this, d, i, data);\r\n          d.rotate = rotate.call(this, d, i, data);\r\n          d.size = ~~fontSize.call(this, d, i, data);\r\n          d.padding = padding.call(this, d, i, data);\r\n          return d;\r\n        })\r\n        .sort(function (a, b) {\r\n          return b.size - a.size;\r\n        });\r\n    let i = -1,\r\n      bounds = !cloud.board\r\n        ? null\r\n        : [\r\n            {\r\n              x: 0,\r\n              y: 0,\r\n            },\r\n            {\r\n              x: width,\r\n              y: height,\r\n            },\r\n          ];\r\n\r\n    step();\r\n\r\n    function step() {\r\n      const start = Date.now();\r\n      while (Date.now() - start < timeInterval && ++i < n) {\r\n        const d = data[i];\r\n        d.x = (width * (random() + 0.5)) >> 1;\r\n        d.y = (height * (random() + 0.5)) >> 1;\r\n        cloudSprite(contextAndRatio, d, data, i);\r\n        if (d.hasText && place(board, d, bounds)) {\r\n          tags.push(d);\r\n          if (bounds) {\r\n            if (!cloud.hasImage) {\r\n              // update bounds if image mask not set\r\n              cloudBounds(bounds, d);\r\n            }\r\n          } else {\r\n            bounds = [\r\n              { x: d.x + d.x0, y: d.y + d.y0 },\r\n              { x: d.x + d.x1, y: d.y + d.y1 },\r\n            ];\r\n          }\r\n          // Temporary hack\r\n          d.x -= size[0] >> 1;\r\n          d.y -= size[1] >> 1;\r\n        }\r\n      }\r\n      cloud._tags = tags;\r\n      cloud._bounds = bounds;\r\n    }\r\n\r\n    return cloud;\r\n  };\r\n\r\n  function getContext(canvas: HTMLCanvasElement) {\r\n    canvas.width = canvas.height = 1;\r\n    const ratio = Math.sqrt(canvas.getContext('2d')!.getImageData(0, 0, 1, 1).data.length >> 2);\r\n    canvas.width = (cw << 5) / ratio;\r\n    canvas.height = ch / ratio;\r\n\r\n    const context = canvas.getContext('2d') as CanvasRenderingContext2D;\r\n    context.fillStyle = context.strokeStyle = 'red';\r\n    context.textAlign = 'center';\r\n    return { context, ratio };\r\n  }\r\n\r\n  function place(board, tag, bounds) {\r\n    // const perimeter = [{ x: 0, y: 0 }, { x: size[0], y: size[1] }],\r\n    const startX = tag.x,\r\n      startY = tag.y,\r\n      maxDelta = Math.sqrt(size[0] * size[0] + size[1] * size[1]),\r\n      s = spiral(size),\r\n      dt = random() < 0.5 ? 1 : -1;\r\n    let dxdy,\r\n      t = -dt,\r\n      dx,\r\n      dy;\r\n\r\n    while ((dxdy = s((t += dt)))) {\r\n      dx = ~~dxdy[0];\r\n      dy = ~~dxdy[1];\r\n\r\n      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;\r\n\r\n      tag.x = startX + dx;\r\n      tag.y = startY + dy;\r\n\r\n      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;\r\n      // TODO only check for collisions within current bounds.\r\n      if (!bounds || !cloudCollide(tag, board, size[0])) {\r\n        if (!bounds || collideRects(tag, bounds)) {\r\n          const sprite = tag.sprite,\r\n            w = tag.width >> 5,\r\n            sw = size[0] >> 5,\r\n            lx = tag.x - (w << 4),\r\n            sx = lx & 0x7f,\r\n            msx = 32 - sx,\r\n            h = tag.y1 - tag.y0;\r\n          let last,\r\n            x = (tag.y + tag.y0) * sw + (lx >> 5);\r\n          for (let j = 0; j < h; j++) {\r\n            last = 0;\r\n            for (let i = 0; i <= w; i++) {\r\n              board[x + i] |= (last << msx) | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);\r\n            }\r\n            x += sw;\r\n          }\r\n          delete tag.sprite;\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  cloud.createMask = (img: HTMLImageElement) => {\r\n    const can: HTMLCanvasElement = document.createElement('canvas');\r\n    const [width, height] = size;\r\n\r\n    // 当 width 或 height 为 0 时，调用 cxt.getImageData 会报错\r\n    if (!width || !height) {\r\n      return;\r\n    }\r\n    const w32 = width >> 5;\r\n    const board = zeroArray((width >> 5) * height);\r\n    can.width = width;\r\n    can.height = height;\r\n    const cxt = can.getContext('2d') as CanvasRenderingContext2D;\r\n    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);\r\n    const imageData = cxt.getImageData(0, 0, width, height).data;\r\n    for (let j = 0; j < height; j++) {\r\n      for (let i = 0; i < width; i++) {\r\n        const k = w32 * j + (i >> 5);\r\n        const tmp = (j * width + i) << 2;\r\n        const flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;\r\n        const m = flag ? 1 << (31 - (i % 32)) : 0;\r\n        board[k] |= m;\r\n      }\r\n    }\r\n    cloud.board = board;\r\n    cloud.hasImage = true;\r\n  };\r\n\r\n  cloud.timeInterval = function (_) {\r\n    timeInterval = _ == null ? Infinity : _;\r\n  };\r\n\r\n  cloud.words = function (_) {\r\n    words = _;\r\n  };\r\n\r\n  cloud.size = function (_) {\r\n    size = [+_[0], +_[1]];\r\n  };\r\n\r\n  cloud.font = function (_) {\r\n    font = functor(_);\r\n  };\r\n\r\n  cloud.fontWeight = function (_) {\r\n    fontWeight = functor(_);\r\n  };\r\n\r\n  cloud.rotate = function (_) {\r\n    rotate = functor(_);\r\n  };\r\n\r\n  cloud.spiral = function (_) {\r\n    spiral = spirals[_] || _;\r\n  };\r\n\r\n  cloud.fontSize = function (_) {\r\n    fontSize = functor(_);\r\n  };\r\n\r\n  cloud.padding = function (_) {\r\n    padding = functor(_);\r\n  };\r\n\r\n  cloud.random = function (_) {\r\n    random = functor(_);\r\n  };\r\n\r\n  return cloud;\r\n}\r\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}