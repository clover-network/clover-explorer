{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\nimport * as echarts from '../../echarts';\nimport { createHashMap, each, hasOwn, keys, map } from 'zrender/esm/core/util';\nimport { isCartesian2DSeries, findAxisModels } from './cartesianAxisHelper';\nimport { getDataDimensionsOnAxis, unionAxisExtentFromData } from '../axisHelper';\nimport { ensureScaleRawExtentInfo } from '../scaleRawExtentInfo';\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.FILTER + 10, {\n  getTargetSeries: function (ecModel) {\n    var seriesModelMap = createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      isCartesian2DSeries(seriesModel) && seriesModelMap.set(seriesModel.uid, seriesModel);\n    });\n    return seriesModelMap;\n  },\n  overallReset: function (ecModel, api) {\n    var seriesRecords = [];\n    var axisRecordMap = createHashMap();\n    prepareDataExtentOnAxis(ecModel, axisRecordMap, seriesRecords);\n    calculateFilteredExtent(axisRecordMap, seriesRecords);\n    shrinkAxisExtent(axisRecordMap);\n  }\n});\n\nfunction prepareDataExtentOnAxis(ecModel, axisRecordMap, seriesRecords) {\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2DSeries(seriesModel)) {\n      return;\n    }\n\n    var axesModelMap = findAxisModels(seriesModel);\n    var xAxisModel = axesModelMap.xAxisModel;\n    var yAxisModel = axesModelMap.yAxisModel;\n    var xAxis = xAxisModel.axis;\n    var yAxis = yAxisModel.axis;\n    var xRawExtentInfo = xAxis.scale.rawExtentInfo;\n    var yRawExtentInfo = yAxis.scale.rawExtentInfo;\n    var data = seriesModel.getData();\n\n    if (xRawExtentInfo && xRawExtentInfo.frozen || yRawExtentInfo && yRawExtentInfo.frozen) {\n      return;\n    }\n\n    seriesRecords.push({\n      seriesModel: seriesModel,\n      xAxisModel: xAxisModel,\n      yAxisModel: yAxisModel\n    });\n    unionAxisExtentFromData(prepareAxisRecord(axisRecordMap, xAxisModel).condExtent, data, xAxis.dim);\n    unionAxisExtentFromData(prepareAxisRecord(axisRecordMap, yAxisModel).condExtent, data, yAxis.dim);\n  });\n}\n\nfunction calculateFilteredExtent(axisRecordMap, seriesRecords) {\n  each(seriesRecords, function (seriesRecord) {\n    var xAxisModel = seriesRecord.xAxisModel;\n    var yAxisModel = seriesRecord.yAxisModel;\n    var xAxis = xAxisModel.axis;\n    var yAxis = yAxisModel.axis;\n    var xAxisRecord = prepareAxisRecord(axisRecordMap, xAxisModel);\n    var yAxisRecord = prepareAxisRecord(axisRecordMap, yAxisModel);\n    xAxisRecord.rawExtentInfo = ensureScaleRawExtentInfo(xAxis.scale, xAxisModel, xAxisRecord.condExtent);\n    yAxisRecord.rawExtentInfo = ensureScaleRawExtentInfo(yAxis.scale, yAxisModel, yAxisRecord.condExtent);\n    xAxisRecord.rawExtentResult = xAxisRecord.rawExtentInfo.calculate();\n    yAxisRecord.rawExtentResult = yAxisRecord.rawExtentInfo.calculate();\n    var data = seriesRecord.seriesModel.getData();\n    var condDimMap = {};\n    var tarDimMap = {};\n    var condAxis;\n    var tarAxisRecord;\n\n    function addCondition(axis, axisRecord) {\n      var condExtent = axisRecord.condExtent;\n      var rawExtentResult = axisRecord.rawExtentResult;\n\n      if (axis.type === 'category' && (condExtent[0] < rawExtentResult.min || rawExtentResult.max < condExtent[1])) {\n        each(getDataDimensionsOnAxis(data, axis.dim), function (dataDim) {\n          if (!hasOwn(condDimMap, dataDim)) {\n            condDimMap[dataDim] = true;\n            condAxis = axis;\n          }\n        });\n      }\n    }\n\n    function addTarget(axis, axisRecord) {\n      var rawExtentResult = axisRecord.rawExtentResult;\n\n      if (axis.type !== 'category' && (!rawExtentResult.minFixed || !rawExtentResult.maxFixed)) {\n        each(getDataDimensionsOnAxis(data, axis.dim), function (dataDim) {\n          if (!hasOwn(condDimMap, dataDim) && !hasOwn(tarDimMap, dataDim)) {\n            tarDimMap[dataDim] = true;\n            tarAxisRecord = axisRecord;\n          }\n        });\n      }\n    }\n\n    addCondition(xAxis, xAxisRecord);\n    addCondition(yAxis, yAxisRecord);\n    addTarget(xAxis, xAxisRecord);\n    addTarget(yAxis, yAxisRecord);\n    var condDims = keys(condDimMap);\n    var tarDims = keys(tarDimMap);\n    var tarDimExtents = map(tarDims, function () {\n      return initExtent();\n    });\n    var condDimsLen = condDims.length;\n    var tarDimsLen = tarDims.length;\n\n    if (!condDimsLen || !tarDimsLen) {\n      return;\n    }\n\n    var singleCondDim = condDimsLen === 1 ? condDims[0] : null;\n    var singleTarDim = tarDimsLen === 1 ? tarDims[0] : null;\n    var dataLen = data.count();\n\n    if (singleCondDim && singleTarDim) {\n      for (var dataIdx = 0; dataIdx < dataLen; dataIdx++) {\n        var condVal = data.get(singleCondDim, dataIdx);\n\n        if (condAxis.scale.isInExtentRange(condVal)) {\n          unionExtent(tarDimExtents[0], data.get(singleTarDim, dataIdx));\n        }\n      }\n    } else {\n      for (var dataIdx = 0; dataIdx < dataLen; dataIdx++) {\n        for (var j = 0; j < condDimsLen; j++) {\n          var condVal = data.get(condDims[j], dataIdx);\n\n          if (condAxis.scale.isInExtentRange(condVal)) {\n            for (var k = 0; k < tarDimsLen; k++) {\n              unionExtent(tarDimExtents[k], data.get(tarDims[k], dataIdx));\n            }\n\n            break;\n          }\n        }\n      }\n    }\n\n    each(tarDimExtents, function (tarDimExtent, i) {\n      var dim = tarDims[i];\n      data.setApproximateExtent(tarDimExtent, dim);\n      var tarAxisExtent = tarAxisRecord.tarExtent = tarAxisRecord.tarExtent || initExtent();\n      unionExtent(tarAxisExtent, tarDimExtent[0]);\n      unionExtent(tarAxisExtent, tarDimExtent[1]);\n    });\n  });\n}\n\nfunction shrinkAxisExtent(axisRecordMap) {\n  axisRecordMap.each(function (axisRecord) {\n    var tarAxisExtent = axisRecord.tarExtent;\n\n    if (tarAxisExtent) {\n      var rawExtentResult = axisRecord.rawExtentResult;\n      var rawExtentInfo = axisRecord.rawExtentInfo;\n\n      if (!rawExtentResult.minFixed && tarAxisExtent[0] > rawExtentResult.min) {\n        rawExtentInfo.modifyDataMinMax('min', tarAxisExtent[0]);\n      }\n\n      if (!rawExtentResult.maxFixed && tarAxisExtent[1] < rawExtentResult.max) {\n        rawExtentInfo.modifyDataMinMax('max', tarAxisExtent[1]);\n      }\n    }\n  });\n}\n\nfunction prepareAxisRecord(axisRecordMap, axisModel) {\n  return axisRecordMap.get(axisModel.uid) || axisRecordMap.set(axisModel.uid, {\n    condExtent: initExtent()\n  });\n}\n\nfunction initExtent() {\n  return [Infinity, -Infinity];\n}\n\nfunction unionExtent(extent, val) {\n  val < extent[0] && (extent[0] = val);\n  val > extent[1] && (extent[1] = val);\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/esm/coord/cartesian/defaultAxisExtentFromData.js"],"names":["echarts","createHashMap","each","hasOwn","keys","map","isCartesian2DSeries","findAxisModels","getDataDimensionsOnAxis","unionAxisExtentFromData","ensureScaleRawExtentInfo","registerProcessor","PRIORITY","PROCESSOR","FILTER","getTargetSeries","ecModel","seriesModelMap","eachSeries","seriesModel","set","uid","overallReset","api","seriesRecords","axisRecordMap","prepareDataExtentOnAxis","calculateFilteredExtent","shrinkAxisExtent","axesModelMap","xAxisModel","yAxisModel","xAxis","axis","yAxis","xRawExtentInfo","scale","rawExtentInfo","yRawExtentInfo","data","getData","frozen","push","prepareAxisRecord","condExtent","dim","seriesRecord","xAxisRecord","yAxisRecord","rawExtentResult","calculate","condDimMap","tarDimMap","condAxis","tarAxisRecord","addCondition","axisRecord","type","min","max","dataDim","addTarget","minFixed","maxFixed","condDims","tarDims","tarDimExtents","initExtent","condDimsLen","length","tarDimsLen","singleCondDim","singleTarDim","dataLen","count","dataIdx","condVal","get","isInExtentRange","unionExtent","j","k","tarDimExtent","i","setApproximateExtent","tarAxisExtent","tarExtent","modifyDataMinMax","axisModel","Infinity","extent","val"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nimport * as echarts from '../../echarts';\nimport { createHashMap, each, hasOwn, keys, map } from 'zrender/esm/core/util';\nimport { isCartesian2DSeries, findAxisModels } from './cartesianAxisHelper';\nimport { getDataDimensionsOnAxis, unionAxisExtentFromData } from '../axisHelper';\nimport { ensureScaleRawExtentInfo } from '../scaleRawExtentInfo';\necharts.registerProcessor(echarts.PRIORITY.PROCESSOR.FILTER + 10, {\n  getTargetSeries: function (ecModel) {\n    var seriesModelMap = createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      isCartesian2DSeries(seriesModel) && seriesModelMap.set(seriesModel.uid, seriesModel);\n    });\n    return seriesModelMap;\n  },\n  overallReset: function (ecModel, api) {\n    var seriesRecords = [];\n    var axisRecordMap = createHashMap();\n    prepareDataExtentOnAxis(ecModel, axisRecordMap, seriesRecords);\n    calculateFilteredExtent(axisRecordMap, seriesRecords);\n    shrinkAxisExtent(axisRecordMap);\n  }\n});\n\nfunction prepareDataExtentOnAxis(ecModel, axisRecordMap, seriesRecords) {\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2DSeries(seriesModel)) {\n      return;\n    }\n\n    var axesModelMap = findAxisModels(seriesModel);\n    var xAxisModel = axesModelMap.xAxisModel;\n    var yAxisModel = axesModelMap.yAxisModel;\n    var xAxis = xAxisModel.axis;\n    var yAxis = yAxisModel.axis;\n    var xRawExtentInfo = xAxis.scale.rawExtentInfo;\n    var yRawExtentInfo = yAxis.scale.rawExtentInfo;\n    var data = seriesModel.getData();\n\n    if (xRawExtentInfo && xRawExtentInfo.frozen || yRawExtentInfo && yRawExtentInfo.frozen) {\n      return;\n    }\n\n    seriesRecords.push({\n      seriesModel: seriesModel,\n      xAxisModel: xAxisModel,\n      yAxisModel: yAxisModel\n    });\n    unionAxisExtentFromData(prepareAxisRecord(axisRecordMap, xAxisModel).condExtent, data, xAxis.dim);\n    unionAxisExtentFromData(prepareAxisRecord(axisRecordMap, yAxisModel).condExtent, data, yAxis.dim);\n  });\n}\n\nfunction calculateFilteredExtent(axisRecordMap, seriesRecords) {\n  each(seriesRecords, function (seriesRecord) {\n    var xAxisModel = seriesRecord.xAxisModel;\n    var yAxisModel = seriesRecord.yAxisModel;\n    var xAxis = xAxisModel.axis;\n    var yAxis = yAxisModel.axis;\n    var xAxisRecord = prepareAxisRecord(axisRecordMap, xAxisModel);\n    var yAxisRecord = prepareAxisRecord(axisRecordMap, yAxisModel);\n    xAxisRecord.rawExtentInfo = ensureScaleRawExtentInfo(xAxis.scale, xAxisModel, xAxisRecord.condExtent);\n    yAxisRecord.rawExtentInfo = ensureScaleRawExtentInfo(yAxis.scale, yAxisModel, yAxisRecord.condExtent);\n    xAxisRecord.rawExtentResult = xAxisRecord.rawExtentInfo.calculate();\n    yAxisRecord.rawExtentResult = yAxisRecord.rawExtentInfo.calculate();\n    var data = seriesRecord.seriesModel.getData();\n    var condDimMap = {};\n    var tarDimMap = {};\n    var condAxis;\n    var tarAxisRecord;\n\n    function addCondition(axis, axisRecord) {\n      var condExtent = axisRecord.condExtent;\n      var rawExtentResult = axisRecord.rawExtentResult;\n\n      if (axis.type === 'category' && (condExtent[0] < rawExtentResult.min || rawExtentResult.max < condExtent[1])) {\n        each(getDataDimensionsOnAxis(data, axis.dim), function (dataDim) {\n          if (!hasOwn(condDimMap, dataDim)) {\n            condDimMap[dataDim] = true;\n            condAxis = axis;\n          }\n        });\n      }\n    }\n\n    function addTarget(axis, axisRecord) {\n      var rawExtentResult = axisRecord.rawExtentResult;\n\n      if (axis.type !== 'category' && (!rawExtentResult.minFixed || !rawExtentResult.maxFixed)) {\n        each(getDataDimensionsOnAxis(data, axis.dim), function (dataDim) {\n          if (!hasOwn(condDimMap, dataDim) && !hasOwn(tarDimMap, dataDim)) {\n            tarDimMap[dataDim] = true;\n            tarAxisRecord = axisRecord;\n          }\n        });\n      }\n    }\n\n    addCondition(xAxis, xAxisRecord);\n    addCondition(yAxis, yAxisRecord);\n    addTarget(xAxis, xAxisRecord);\n    addTarget(yAxis, yAxisRecord);\n    var condDims = keys(condDimMap);\n    var tarDims = keys(tarDimMap);\n    var tarDimExtents = map(tarDims, function () {\n      return initExtent();\n    });\n    var condDimsLen = condDims.length;\n    var tarDimsLen = tarDims.length;\n\n    if (!condDimsLen || !tarDimsLen) {\n      return;\n    }\n\n    var singleCondDim = condDimsLen === 1 ? condDims[0] : null;\n    var singleTarDim = tarDimsLen === 1 ? tarDims[0] : null;\n    var dataLen = data.count();\n\n    if (singleCondDim && singleTarDim) {\n      for (var dataIdx = 0; dataIdx < dataLen; dataIdx++) {\n        var condVal = data.get(singleCondDim, dataIdx);\n\n        if (condAxis.scale.isInExtentRange(condVal)) {\n          unionExtent(tarDimExtents[0], data.get(singleTarDim, dataIdx));\n        }\n      }\n    } else {\n      for (var dataIdx = 0; dataIdx < dataLen; dataIdx++) {\n        for (var j = 0; j < condDimsLen; j++) {\n          var condVal = data.get(condDims[j], dataIdx);\n\n          if (condAxis.scale.isInExtentRange(condVal)) {\n            for (var k = 0; k < tarDimsLen; k++) {\n              unionExtent(tarDimExtents[k], data.get(tarDims[k], dataIdx));\n            }\n\n            break;\n          }\n        }\n      }\n    }\n\n    each(tarDimExtents, function (tarDimExtent, i) {\n      var dim = tarDims[i];\n      data.setApproximateExtent(tarDimExtent, dim);\n      var tarAxisExtent = tarAxisRecord.tarExtent = tarAxisRecord.tarExtent || initExtent();\n      unionExtent(tarAxisExtent, tarDimExtent[0]);\n      unionExtent(tarAxisExtent, tarDimExtent[1]);\n    });\n  });\n}\n\nfunction shrinkAxisExtent(axisRecordMap) {\n  axisRecordMap.each(function (axisRecord) {\n    var tarAxisExtent = axisRecord.tarExtent;\n\n    if (tarAxisExtent) {\n      var rawExtentResult = axisRecord.rawExtentResult;\n      var rawExtentInfo = axisRecord.rawExtentInfo;\n\n      if (!rawExtentResult.minFixed && tarAxisExtent[0] > rawExtentResult.min) {\n        rawExtentInfo.modifyDataMinMax('min', tarAxisExtent[0]);\n      }\n\n      if (!rawExtentResult.maxFixed && tarAxisExtent[1] < rawExtentResult.max) {\n        rawExtentInfo.modifyDataMinMax('max', tarAxisExtent[1]);\n      }\n    }\n  });\n}\n\nfunction prepareAxisRecord(axisRecordMap, axisModel) {\n  return axisRecordMap.get(axisModel.uid) || axisRecordMap.set(axisModel.uid, {\n    condExtent: initExtent()\n  });\n}\n\nfunction initExtent() {\n  return [Infinity, -Infinity];\n}\n\nfunction unionExtent(extent, val) {\n  val < extent[0] && (extent[0] = val);\n  val > extent[1] && (extent[1] = val);\n}"]},"metadata":{},"sourceType":"module"}