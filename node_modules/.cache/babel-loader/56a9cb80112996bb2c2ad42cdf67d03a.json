{"ast":null,"code":"/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\n\nexport function checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\n\nexport function checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n\n  if (vector.length !== matrix.columns) {\n    throw new RangeError('vector size must be the same as the number of columns');\n  }\n\n  return vector;\n}\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\n\nexport function checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n\n  return vector;\n}\nexport function checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices)\n  };\n}\nexport function checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some(r => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n  return rowIndices;\n}\nexport function checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some(c => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n  return columnIndices;\n}\nexport function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n\n  if (startRow > endRow || startColumn > endColumn || startRow < 0 || startRow >= matrix.rows || endRow < 0 || endRow >= matrix.rows || startColumn < 0 || startColumn >= matrix.columns || endColumn < 0 || endColumn >= matrix.columns) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\nexport function newArray(length, value = 0) {\n  let array = [];\n\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/ml-matrix/src/util.js"],"names":["checkRowIndex","matrix","index","outer","max","rows","RangeError","checkColumnIndex","columns","checkRowVector","vector","to1DArray","length","checkColumnVector","checkIndices","rowIndices","columnIndices","row","checkRowIndices","column","checkColumnIndices","TypeError","rowOut","some","r","Array","isArray","from","columnOut","c","checkRange","startRow","endRow","startColumn","endColumn","arguments","checkNumber","newArray","value","array","i","push","name"],"mappings":"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","sourcesContent":["/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nexport function checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices),\n  };\n}\n\nexport function checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some((r) => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n\n  return rowIndices;\n}\n\nexport function checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some((c) => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n\n  return columnIndices;\n}\n\nexport function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nexport function newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}