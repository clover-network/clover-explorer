{"ast":null,"code":"/**\n * Use cross product to judge the direction of the turn.\n * Returns a positive value, if OAB makes a clockwise turn,\n * negative for counter-clockwise turn, and zero if the points are collinear.\n */\nexport var cross = function cross(a, b, o) {\n  return (a.y - o.y) * (b.x - o.x) - (a.x - o.x) * (b.y - o.y);\n};\n/**\n * Generate a convex hull of given points. Andrew's monotone chain algorithm.\n * @param points An array of [x, y] representing the coordinates of points.\n * @return a list of vertices of the convex hull in counter-clockwise order,\n */\n\nexport var genConvexHull = function genConvexHull(items) {\n  var points = items.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  });\n  points.sort(function (a, b) {\n    return a.x === b.x ? a.y - b.y : a.x - b.x;\n  }); // build the lower hull\n\n  var lower = [];\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    lower.push(points[i]);\n  } // build the upper hull\n\n\n  var upper = [];\n\n  for (var i = points.length - 1; i >= 0; i--) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    upper.push(points[i]);\n  }\n\n  upper.pop();\n  lower.pop();\n  var strictHull = lower.concat(upper);\n  return strictHull;\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/shape/hull/convexHull.js"],"names":["cross","a","b","o","y","x","genConvexHull","items","points","map","item","getModel","sort","lower","i","length","pop","push","upper","strictHull","concat"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAIA,KAAK,GAAG,SAASA,KAAT,CAAeC,CAAf,EAAkBC,CAAlB,EAAqBC,CAArB,EAAwB;AACzC,SAAO,CAACF,CAAC,CAACG,CAAF,GAAMD,CAAC,CAACC,CAAT,KAAeF,CAAC,CAACG,CAAF,GAAMF,CAAC,CAACE,CAAvB,IAA4B,CAACJ,CAAC,CAACI,CAAF,GAAMF,CAAC,CAACE,CAAT,KAAeH,CAAC,CAACE,CAAF,GAAMD,CAAC,CAACC,CAAvB,CAAnC;AACD,CAFM;AAGP;AACA;AACA;AACA;AACA;;AAEA,OAAO,IAAIE,aAAa,GAAG,SAASA,aAAT,CAAuBC,KAAvB,EAA8B;AACvD,MAAIC,MAAM,GAAGD,KAAK,CAACE,GAAN,CAAU,UAAUC,IAAV,EAAgB;AACrC,WAAO;AACLL,MAAAA,CAAC,EAAEK,IAAI,CAACC,QAAL,GAAgBN,CADd;AAELD,MAAAA,CAAC,EAAEM,IAAI,CAACC,QAAL,GAAgBP;AAFd,KAAP;AAID,GALY,CAAb;AAMAI,EAAAA,MAAM,CAACI,IAAP,CAAY,UAAUX,CAAV,EAAaC,CAAb,EAAgB;AAC1B,WAAOD,CAAC,CAACI,CAAF,KAAQH,CAAC,CAACG,CAAV,GAAcJ,CAAC,CAACG,CAAF,GAAMF,CAAC,CAACE,CAAtB,GAA0BH,CAAC,CAACI,CAAF,GAAMH,CAAC,CAACG,CAAzC;AACD,GAFD,EAPuD,CASnD;;AAEJ,MAAIQ,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,MAAM,CAACO,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,WAAOD,KAAK,CAACE,MAAN,IAAgB,CAAhB,IAAqBf,KAAK,CAACa,KAAK,CAACA,KAAK,CAACE,MAAN,GAAe,CAAhB,CAAN,EAA0BF,KAAK,CAACA,KAAK,CAACE,MAAN,GAAe,CAAhB,CAA/B,EAAmDP,MAAM,CAACM,CAAD,CAAzD,CAAL,IAAsE,CAAlG,EAAqG;AACnGD,MAAAA,KAAK,CAACG,GAAN;AACD;;AAEDH,IAAAA,KAAK,CAACI,IAAN,CAAWT,MAAM,CAACM,CAAD,CAAjB;AACD,GAnBsD,CAmBrD;;;AAGF,MAAII,KAAK,GAAG,EAAZ;;AAEA,OAAK,IAAIJ,CAAC,GAAGN,MAAM,CAACO,MAAP,GAAgB,CAA7B,EAAgCD,CAAC,IAAI,CAArC,EAAwCA,CAAC,EAAzC,EAA6C;AAC3C,WAAOI,KAAK,CAACH,MAAN,IAAgB,CAAhB,IAAqBf,KAAK,CAACkB,KAAK,CAACA,KAAK,CAACH,MAAN,GAAe,CAAhB,CAAN,EAA0BG,KAAK,CAACA,KAAK,CAACH,MAAN,GAAe,CAAhB,CAA/B,EAAmDP,MAAM,CAACM,CAAD,CAAzD,CAAL,IAAsE,CAAlG,EAAqG;AACnGI,MAAAA,KAAK,CAACF,GAAN;AACD;;AAEDE,IAAAA,KAAK,CAACD,IAAN,CAAWT,MAAM,CAACM,CAAD,CAAjB;AACD;;AAEDI,EAAAA,KAAK,CAACF,GAAN;AACAH,EAAAA,KAAK,CAACG,GAAN;AACA,MAAIG,UAAU,GAAGN,KAAK,CAACO,MAAN,CAAaF,KAAb,CAAjB;AACA,SAAOC,UAAP;AACD,CApCM","sourcesContent":["/**\n * Use cross product to judge the direction of the turn.\n * Returns a positive value, if OAB makes a clockwise turn,\n * negative for counter-clockwise turn, and zero if the points are collinear.\n */\nexport var cross = function cross(a, b, o) {\n  return (a.y - o.y) * (b.x - o.x) - (a.x - o.x) * (b.y - o.y);\n};\n/**\n * Generate a convex hull of given points. Andrew's monotone chain algorithm.\n * @param points An array of [x, y] representing the coordinates of points.\n * @return a list of vertices of the convex hull in counter-clockwise order,\n */\n\nexport var genConvexHull = function genConvexHull(items) {\n  var points = items.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  });\n  points.sort(function (a, b) {\n    return a.x === b.x ? a.y - b.y : a.x - b.x;\n  }); // build the lower hull\n\n  var lower = [];\n\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n\n    lower.push(points[i]);\n  } // build the upper hull\n\n\n  var upper = [];\n\n  for (var i = points.length - 1; i >= 0; i--) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n\n    upper.push(points[i]);\n  }\n\n  upper.pop();\n  lower.pop();\n  var strictHull = lower.concat(upper);\n  return strictHull;\n};"]},"metadata":{},"sourceType":"module"}