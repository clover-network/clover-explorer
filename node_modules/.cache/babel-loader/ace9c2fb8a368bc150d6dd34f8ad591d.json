{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\nimport * as zrUtil from 'zrender/esm/core/util';\nimport IndicatorAxis from './IndicatorAxis';\nimport IntervalScale from '../../scale/Interval';\nimport * as numberUtil from '../../util/number';\nimport { getScaleExtent, niceScaleExtent } from '../axisHelper';\nimport CoordinateSystemManager from '../../CoordinateSystem';\nimport { parseAxisModelMinMax } from '../scaleRawExtentInfo';\n\nvar Radar = function () {\n  function Radar(radarModel, ecModel, api) {\n    this.dimensions = [];\n    this._model = radarModel;\n    this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n      var dim = 'indicator_' + idx;\n      var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n      indicatorAxis.name = indicatorModel.get('name');\n      indicatorAxis.model = indicatorModel;\n      indicatorModel.axis = indicatorAxis;\n      this.dimensions.push(dim);\n      return indicatorAxis;\n    }, this);\n    this.resize(radarModel, api);\n  }\n\n  Radar.prototype.getIndicatorAxes = function () {\n    return this._indicatorAxes;\n  };\n\n  Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n  };\n\n  Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n    var angle = indicatorAxis.angle;\n    var x = this.cx + coord * Math.cos(angle);\n    var y = this.cy - coord * Math.sin(angle);\n    return [x, y];\n  };\n\n  Radar.prototype.pointToData = function (pt) {\n    var dx = pt[0] - this.cx;\n    var dy = pt[1] - this.cy;\n    var radius = Math.sqrt(dx * dx + dy * dy);\n    dx /= radius;\n    dy /= radius;\n    var radian = Math.atan2(-dy, dx);\n    var minRadianDiff = Infinity;\n    var closestAxis;\n    var closestAxisIdx = -1;\n\n    for (var i = 0; i < this._indicatorAxes.length; i++) {\n      var indicatorAxis = this._indicatorAxes[i];\n      var diff = Math.abs(radian - indicatorAxis.angle);\n\n      if (diff < minRadianDiff) {\n        closestAxis = indicatorAxis;\n        closestAxisIdx = i;\n        minRadianDiff = diff;\n      }\n    }\n\n    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];\n  };\n\n  Radar.prototype.resize = function (radarModel, api) {\n    var center = radarModel.get('center');\n    var viewWidth = api.getWidth();\n    var viewHeight = api.getHeight();\n    var viewSize = Math.min(viewWidth, viewHeight) / 2;\n    this.cx = numberUtil.parsePercent(center[0], viewWidth);\n    this.cy = numberUtil.parsePercent(center[1], viewHeight);\n    this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n    var radius = radarModel.get('radius');\n\n    if (typeof radius === 'string' || typeof radius === 'number') {\n      radius = [0, radius];\n    }\n\n    this.r0 = numberUtil.parsePercent(radius[0], viewSize);\n    this.r = numberUtil.parsePercent(radius[1], viewSize);\n    zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n      indicatorAxis.setExtent(this.r0, this.r);\n      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;\n      angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n      indicatorAxis.angle = angle;\n    }, this);\n  };\n\n  Radar.prototype.update = function (ecModel, api) {\n    var indicatorAxes = this._indicatorAxes;\n    var radarModel = this._model;\n    zrUtil.each(indicatorAxes, function (indicatorAxis) {\n      indicatorAxis.scale.setExtent(Infinity, -Infinity);\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n      if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {\n        return;\n      }\n\n      var data = radarSeries.getData();\n      zrUtil.each(indicatorAxes, function (indicatorAxis) {\n        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));\n      });\n    }, this);\n    var splitNumber = radarModel.get('splitNumber');\n\n    function increaseInterval(interval) {\n      var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n      var f = interval / exp10;\n\n      if (f === 2) {\n        f = 5;\n      } else {\n        f *= 2;\n      }\n\n      return f * exp10;\n    }\n\n    zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n      var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model).extent;\n      niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n      var axisModel = indicatorAxis.model;\n      var scale = indicatorAxis.scale;\n      var fixedMin = parseAxisModelMinMax(scale, axisModel.get('min', true));\n      var fixedMax = parseAxisModelMinMax(scale, axisModel.get('max', true));\n      var interval = scale.getInterval();\n\n      if (fixedMin != null && fixedMax != null) {\n        scale.setExtent(+fixedMin, +fixedMax);\n        scale.setInterval((fixedMax - fixedMin) / splitNumber);\n      } else if (fixedMin != null) {\n        var max = void 0;\n\n        do {\n          max = fixedMin + interval * splitNumber;\n          scale.setExtent(+fixedMin, max);\n          scale.setInterval(interval);\n          interval = increaseInterval(interval);\n        } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n      } else if (fixedMax != null) {\n        var min = void 0;\n\n        do {\n          min = fixedMax - interval * splitNumber;\n          scale.setExtent(min, +fixedMax);\n          scale.setInterval(interval);\n          interval = increaseInterval(interval);\n        } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n      } else {\n        var nicedSplitNumber = scale.getTicks().length - 1;\n\n        if (nicedSplitNumber > splitNumber) {\n          interval = increaseInterval(interval);\n        }\n\n        var max = Math.ceil(rawExtent[1] / interval) * interval;\n        var min = numberUtil.round(max - interval * splitNumber);\n        scale.setExtent(min, max);\n        scale.setInterval(interval);\n      }\n    });\n  };\n\n  Radar.prototype.convertToPixel = function (ecModel, finder, value) {\n    console.warn('Not implemented.');\n    return null;\n  };\n\n  Radar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    console.warn('Not implemented.');\n    return null;\n  };\n\n  Radar.prototype.containPoint = function (point) {\n    console.warn('Not implemented.');\n    return false;\n  };\n\n  Radar.create = function (ecModel, api) {\n    var radarList = [];\n    ecModel.eachComponent('radar', function (radarModel) {\n      var radar = new Radar(radarModel, ecModel, api);\n      radarList.push(radar);\n      radarModel.coordinateSystem = radar;\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries) {\n      if (radarSeries.get('coordinateSystem') === 'radar') {\n        radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n      }\n    });\n    return radarList;\n  };\n\n  Radar.dimensions = [];\n  return Radar;\n}();\n\nCoordinateSystemManager.register('radar', Radar);\nexport default Radar;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/esm/coord/radar/Radar.js"],"names":["zrUtil","IndicatorAxis","IntervalScale","numberUtil","getScaleExtent","niceScaleExtent","CoordinateSystemManager","parseAxisModelMinMax","Radar","radarModel","ecModel","api","dimensions","_model","_indicatorAxes","map","getIndicatorModels","indicatorModel","idx","dim","indicatorAxis","name","get","model","axis","push","resize","prototype","getIndicatorAxes","dataToPoint","value","indicatorIndex","coordToPoint","dataToCoord","coord","angle","x","cx","Math","cos","y","cy","sin","pointToData","pt","dx","dy","radius","sqrt","radian","atan2","minRadianDiff","Infinity","closestAxis","closestAxisIdx","i","length","diff","abs","coordToData","center","viewWidth","getWidth","viewHeight","getHeight","viewSize","min","parsePercent","startAngle","PI","r0","r","each","setExtent","update","indicatorAxes","scale","eachSeriesByType","radarSeries","getComponent","data","getData","unionExtentFromData","mapDimension","splitNumber","increaseInterval","interval","exp10","pow","floor","log","LN10","f","rawExtent","extent","axisModel","fixedMin","fixedMax","getInterval","setInterval","max","isFinite","nicedSplitNumber","getTicks","ceil","round","convertToPixel","finder","console","warn","convertFromPixel","pixel","containPoint","point","create","radarList","eachComponent","radar","coordinateSystem","register"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nimport * as zrUtil from 'zrender/esm/core/util';\nimport IndicatorAxis from './IndicatorAxis';\nimport IntervalScale from '../../scale/Interval';\nimport * as numberUtil from '../../util/number';\nimport { getScaleExtent, niceScaleExtent } from '../axisHelper';\nimport CoordinateSystemManager from '../../CoordinateSystem';\nimport { parseAxisModelMinMax } from '../scaleRawExtentInfo';\n\nvar Radar = function () {\n  function Radar(radarModel, ecModel, api) {\n    this.dimensions = [];\n    this._model = radarModel;\n    this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {\n      var dim = 'indicator_' + idx;\n      var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());\n      indicatorAxis.name = indicatorModel.get('name');\n      indicatorAxis.model = indicatorModel;\n      indicatorModel.axis = indicatorAxis;\n      this.dimensions.push(dim);\n      return indicatorAxis;\n    }, this);\n    this.resize(radarModel, api);\n  }\n\n  Radar.prototype.getIndicatorAxes = function () {\n    return this._indicatorAxes;\n  };\n\n  Radar.prototype.dataToPoint = function (value, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n    return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);\n  };\n\n  Radar.prototype.coordToPoint = function (coord, indicatorIndex) {\n    var indicatorAxis = this._indicatorAxes[indicatorIndex];\n    var angle = indicatorAxis.angle;\n    var x = this.cx + coord * Math.cos(angle);\n    var y = this.cy - coord * Math.sin(angle);\n    return [x, y];\n  };\n\n  Radar.prototype.pointToData = function (pt) {\n    var dx = pt[0] - this.cx;\n    var dy = pt[1] - this.cy;\n    var radius = Math.sqrt(dx * dx + dy * dy);\n    dx /= radius;\n    dy /= radius;\n    var radian = Math.atan2(-dy, dx);\n    var minRadianDiff = Infinity;\n    var closestAxis;\n    var closestAxisIdx = -1;\n\n    for (var i = 0; i < this._indicatorAxes.length; i++) {\n      var indicatorAxis = this._indicatorAxes[i];\n      var diff = Math.abs(radian - indicatorAxis.angle);\n\n      if (diff < minRadianDiff) {\n        closestAxis = indicatorAxis;\n        closestAxisIdx = i;\n        minRadianDiff = diff;\n      }\n    }\n\n    return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))];\n  };\n\n  Radar.prototype.resize = function (radarModel, api) {\n    var center = radarModel.get('center');\n    var viewWidth = api.getWidth();\n    var viewHeight = api.getHeight();\n    var viewSize = Math.min(viewWidth, viewHeight) / 2;\n    this.cx = numberUtil.parsePercent(center[0], viewWidth);\n    this.cy = numberUtil.parsePercent(center[1], viewHeight);\n    this.startAngle = radarModel.get('startAngle') * Math.PI / 180;\n    var radius = radarModel.get('radius');\n\n    if (typeof radius === 'string' || typeof radius === 'number') {\n      radius = [0, radius];\n    }\n\n    this.r0 = numberUtil.parsePercent(radius[0], viewSize);\n    this.r = numberUtil.parsePercent(radius[1], viewSize);\n    zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {\n      indicatorAxis.setExtent(this.r0, this.r);\n      var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;\n      angle = Math.atan2(Math.sin(angle), Math.cos(angle));\n      indicatorAxis.angle = angle;\n    }, this);\n  };\n\n  Radar.prototype.update = function (ecModel, api) {\n    var indicatorAxes = this._indicatorAxes;\n    var radarModel = this._model;\n    zrUtil.each(indicatorAxes, function (indicatorAxis) {\n      indicatorAxis.scale.setExtent(Infinity, -Infinity);\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries, idx) {\n      if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {\n        return;\n      }\n\n      var data = radarSeries.getData();\n      zrUtil.each(indicatorAxes, function (indicatorAxis) {\n        indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim));\n      });\n    }, this);\n    var splitNumber = radarModel.get('splitNumber');\n\n    function increaseInterval(interval) {\n      var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));\n      var f = interval / exp10;\n\n      if (f === 2) {\n        f = 5;\n      } else {\n        f *= 2;\n      }\n\n      return f * exp10;\n    }\n\n    zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {\n      var rawExtent = getScaleExtent(indicatorAxis.scale, indicatorAxis.model).extent;\n      niceScaleExtent(indicatorAxis.scale, indicatorAxis.model);\n      var axisModel = indicatorAxis.model;\n      var scale = indicatorAxis.scale;\n      var fixedMin = parseAxisModelMinMax(scale, axisModel.get('min', true));\n      var fixedMax = parseAxisModelMinMax(scale, axisModel.get('max', true));\n      var interval = scale.getInterval();\n\n      if (fixedMin != null && fixedMax != null) {\n        scale.setExtent(+fixedMin, +fixedMax);\n        scale.setInterval((fixedMax - fixedMin) / splitNumber);\n      } else if (fixedMin != null) {\n        var max = void 0;\n\n        do {\n          max = fixedMin + interval * splitNumber;\n          scale.setExtent(+fixedMin, max);\n          scale.setInterval(interval);\n          interval = increaseInterval(interval);\n        } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));\n      } else if (fixedMax != null) {\n        var min = void 0;\n\n        do {\n          min = fixedMax - interval * splitNumber;\n          scale.setExtent(min, +fixedMax);\n          scale.setInterval(interval);\n          interval = increaseInterval(interval);\n        } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));\n      } else {\n        var nicedSplitNumber = scale.getTicks().length - 1;\n\n        if (nicedSplitNumber > splitNumber) {\n          interval = increaseInterval(interval);\n        }\n\n        var max = Math.ceil(rawExtent[1] / interval) * interval;\n        var min = numberUtil.round(max - interval * splitNumber);\n        scale.setExtent(min, max);\n        scale.setInterval(interval);\n      }\n    });\n  };\n\n  Radar.prototype.convertToPixel = function (ecModel, finder, value) {\n    console.warn('Not implemented.');\n    return null;\n  };\n\n  Radar.prototype.convertFromPixel = function (ecModel, finder, pixel) {\n    console.warn('Not implemented.');\n    return null;\n  };\n\n  Radar.prototype.containPoint = function (point) {\n    console.warn('Not implemented.');\n    return false;\n  };\n\n  Radar.create = function (ecModel, api) {\n    var radarList = [];\n    ecModel.eachComponent('radar', function (radarModel) {\n      var radar = new Radar(radarModel, ecModel, api);\n      radarList.push(radar);\n      radarModel.coordinateSystem = radar;\n    });\n    ecModel.eachSeriesByType('radar', function (radarSeries) {\n      if (radarSeries.get('coordinateSystem') === 'radar') {\n        radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];\n      }\n    });\n    return radarList;\n  };\n\n  Radar.dimensions = [];\n  return Radar;\n}();\n\nCoordinateSystemManager.register('radar', Radar);\nexport default Radar;"]},"metadata":{},"sourceType":"module"}