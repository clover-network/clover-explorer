{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport Global from '../global';\nimport { applyMatrix } from './math';\nimport letterAspectRatio from './letterAspectRatio';\nimport { isString, clone } from '@antv/util';\nvar PI = Math.PI,\n    sin = Math.sin,\n    cos = Math.cos; // 一共支持8个方向的自环，每个环占的角度是45度，在计算时再二分，为22.5度\n\nvar SELF_LINK_SIN = sin(PI / 8);\nvar SELF_LINK_COS = cos(PI / 8);\nexport var getBBox = function getBBox(element, group) {\n  var bbox = element.getBBox();\n  var leftTop = {\n    x: bbox.minX,\n    y: bbox.minY\n  };\n  var rightBottom = {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }; // 根据父元素变换矩阵\n\n  if (group) {\n    var matrix = group.getMatrix();\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    leftTop = applyMatrix(leftTop, matrix);\n    rightBottom = applyMatrix(rightBottom, matrix);\n  }\n\n  var lx = leftTop.x,\n      ly = leftTop.y;\n  var rx = rightBottom.x,\n      ry = rightBottom.y;\n  return {\n    x: lx,\n    y: ly,\n    minX: lx,\n    minY: ly,\n    maxX: rx,\n    maxY: ry,\n    width: rx - lx,\n    height: ry - ly\n  };\n};\n/**\n * get loop edge config\n * @param cfg edge config\n */\n\nexport var getLoopCfgs = function getLoopCfgs(cfg) {\n  var item = cfg.sourceNode || cfg.targetNode;\n  var container = item.get('group');\n  var containerMatrix = container.getMatrix();\n  if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var keyShape = item.getKeyShape();\n  var bbox = keyShape.getBBox();\n  var loopCfg = cfg.loopCfg || {}; // 距离keyShape边的最高距离\n\n  var dist = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2; // 自环边与keyShape的相对位置关系\n\n  var position = loopCfg.position || Global.defaultLoopPosition; // 中心取group上真实位置\n\n  var center = [containerMatrix[6], containerMatrix[7]];\n  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];\n  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];\n  var rstart = bbox.height / 2;\n  var rend = bbox.height / 2;\n  var sinDeltaStart = rstart * SELF_LINK_SIN;\n  var cosDeltaStart = rstart * SELF_LINK_COS;\n  var sinDeltaEnd = rend * SELF_LINK_SIN;\n  var cosDeltaEnd = rend * SELF_LINK_COS; // 如果定义了锚点的，直接用锚点坐标，否则，根据自环的 cfg 计算\n\n  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {\n    switch (position) {\n      case 'top':\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      case 'top-right':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'right':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'bottom-right':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom':\n        rstart = bbox.height / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom-left':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'left':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'top-left':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      default:\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n    } // 如果逆时针画，交换起点和终点\n\n\n    if (loopCfg.clockwise === false) {\n      var swap = [startPoint[0], startPoint[1]];\n      startPoint = [endPoint[0], endPoint[1]];\n      endPoint = [swap[0], swap[1]];\n    }\n  }\n\n  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];\n  var scaleRateStart = (rstart + dist) / rstart;\n  var scaleRateEnd = (rend + dist) / rend;\n\n  if (loopCfg.clockwise === false) {\n    scaleRateStart = (rend + dist) / rend;\n    scaleRateEnd = (rstart + dist) / rstart;\n  }\n\n  var startExtendVec = vec2.scale([], startVec, scaleRateStart);\n  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];\n  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];\n  var endExtendVec = vec2.scale([], endVec, scaleRateEnd);\n  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];\n  cfg.startPoint = {\n    x: startPoint[0],\n    y: startPoint[1]\n  };\n  cfg.endPoint = {\n    x: endPoint[0],\n    y: endPoint[1]\n  };\n  cfg.controlPoints = [{\n    x: controlPoint1[0],\n    y: controlPoint1[1]\n  }, {\n    x: controlPoint2[0],\n    y: controlPoint2[1]\n  }];\n  return cfg;\n};\n/**\n * 根据 label 所在线条的位置百分比，计算 label 坐标\n * @param {object}  pathShape  G 的 path 实例，一般是 Edge 实例的 keyShape\n * @param {number}  percent    范围 0 - 1 的线条百分比\n * @param {number}  refX     x 轴正方向为基准的 label 偏移\n * @param {number}  refY     y 轴正方向为基准的 label 偏移\n * @param {boolean} rotate     是否根据线条斜率旋转文本\n * @return {object} 文本的 x, y, 文本的旋转角度\n */\n\nexport var getLabelPosition = function getLabelPosition(pathShape, percent, refX, refY, rotate) {\n  var TAN_OFFSET = 0.0001;\n  var vector = [];\n  var point = pathShape.getPoint(percent);\n\n  if (point === null) {\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  } // 头尾最可能，放在最前面，使用 g path 上封装的方法\n\n\n  if (percent < TAN_OFFSET) {\n    vector = pathShape.getStartTangent().reverse();\n  } else if (percent > 1 - TAN_OFFSET) {\n    vector = pathShape.getEndTangent();\n  } else {\n    // 否则取指定位置的点,与少量偏移的点，做微分向量\n    var offsetPoint = pathShape.getPoint(percent + TAN_OFFSET);\n    vector.push([point.x, point.y]);\n    vector.push([offsetPoint.x, offsetPoint.y]);\n  }\n\n  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);\n\n  if (rad < 0) {\n    rad += PI * 2;\n  }\n\n  if (refX) {\n    point.x += cos(rad) * refX;\n    point.y += sin(rad) * refX;\n  }\n\n  if (refY) {\n    // 默认方向是 x 轴正方向，法线是 求出角度 - 90°\n    var normal = rad - PI / 2; // 若法线角度在 y 轴负方向，切到正方向，保证 refY 相对于 y 轴正方向\n\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      normal -= PI;\n    }\n\n    point.x += cos(normal) * refY;\n    point.y += sin(normal) * refY;\n  }\n\n  var result = {\n    x: point.x,\n    y: point.y,\n    angle: rad\n  };\n\n  if (rotate) {\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      rad -= PI;\n    }\n\n    return __assign({\n      rotate: rad\n    }, result);\n  }\n\n  return result;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\nvar traverse = function traverse(data, fn) {\n  if (fn(data) === false) {\n    return false;\n  }\n\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverse(data.children[i], fn)) return false;\n    }\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (fn(data) === false) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nexport var traverseTree = function traverseTree(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverse(data, fn);\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\nexport var traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\n\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  }; // 默认布局是垂直布局TB，此时x对应rad，y对应r\n\n  var rScale = 'x';\n  var radScale = 'y';\n\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n\n    return true;\n  });\n  var avgRad = PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n\n  if (radDiff === 0) {\n    return data;\n  }\n\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};\n/**\n *\n * @param letter the letter\n * @param fontSize\n * @return the letter's width\n */\n\nexport var getLetterWidth = function getLetterWidth(letter, fontSize) {\n  return fontSize * (letterAspectRatio[letter] || 1);\n};\n/**\n *\n * @param text the text\n * @param fontSize\n * @return the text's size\n */\n\nexport var getTextSize = function getTextSize(text, fontSize) {\n  var width = 0;\n  var pattern = new RegExp(\"[\\u4E00-\\u9FA5]+\");\n  text.split('').forEach(function (letter) {\n    if (pattern.test(letter)) {\n      // 中文字符\n      width += fontSize;\n    } else {\n      width += getLetterWidth(letter, fontSize);\n    }\n  });\n  return [width, fontSize];\n};\n/**\n * construct the trees from combos data\n * @param array the combos array\n * @param nodes the nodes array\n * @return the tree\n */\n\nexport var plainCombosToTrees = function plainCombosToTrees(array, nodes) {\n  var result = [];\n  var addedMap = {};\n  var modelMap = {};\n  array.forEach(function (d) {\n    modelMap[d.id] = d;\n  });\n  array.forEach(function (d, i) {\n    var cd = clone(d);\n    cd.itemType = 'combo';\n    cd.children = undefined;\n\n    if (cd.parentId === cd.id) {\n      console.warn(\"The parentId for combo \" + cd.id + \" can not be the same as the combo's id\");\n      delete cd.parentId;\n    } else if (cd.parentId && !modelMap[cd.parentId]) {\n      console.warn(\"The parent combo for combo \" + cd.id + \" does not exist!\");\n      delete cd.parentId;\n    }\n\n    var mappedObj = addedMap[cd.id];\n\n    if (mappedObj) {\n      cd.children = mappedObj.children;\n      addedMap[cd.id] = cd;\n      mappedObj = cd;\n\n      if (!mappedObj.parentId) {\n        result.push(mappedObj);\n        return;\n      }\n\n      var mappedParent = addedMap[mappedObj.parentId];\n\n      if (mappedParent) {\n        if (mappedParent.children) mappedParent.children.push(cd);else mappedParent.children = [cd];\n      } else {\n        var parent_1 = {\n          id: mappedObj.parentId,\n          children: [mappedObj]\n        };\n        addedMap[mappedObj.parentId] = parent_1;\n        addedMap[cd.id] = cd;\n      }\n\n      return;\n    }\n\n    if (isString(d.parentId)) {\n      var parent_2 = addedMap[d.parentId];\n\n      if (parent_2) {\n        if (parent_2.children) parent_2.children.push(cd);else parent_2.children = [cd];\n        addedMap[cd.id] = cd;\n      } else {\n        var pa = {\n          id: d.parentId,\n          children: [cd]\n        };\n        addedMap[pa.id] = pa;\n        addedMap[cd.id] = cd;\n      }\n    } else {\n      result.push(cd);\n      addedMap[cd.id] = cd;\n    }\n  }); // proccess the nodes\n\n  var nodeMap = {};\n  (nodes || []).forEach(function (node) {\n    nodeMap[node.id] = node;\n    var combo = addedMap[node.comboId];\n\n    if (combo) {\n      var cnode = {\n        id: node.id,\n        comboId: node.comboId\n      };\n      if (combo.children) combo.children.push(cnode);else combo.children = [cnode];\n      cnode.itemType = 'node';\n      addedMap[node.id] = cnode;\n    }\n  }); // assign the depth for each element\n\n  result.forEach(function (tree) {\n    tree.depth = 0;\n    traverse(tree, function (child) {\n      var parent;\n      var itemType = addedMap[child.id].itemType;\n\n      if (itemType === 'node') {\n        parent = addedMap[child.comboId];\n      } else {\n        parent = addedMap[child.parentId];\n      }\n\n      if (parent) {\n        if (itemType === 'node') child.depth = parent.depth + 1;else child.depth = parent.depth + 2;\n      } else {\n        child.depth = 0;\n      }\n\n      var oriNodeModel = nodeMap[child.id];\n\n      if (oriNodeModel) {\n        oriNodeModel.depth = child.depth;\n      }\n\n      return true;\n    });\n  });\n  return result;\n};\nexport var reconstructTree = function reconstructTree(trees, subtreeId, newParentId) {\n  var brothers = trees;\n  var subtree;\n  var comboChildsMap = {\n    root: {\n      children: trees\n    }\n  };\n  var foundSubTree = false;\n  var oldParentId = 'root';\n  (trees || []).forEach(function (tree) {\n    if (foundSubTree) return;\n\n    if (tree.id === subtreeId) {\n      subtree = tree;\n\n      if (tree.itemType === 'combo') {\n        subtree.parentId = newParentId;\n      } else {\n        subtree.comboId = newParentId;\n      }\n\n      foundSubTree = true;\n      return;\n    }\n\n    traverseTree(tree, function (child) {\n      comboChildsMap[child.id] = {\n        children: child.children\n      }; // store the old parent id to delete the subtree from the old parent's children in next recursion\n\n      brothers = comboChildsMap[child.parentId || child.comboId || 'root'].children;\n\n      if (child && (child.removed || subtreeId === child.id) && brothers) {\n        oldParentId = child.parentId || child.comboId || 'root';\n        subtree = child; // re-assign the parentId or comboId for the moved subtree\n\n        if (child.itemType === 'combo') {\n          subtree.parentId = newParentId;\n        } else {\n          subtree.comboId = newParentId;\n        }\n\n        foundSubTree = true;\n        return false;\n      }\n\n      return true;\n    });\n  });\n  brothers = comboChildsMap[oldParentId].children;\n  var index = brothers ? brothers.indexOf(subtree) : -1;\n  if (index > -1) brothers.splice(index, 1); // 如果遍历完整棵树还没有找到，说明之前就不在树中\n\n  if (!foundSubTree) {\n    subtree = {\n      id: subtreeId,\n      itemType: 'node',\n      comboId: newParentId\n    };\n    comboChildsMap[subtreeId] = {\n      children: undefined\n    };\n  } // append to new parent\n\n\n  if (subtreeId) {\n    var found_1 = false; // newParentId is undefined means the subtree will have no parent\n\n    if (newParentId) {\n      var newParentDepth_1 = 0;\n      (trees || []).forEach(function (tree) {\n        if (found_1) return; // terminate\n\n        traverseTree(tree, function (child) {\n          // append subtree to the new parent ans assign the depth to the subtree\n          if (newParentId === child.id) {\n            found_1 = true;\n            if (child.children) child.children.push(subtree);else child.children = [subtree];\n            newParentDepth_1 = child.depth;\n            if (subtree.itemType === 'node') subtree.depth = newParentDepth_1 + 2;else subtree.depth = newParentDepth_1 + 1;\n            return false; // terminate\n          }\n\n          return true;\n        });\n      });\n    } else if ((!newParentId || !found_1) && subtree.itemType !== 'node') {\n      // if the newParentId is undefined or it is not found in the tree, add the subTree to the root\n      trees.push(subtree);\n    } // update the depth of the subtree and its children from the subtree\n\n\n    var currentDepth_1 = subtree.depth;\n    traverseTree(subtree, function (child) {\n      if (child.itemType === 'node') currentDepth_1 += 2;else currentDepth_1 += 1;\n      child.depth = currentDepth_1;\n      return true;\n    });\n  }\n\n  return trees;\n};\nexport var getComboBBox = function getComboBBox(children, graph) {\n  var comboBBox = {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity,\n    x: undefined,\n    y: undefined,\n    width: undefined,\n    height: undefined,\n    centerX: undefined,\n    centerY: undefined\n  };\n\n  if (!children || children.length === 0) {\n    return comboBBox;\n  }\n\n  children.forEach(function (child) {\n    var childItem = graph.findById(child.id);\n    if (!childItem || !childItem.isVisible()) return; // ignore hidden children\n\n    childItem.set('bboxCanvasCache', undefined);\n    var childBBox = childItem.getCanvasBBox();\n    if (childBBox.x && comboBBox.minX > childBBox.minX) comboBBox.minX = childBBox.minX;\n    if (childBBox.y && comboBBox.minY > childBBox.minY) comboBBox.minY = childBBox.minY;\n    if (childBBox.x && comboBBox.maxX < childBBox.maxX) comboBBox.maxX = childBBox.maxX;\n    if (childBBox.y && comboBBox.maxY < childBBox.maxY) comboBBox.maxY = childBBox.maxY;\n  });\n  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;\n  comboBBox.width = comboBBox.maxX - comboBBox.minX;\n  comboBBox.height = comboBBox.maxY - comboBBox.minY;\n  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;\n  Object.keys(comboBBox).forEach(function (key) {\n    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {\n      comboBBox[key] = undefined;\n    }\n  });\n  return comboBBox;\n};\nexport var getChartRegion = function getChartRegion(params) {\n  var group = params.group,\n      height = params.height,\n      width = params.width,\n      x = params.x,\n      y = params.y;\n  var canvas = group.get('canvas');\n  var canvasWidth = canvas.get('width');\n  var canvasHeight = canvas.get('height');\n  var region = {\n    start: {\n      x: 0,\n      y: 0\n    },\n    end: {\n      x: 0,\n      y: 0\n    }\n  };\n  region.start.x = x / canvasWidth;\n  region.start.y = y / canvasHeight;\n  region.end.x = (x + width) / canvasWidth;\n  region.end.y = (y + height) / canvasHeight;\n  return region;\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/util/graphic.js"],"names":["__assign","vec2","Global","applyMatrix","letterAspectRatio","isString","clone","PI","Math","sin","cos","SELF_LINK_SIN","SELF_LINK_COS","getBBox","element","group","bbox","leftTop","x","minX","y","minY","rightBottom","maxX","maxY","matrix","getMatrix","lx","ly","rx","ry","width","height","getLoopCfgs","cfg","item","sourceNode","targetNode","container","get","containerMatrix","keyShape","getKeyShape","loopCfg","dist","max","position","defaultLoopPosition","center","startPoint","endPoint","rstart","rend","sinDeltaStart","cosDeltaStart","sinDeltaEnd","cosDeltaEnd","clockwise","swap","startVec","scaleRateStart","scaleRateEnd","startExtendVec","scale","controlPoint1","endVec","endExtendVec","controlPoint2","controlPoints","getLabelPosition","pathShape","percent","refX","refY","rotate","TAN_OFFSET","vector","point","getPoint","angle","getStartTangent","reverse","getEndTangent","offsetPoint","push","rad","atan2","normal","result","traverse","data","fn","children","i","length","traverseUp","traverseTree","traverseTreeUp","radialLayout","layout","VERTICAL_LAYOUTS","min","Infinity","rScale","radScale","indexOf","count","node","avgRad","radDiff","radial","r","abs","getLetterWidth","letter","fontSize","getTextSize","text","pattern","RegExp","split","forEach","test","plainCombosToTrees","array","nodes","addedMap","modelMap","d","id","cd","itemType","undefined","parentId","console","warn","mappedObj","mappedParent","parent_1","parent_2","pa","nodeMap","combo","comboId","cnode","tree","depth","child","parent","oriNodeModel","reconstructTree","trees","subtreeId","newParentId","brothers","subtree","comboChildsMap","root","foundSubTree","oldParentId","removed","index","splice","found_1","newParentDepth_1","currentDepth_1","getComboBBox","graph","comboBBox","centerX","centerY","childItem","findById","isVisible","set","childBBox","getCanvasBBox","Object","keys","key","getChartRegion","params","canvas","canvasWidth","canvasHeight","region","start","end"],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { vec2 } from '@antv/matrix-util';\nimport Global from '../global';\nimport { applyMatrix } from './math';\nimport letterAspectRatio from './letterAspectRatio';\nimport { isString, clone } from '@antv/util';\nvar PI = Math.PI,\n    sin = Math.sin,\n    cos = Math.cos; // 一共支持8个方向的自环，每个环占的角度是45度，在计算时再二分，为22.5度\n\nvar SELF_LINK_SIN = sin(PI / 8);\nvar SELF_LINK_COS = cos(PI / 8);\nexport var getBBox = function getBBox(element, group) {\n  var bbox = element.getBBox();\n  var leftTop = {\n    x: bbox.minX,\n    y: bbox.minY\n  };\n  var rightBottom = {\n    x: bbox.maxX,\n    y: bbox.maxY\n  }; // 根据父元素变换矩阵\n\n  if (group) {\n    var matrix = group.getMatrix();\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    leftTop = applyMatrix(leftTop, matrix);\n    rightBottom = applyMatrix(rightBottom, matrix);\n  }\n\n  var lx = leftTop.x,\n      ly = leftTop.y;\n  var rx = rightBottom.x,\n      ry = rightBottom.y;\n  return {\n    x: lx,\n    y: ly,\n    minX: lx,\n    minY: ly,\n    maxX: rx,\n    maxY: ry,\n    width: rx - lx,\n    height: ry - ly\n  };\n};\n/**\n * get loop edge config\n * @param cfg edge config\n */\n\nexport var getLoopCfgs = function getLoopCfgs(cfg) {\n  var item = cfg.sourceNode || cfg.targetNode;\n  var container = item.get('group');\n  var containerMatrix = container.getMatrix();\n  if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  var keyShape = item.getKeyShape();\n  var bbox = keyShape.getBBox();\n  var loopCfg = cfg.loopCfg || {}; // 距离keyShape边的最高距离\n\n  var dist = loopCfg.dist || Math.max(bbox.width, bbox.height) * 2; // 自环边与keyShape的相对位置关系\n\n  var position = loopCfg.position || Global.defaultLoopPosition; // 中心取group上真实位置\n\n  var center = [containerMatrix[6], containerMatrix[7]];\n  var startPoint = [cfg.startPoint.x, cfg.startPoint.y];\n  var endPoint = [cfg.endPoint.x, cfg.endPoint.y];\n  var rstart = bbox.height / 2;\n  var rend = bbox.height / 2;\n  var sinDeltaStart = rstart * SELF_LINK_SIN;\n  var cosDeltaStart = rstart * SELF_LINK_COS;\n  var sinDeltaEnd = rend * SELF_LINK_SIN;\n  var cosDeltaEnd = rend * SELF_LINK_COS; // 如果定义了锚点的，直接用锚点坐标，否则，根据自环的 cfg 计算\n\n  if (startPoint[0] === endPoint[0] && startPoint[1] === endPoint[1]) {\n    switch (position) {\n      case 'top':\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      case 'top-right':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'right':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] + cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'bottom-right':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom':\n        rstart = bbox.height / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] + sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] + cosDeltaEnd];\n        break;\n\n      case 'bottom-left':\n        rstart = bbox.height / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] + cosDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] + sinDeltaEnd];\n        break;\n\n      case 'left':\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] + sinDeltaStart];\n        endPoint = [center[0] - cosDeltaEnd, center[1] - sinDeltaEnd];\n        break;\n\n      case 'top-left':\n        rstart = bbox.width / 2;\n        rend = bbox.height / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - cosDeltaStart, center[1] - sinDeltaStart];\n        endPoint = [center[0] - sinDeltaEnd, center[1] - cosDeltaEnd];\n        break;\n\n      default:\n        rstart = bbox.width / 2;\n        rend = bbox.width / 2;\n        sinDeltaStart = rstart * SELF_LINK_SIN;\n        cosDeltaStart = rstart * SELF_LINK_COS;\n        sinDeltaEnd = rend * SELF_LINK_SIN;\n        cosDeltaEnd = rend * SELF_LINK_COS;\n        startPoint = [center[0] - sinDeltaStart, center[1] - cosDeltaStart];\n        endPoint = [center[0] + sinDeltaEnd, center[1] - cosDeltaEnd];\n    } // 如果逆时针画，交换起点和终点\n\n\n    if (loopCfg.clockwise === false) {\n      var swap = [startPoint[0], startPoint[1]];\n      startPoint = [endPoint[0], endPoint[1]];\n      endPoint = [swap[0], swap[1]];\n    }\n  }\n\n  var startVec = [startPoint[0] - center[0], startPoint[1] - center[1]];\n  var scaleRateStart = (rstart + dist) / rstart;\n  var scaleRateEnd = (rend + dist) / rend;\n\n  if (loopCfg.clockwise === false) {\n    scaleRateStart = (rend + dist) / rend;\n    scaleRateEnd = (rstart + dist) / rstart;\n  }\n\n  var startExtendVec = vec2.scale([], startVec, scaleRateStart);\n  var controlPoint1 = [center[0] + startExtendVec[0], center[1] + startExtendVec[1]];\n  var endVec = [endPoint[0] - center[0], endPoint[1] - center[1]];\n  var endExtendVec = vec2.scale([], endVec, scaleRateEnd);\n  var controlPoint2 = [center[0] + endExtendVec[0], center[1] + endExtendVec[1]];\n  cfg.startPoint = {\n    x: startPoint[0],\n    y: startPoint[1]\n  };\n  cfg.endPoint = {\n    x: endPoint[0],\n    y: endPoint[1]\n  };\n  cfg.controlPoints = [{\n    x: controlPoint1[0],\n    y: controlPoint1[1]\n  }, {\n    x: controlPoint2[0],\n    y: controlPoint2[1]\n  }];\n  return cfg;\n};\n/**\n * 根据 label 所在线条的位置百分比，计算 label 坐标\n * @param {object}  pathShape  G 的 path 实例，一般是 Edge 实例的 keyShape\n * @param {number}  percent    范围 0 - 1 的线条百分比\n * @param {number}  refX     x 轴正方向为基准的 label 偏移\n * @param {number}  refY     y 轴正方向为基准的 label 偏移\n * @param {boolean} rotate     是否根据线条斜率旋转文本\n * @return {object} 文本的 x, y, 文本的旋转角度\n */\n\nexport var getLabelPosition = function getLabelPosition(pathShape, percent, refX, refY, rotate) {\n  var TAN_OFFSET = 0.0001;\n  var vector = [];\n  var point = pathShape.getPoint(percent);\n\n  if (point === null) {\n    return {\n      x: 0,\n      y: 0,\n      angle: 0\n    };\n  } // 头尾最可能，放在最前面，使用 g path 上封装的方法\n\n\n  if (percent < TAN_OFFSET) {\n    vector = pathShape.getStartTangent().reverse();\n  } else if (percent > 1 - TAN_OFFSET) {\n    vector = pathShape.getEndTangent();\n  } else {\n    // 否则取指定位置的点,与少量偏移的点，做微分向量\n    var offsetPoint = pathShape.getPoint(percent + TAN_OFFSET);\n    vector.push([point.x, point.y]);\n    vector.push([offsetPoint.x, offsetPoint.y]);\n  }\n\n  var rad = Math.atan2(vector[1][1] - vector[0][1], vector[1][0] - vector[0][0]);\n\n  if (rad < 0) {\n    rad += PI * 2;\n  }\n\n  if (refX) {\n    point.x += cos(rad) * refX;\n    point.y += sin(rad) * refX;\n  }\n\n  if (refY) {\n    // 默认方向是 x 轴正方向，法线是 求出角度 - 90°\n    var normal = rad - PI / 2; // 若法线角度在 y 轴负方向，切到正方向，保证 refY 相对于 y 轴正方向\n\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      normal -= PI;\n    }\n\n    point.x += cos(normal) * refY;\n    point.y += sin(normal) * refY;\n  }\n\n  var result = {\n    x: point.x,\n    y: point.y,\n    angle: rad\n  };\n\n  if (rotate) {\n    if (rad > 1 / 2 * PI && rad < 3 * 1 / 2 * PI) {\n      rad -= PI;\n    }\n\n    return __assign({\n      rotate: rad\n    }, result);\n  }\n\n  return result;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\nvar traverse = function traverse(data, fn) {\n  if (fn(data) === false) {\n    return false;\n  }\n\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverse(data.children[i], fn)) return false;\n    }\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nvar traverseUp = function traverseUp(data, fn) {\n  if (data && data.children) {\n    for (var i = data.children.length - 1; i >= 0; i--) {\n      if (!traverseUp(data.children[i], fn)) return;\n    }\n  }\n\n  if (fn(data) === false) {\n    return false;\n  }\n\n  return true;\n};\n/**\n * depth first traverse, from root to leaves, children in inverse order\n *  if the fn returns false, terminate the traverse\n */\n\n\nexport var traverseTree = function traverseTree(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverse(data, fn);\n};\n/**\n * depth first traverse, from leaves to root, children in inverse order\n * if the fn returns false, terminate the traverse\n */\n\nexport var traverseTreeUp = function traverseTreeUp(data, fn) {\n  if (typeof fn !== 'function') {\n    return;\n  }\n\n  traverseUp(data, fn);\n};\n/**\n *\n * @param data Tree graph data\n * @param layout\n */\n\nexport var radialLayout = function radialLayout(data, layout) {\n  // 布局方式有 H / V / LR / RL / TB / BT\n  var VERTICAL_LAYOUTS = ['V', 'TB', 'BT'];\n  var min = {\n    x: Infinity,\n    y: Infinity\n  };\n  var max = {\n    x: -Infinity,\n    y: -Infinity\n  }; // 默认布局是垂直布局TB，此时x对应rad，y对应r\n\n  var rScale = 'x';\n  var radScale = 'y';\n\n  if (layout && VERTICAL_LAYOUTS.indexOf(layout) >= 0) {\n    // 若是水平布局，y对应rad，x对应r\n    radScale = 'x';\n    rScale = 'y';\n  }\n\n  var count = 0;\n  traverseTree(data, function (node) {\n    count++;\n\n    if (node.x > max.x) {\n      max.x = node.x;\n    }\n\n    if (node.x < min.x) {\n      min.x = node.x;\n    }\n\n    if (node.y > max.y) {\n      max.y = node.y;\n    }\n\n    if (node.y < min.y) {\n      min.y = node.y;\n    }\n\n    return true;\n  });\n  var avgRad = PI * 2 / count;\n  var radDiff = max[radScale] - min[radScale];\n\n  if (radDiff === 0) {\n    return data;\n  }\n\n  traverseTree(data, function (node) {\n    var radial = (node[radScale] - min[radScale]) / radDiff * (PI * 2 - avgRad) + avgRad;\n    var r = Math.abs(rScale === 'x' ? node.x - data.x : node.y - data.y);\n    node.x = r * Math.cos(radial);\n    node.y = r * Math.sin(radial);\n    return true;\n  });\n  return data;\n};\n/**\n *\n * @param letter the letter\n * @param fontSize\n * @return the letter's width\n */\n\nexport var getLetterWidth = function getLetterWidth(letter, fontSize) {\n  return fontSize * (letterAspectRatio[letter] || 1);\n};\n/**\n *\n * @param text the text\n * @param fontSize\n * @return the text's size\n */\n\nexport var getTextSize = function getTextSize(text, fontSize) {\n  var width = 0;\n  var pattern = new RegExp(\"[\\u4E00-\\u9FA5]+\");\n  text.split('').forEach(function (letter) {\n    if (pattern.test(letter)) {\n      // 中文字符\n      width += fontSize;\n    } else {\n      width += getLetterWidth(letter, fontSize);\n    }\n  });\n  return [width, fontSize];\n};\n/**\n * construct the trees from combos data\n * @param array the combos array\n * @param nodes the nodes array\n * @return the tree\n */\n\nexport var plainCombosToTrees = function plainCombosToTrees(array, nodes) {\n  var result = [];\n  var addedMap = {};\n  var modelMap = {};\n  array.forEach(function (d) {\n    modelMap[d.id] = d;\n  });\n  array.forEach(function (d, i) {\n    var cd = clone(d);\n    cd.itemType = 'combo';\n    cd.children = undefined;\n\n    if (cd.parentId === cd.id) {\n      console.warn(\"The parentId for combo \" + cd.id + \" can not be the same as the combo's id\");\n      delete cd.parentId;\n    } else if (cd.parentId && !modelMap[cd.parentId]) {\n      console.warn(\"The parent combo for combo \" + cd.id + \" does not exist!\");\n      delete cd.parentId;\n    }\n\n    var mappedObj = addedMap[cd.id];\n\n    if (mappedObj) {\n      cd.children = mappedObj.children;\n      addedMap[cd.id] = cd;\n      mappedObj = cd;\n\n      if (!mappedObj.parentId) {\n        result.push(mappedObj);\n        return;\n      }\n\n      var mappedParent = addedMap[mappedObj.parentId];\n\n      if (mappedParent) {\n        if (mappedParent.children) mappedParent.children.push(cd);else mappedParent.children = [cd];\n      } else {\n        var parent_1 = {\n          id: mappedObj.parentId,\n          children: [mappedObj]\n        };\n        addedMap[mappedObj.parentId] = parent_1;\n        addedMap[cd.id] = cd;\n      }\n\n      return;\n    }\n\n    if (isString(d.parentId)) {\n      var parent_2 = addedMap[d.parentId];\n\n      if (parent_2) {\n        if (parent_2.children) parent_2.children.push(cd);else parent_2.children = [cd];\n        addedMap[cd.id] = cd;\n      } else {\n        var pa = {\n          id: d.parentId,\n          children: [cd]\n        };\n        addedMap[pa.id] = pa;\n        addedMap[cd.id] = cd;\n      }\n    } else {\n      result.push(cd);\n      addedMap[cd.id] = cd;\n    }\n  }); // proccess the nodes\n\n  var nodeMap = {};\n  (nodes || []).forEach(function (node) {\n    nodeMap[node.id] = node;\n    var combo = addedMap[node.comboId];\n\n    if (combo) {\n      var cnode = {\n        id: node.id,\n        comboId: node.comboId\n      };\n      if (combo.children) combo.children.push(cnode);else combo.children = [cnode];\n      cnode.itemType = 'node';\n      addedMap[node.id] = cnode;\n    }\n  }); // assign the depth for each element\n\n  result.forEach(function (tree) {\n    tree.depth = 0;\n    traverse(tree, function (child) {\n      var parent;\n      var itemType = addedMap[child.id].itemType;\n\n      if (itemType === 'node') {\n        parent = addedMap[child.comboId];\n      } else {\n        parent = addedMap[child.parentId];\n      }\n\n      if (parent) {\n        if (itemType === 'node') child.depth = parent.depth + 1;else child.depth = parent.depth + 2;\n      } else {\n        child.depth = 0;\n      }\n\n      var oriNodeModel = nodeMap[child.id];\n\n      if (oriNodeModel) {\n        oriNodeModel.depth = child.depth;\n      }\n\n      return true;\n    });\n  });\n  return result;\n};\nexport var reconstructTree = function reconstructTree(trees, subtreeId, newParentId) {\n  var brothers = trees;\n  var subtree;\n  var comboChildsMap = {\n    root: {\n      children: trees\n    }\n  };\n  var foundSubTree = false;\n  var oldParentId = 'root';\n  (trees || []).forEach(function (tree) {\n    if (foundSubTree) return;\n\n    if (tree.id === subtreeId) {\n      subtree = tree;\n\n      if (tree.itemType === 'combo') {\n        subtree.parentId = newParentId;\n      } else {\n        subtree.comboId = newParentId;\n      }\n\n      foundSubTree = true;\n      return;\n    }\n\n    traverseTree(tree, function (child) {\n      comboChildsMap[child.id] = {\n        children: child.children\n      }; // store the old parent id to delete the subtree from the old parent's children in next recursion\n\n      brothers = comboChildsMap[child.parentId || child.comboId || 'root'].children;\n\n      if (child && (child.removed || subtreeId === child.id) && brothers) {\n        oldParentId = child.parentId || child.comboId || 'root';\n        subtree = child; // re-assign the parentId or comboId for the moved subtree\n\n        if (child.itemType === 'combo') {\n          subtree.parentId = newParentId;\n        } else {\n          subtree.comboId = newParentId;\n        }\n\n        foundSubTree = true;\n        return false;\n      }\n\n      return true;\n    });\n  });\n  brothers = comboChildsMap[oldParentId].children;\n  var index = brothers ? brothers.indexOf(subtree) : -1;\n  if (index > -1) brothers.splice(index, 1); // 如果遍历完整棵树还没有找到，说明之前就不在树中\n\n  if (!foundSubTree) {\n    subtree = {\n      id: subtreeId,\n      itemType: 'node',\n      comboId: newParentId\n    };\n    comboChildsMap[subtreeId] = {\n      children: undefined\n    };\n  } // append to new parent\n\n\n  if (subtreeId) {\n    var found_1 = false; // newParentId is undefined means the subtree will have no parent\n\n    if (newParentId) {\n      var newParentDepth_1 = 0;\n      (trees || []).forEach(function (tree) {\n        if (found_1) return; // terminate\n\n        traverseTree(tree, function (child) {\n          // append subtree to the new parent ans assign the depth to the subtree\n          if (newParentId === child.id) {\n            found_1 = true;\n            if (child.children) child.children.push(subtree);else child.children = [subtree];\n            newParentDepth_1 = child.depth;\n            if (subtree.itemType === 'node') subtree.depth = newParentDepth_1 + 2;else subtree.depth = newParentDepth_1 + 1;\n            return false; // terminate\n          }\n\n          return true;\n        });\n      });\n    } else if ((!newParentId || !found_1) && subtree.itemType !== 'node') {\n      // if the newParentId is undefined or it is not found in the tree, add the subTree to the root\n      trees.push(subtree);\n    } // update the depth of the subtree and its children from the subtree\n\n\n    var currentDepth_1 = subtree.depth;\n    traverseTree(subtree, function (child) {\n      if (child.itemType === 'node') currentDepth_1 += 2;else currentDepth_1 += 1;\n      child.depth = currentDepth_1;\n      return true;\n    });\n  }\n\n  return trees;\n};\nexport var getComboBBox = function getComboBBox(children, graph) {\n  var comboBBox = {\n    minX: Infinity,\n    minY: Infinity,\n    maxX: -Infinity,\n    maxY: -Infinity,\n    x: undefined,\n    y: undefined,\n    width: undefined,\n    height: undefined,\n    centerX: undefined,\n    centerY: undefined\n  };\n\n  if (!children || children.length === 0) {\n    return comboBBox;\n  }\n\n  children.forEach(function (child) {\n    var childItem = graph.findById(child.id);\n    if (!childItem || !childItem.isVisible()) return; // ignore hidden children\n\n    childItem.set('bboxCanvasCache', undefined);\n    var childBBox = childItem.getCanvasBBox();\n    if (childBBox.x && comboBBox.minX > childBBox.minX) comboBBox.minX = childBBox.minX;\n    if (childBBox.y && comboBBox.minY > childBBox.minY) comboBBox.minY = childBBox.minY;\n    if (childBBox.x && comboBBox.maxX < childBBox.maxX) comboBBox.maxX = childBBox.maxX;\n    if (childBBox.y && comboBBox.maxY < childBBox.maxY) comboBBox.maxY = childBBox.maxY;\n  });\n  comboBBox.x = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.y = (comboBBox.minY + comboBBox.maxY) / 2;\n  comboBBox.width = comboBBox.maxX - comboBBox.minX;\n  comboBBox.height = comboBBox.maxY - comboBBox.minY;\n  comboBBox.centerX = (comboBBox.minX + comboBBox.maxX) / 2;\n  comboBBox.centerY = (comboBBox.minY + comboBBox.maxY) / 2;\n  Object.keys(comboBBox).forEach(function (key) {\n    if (comboBBox[key] === Infinity || comboBBox[key] === -Infinity) {\n      comboBBox[key] = undefined;\n    }\n  });\n  return comboBBox;\n};\nexport var getChartRegion = function getChartRegion(params) {\n  var group = params.group,\n      height = params.height,\n      width = params.width,\n      x = params.x,\n      y = params.y;\n  var canvas = group.get('canvas');\n  var canvasWidth = canvas.get('width');\n  var canvasHeight = canvas.get('height');\n  var region = {\n    start: {\n      x: 0,\n      y: 0\n    },\n    end: {\n      x: 0,\n      y: 0\n    }\n  };\n  region.start.x = x / canvasWidth;\n  region.start.y = y / canvasHeight;\n  region.end.x = (x + width) / canvasWidth;\n  region.end.y = (y + height) / canvasHeight;\n  return region;\n};"]},"metadata":{},"sourceType":"module"}