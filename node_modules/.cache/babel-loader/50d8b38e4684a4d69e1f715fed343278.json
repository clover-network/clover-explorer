{"ast":null,"code":"/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from '../util/math';\nimport { BaseLayout } from './layout';\n/**\n * mds 布局\n */\n\nvar MDSLayout =\n/** @class */\nfunction (_super) {\n  __extends(MDSLayout, _super);\n\n  function MDSLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 边长度 */\n\n    _this.linkDistance = 50;\n    _this.scaledDistances = null;\n    return _this;\n  }\n\n  MDSLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      linkDistance: 50\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  MDSLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes,\n        _a = self.edges,\n        edges = _a === void 0 ? [] : _a;\n    var center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var linkDistance = self.linkDistance; // the graph-theoretic distance (shortest path distance) matrix\n\n    var adjMatrix = getAdjMatrix({\n      nodes: nodes,\n      edges: edges\n    }, false);\n    var distances = floydWarshall(adjMatrix);\n    self.handleInfinity(distances); // scale the ideal edge length acoording to linkDistance\n\n    var scaledD = scaleMatrix(distances, linkDistance);\n    self.scaledDistances = scaledD; // get positions by MDS\n\n    var positions = self.runMDS();\n    self.positions = positions;\n    positions.forEach(function (p, i) {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n  };\n  /**\n   * mds 算法\n   * @return {array} positions 计算后的节点位置数组\n   */\n\n\n  MDSLayout.prototype.runMDS = function () {\n    var self = this;\n    var dimension = 2;\n    var distances = self.scaledDistances; // square distances\n\n    var M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n    var rowMeans = M.mean('row');\n    var colMeans = M.mean('column');\n    var totalMean = M.mean();\n    M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n    // points from it\n\n    var ret = new SingularValueDecomposition(M);\n    var eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n    return ret.leftSingularVectors.toJSON().map(function (row) {\n      return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n    });\n  };\n\n  MDSLayout.prototype.handleInfinity = function (distances) {\n    var maxDistance = -999999;\n    distances.forEach(function (row) {\n      row.forEach(function (value) {\n        if (value === Infinity) {\n          return;\n        }\n\n        if (maxDistance < value) {\n          maxDistance = value;\n        }\n      });\n    });\n    distances.forEach(function (row, i) {\n      row.forEach(function (value, j) {\n        if (value === Infinity) {\n          distances[i][j] = maxDistance;\n        }\n      });\n    });\n  };\n\n  return MDSLayout;\n}(BaseLayout);\n\nexport default MDSLayout;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/mds.js"],"names":["__extends","Matrix","MLMatrix","SingularValueDecomposition","floydWarshall","getAdjMatrix","scaleMatrix","BaseLayout","MDSLayout","_super","_this","apply","arguments","center","linkDistance","scaledDistances","prototype","getDefaultCfg","execute","self","nodes","_a","edges","length","x","y","adjMatrix","distances","handleInfinity","scaledD","positions","runMDS","forEach","p","i","dimension","M","mul","pow","rowMeans","mean","colMeans","totalMean","add","subRowVector","subColumnVector","ret","eigenValues","sqrt","diagonalMatrix","diagonal","leftSingularVectors","toJSON","map","row","splice","maxDistance","value","Infinity","j"],"mappings":"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","sourcesContent":["/**\n * @fileOverview MDS layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\nimport { floydWarshall, getAdjMatrix, scaleMatrix } from '../util/math';\nimport { BaseLayout } from './layout';\n/**\n * mds 布局\n */\n\nvar MDSLayout =\n/** @class */\nfunction (_super) {\n  __extends(MDSLayout, _super);\n\n  function MDSLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 边长度 */\n\n    _this.linkDistance = 50;\n    _this.scaledDistances = null;\n    return _this;\n  }\n\n  MDSLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      linkDistance: 50\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  MDSLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes,\n        _a = self.edges,\n        edges = _a === void 0 ? [] : _a;\n    var center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var linkDistance = self.linkDistance; // the graph-theoretic distance (shortest path distance) matrix\n\n    var adjMatrix = getAdjMatrix({\n      nodes: nodes,\n      edges: edges\n    }, false);\n    var distances = floydWarshall(adjMatrix);\n    self.handleInfinity(distances); // scale the ideal edge length acoording to linkDistance\n\n    var scaledD = scaleMatrix(distances, linkDistance);\n    self.scaledDistances = scaledD; // get positions by MDS\n\n    var positions = self.runMDS();\n    self.positions = positions;\n    positions.forEach(function (p, i) {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n  };\n  /**\n   * mds 算法\n   * @return {array} positions 计算后的节点位置数组\n   */\n\n\n  MDSLayout.prototype.runMDS = function () {\n    var self = this;\n    var dimension = 2;\n    var distances = self.scaledDistances; // square distances\n\n    var M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n    var rowMeans = M.mean('row');\n    var colMeans = M.mean('column');\n    var totalMean = M.mean();\n    M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n    // points from it\n\n    var ret = new SingularValueDecomposition(M);\n    var eigenValues = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n    return ret.leftSingularVectors.toJSON().map(function (row) {\n      return MLMatrix.mul([row], [eigenValues]).toJSON()[0].splice(0, dimension);\n    });\n  };\n\n  MDSLayout.prototype.handleInfinity = function (distances) {\n    var maxDistance = -999999;\n    distances.forEach(function (row) {\n      row.forEach(function (value) {\n        if (value === Infinity) {\n          return;\n        }\n\n        if (maxDistance < value) {\n          maxDistance = value;\n        }\n      });\n    });\n    distances.forEach(function (row, i) {\n      row.forEach(function (value, j) {\n        if (value === Infinity) {\n          distances[i][j] = maxDistance;\n        }\n      });\n    });\n  };\n\n  return MDSLayout;\n}(BaseLayout);\n\nexport default MDSLayout;"]},"metadata":{},"sourceType":"module"}