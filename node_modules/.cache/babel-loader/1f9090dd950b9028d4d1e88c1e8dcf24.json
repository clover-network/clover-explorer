{"ast":null,"code":"import { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\n\nvar MDS =\n/** @class */\nfunction () {\n  function MDS(params) {\n    this.distances = params.distances;\n    this.dimension = params.dimension || 2;\n    this.linkDistance = params.linkDistance;\n  }\n\n  MDS.prototype.layout = function () {\n    var self = this;\n    var dimension = self.dimension,\n        distances = self.distances,\n        linkDistance = self.linkDistance;\n\n    try {\n      // square distances\n      var M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n      var rowMeans = M.mean('row');\n      var colMeans = M.mean('column');\n      var totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n      // points from it\n\n      var ret = new SingularValueDecomposition(M);\n      var eigenValues_1 = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map(function (row) {\n        return MLMatrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);\n      });\n    } catch (_a) {\n      var res = [];\n\n      for (var i = 0; i < distances.length; i++) {\n        var x = Math.random() * linkDistance;\n        var y = Math.random() * linkDistance;\n        res.push([x, y]);\n      }\n\n      return res;\n    }\n  };\n\n  return MDS;\n}();\n\nexport default MDS;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/radial/mds.js"],"names":["Matrix","MLMatrix","SingularValueDecomposition","MDS","params","distances","dimension","linkDistance","prototype","layout","self","M","mul","pow","rowMeans","mean","colMeans","totalMean","add","subRowVector","subColumnVector","ret","eigenValues_1","sqrt","diagonalMatrix","diagonal","leftSingularVectors","toJSON","map","row","splice","_a","res","i","length","x","Math","random","y","push"],"mappings":"AAAA,SAASA,MAAM,IAAIC,QAAnB,EAA6BC,0BAA7B,QAA+D,WAA/D;;AAEA,IAAIC,GAAG;AACP;AACA,YAAY;AACV,WAASA,GAAT,CAAaC,MAAb,EAAqB;AACnB,SAAKC,SAAL,GAAiBD,MAAM,CAACC,SAAxB;AACA,SAAKC,SAAL,GAAiBF,MAAM,CAACE,SAAP,IAAoB,CAArC;AACA,SAAKC,YAAL,GAAoBH,MAAM,CAACG,YAA3B;AACD;;AAEDJ,EAAAA,GAAG,CAACK,SAAJ,CAAcC,MAAd,GAAuB,YAAY;AACjC,QAAIC,IAAI,GAAG,IAAX;AACA,QAAIJ,SAAS,GAAGI,IAAI,CAACJ,SAArB;AAAA,QACID,SAAS,GAAGK,IAAI,CAACL,SADrB;AAAA,QAEIE,YAAY,GAAGG,IAAI,CAACH,YAFxB;;AAIA,QAAI;AACF;AACA,UAAII,CAAC,GAAGV,QAAQ,CAACW,GAAT,CAAaX,QAAQ,CAACY,GAAT,CAAaR,SAAb,EAAwB,CAAxB,CAAb,EAAyC,CAAC,GAA1C,CAAR,CAFE,CAEsD;;AAExD,UAAIS,QAAQ,GAAGH,CAAC,CAACI,IAAF,CAAO,KAAP,CAAf;AACA,UAAIC,QAAQ,GAAGL,CAAC,CAACI,IAAF,CAAO,QAAP,CAAf;AACA,UAAIE,SAAS,GAAGN,CAAC,CAACI,IAAF,EAAhB;AACAJ,MAAAA,CAAC,CAACO,GAAF,CAAMD,SAAN,EAAiBE,YAAjB,CAA8BL,QAA9B,EAAwCM,eAAxC,CAAwDJ,QAAxD,EAPE,CAOiE;AACnE;;AAEA,UAAIK,GAAG,GAAG,IAAInB,0BAAJ,CAA+BS,CAA/B,CAAV;AACA,UAAIW,aAAa,GAAGrB,QAAQ,CAACsB,IAAT,CAAcF,GAAG,CAACG,cAAlB,EAAkCC,QAAlC,EAApB;AACA,aAAOJ,GAAG,CAACK,mBAAJ,CAAwBC,MAAxB,GAAiCC,GAAjC,CAAqC,UAAUC,GAAV,EAAe;AACzD,eAAO5B,QAAQ,CAACW,GAAT,CAAa,CAACiB,GAAD,CAAb,EAAoB,CAACP,aAAD,CAApB,EAAqCK,MAArC,GAA8C,CAA9C,EAAiDG,MAAjD,CAAwD,CAAxD,EAA2DxB,SAA3D,CAAP;AACD,OAFM,CAAP;AAGD,KAfD,CAeE,OAAOyB,EAAP,EAAW;AACX,UAAIC,GAAG,GAAG,EAAV;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,SAAS,CAAC6B,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,YAAIE,CAAC,GAAGC,IAAI,CAACC,MAAL,KAAgB9B,YAAxB;AACA,YAAI+B,CAAC,GAAGF,IAAI,CAACC,MAAL,KAAgB9B,YAAxB;AACAyB,QAAAA,GAAG,CAACO,IAAJ,CAAS,CAACJ,CAAD,EAAIG,CAAJ,CAAT;AACD;;AAED,aAAON,GAAP;AACD;AACF,GAhCD;;AAkCA,SAAO7B,GAAP;AACD,CA1CD,EAFA;;AA8CA,eAAeA,GAAf","sourcesContent":["import { Matrix as MLMatrix, SingularValueDecomposition } from 'ml-matrix';\n\nvar MDS =\n/** @class */\nfunction () {\n  function MDS(params) {\n    this.distances = params.distances;\n    this.dimension = params.dimension || 2;\n    this.linkDistance = params.linkDistance;\n  }\n\n  MDS.prototype.layout = function () {\n    var self = this;\n    var dimension = self.dimension,\n        distances = self.distances,\n        linkDistance = self.linkDistance;\n\n    try {\n      // square distances\n      var M = MLMatrix.mul(MLMatrix.pow(distances, 2), -0.5); // double centre the rows/columns\n\n      var rowMeans = M.mean('row');\n      var colMeans = M.mean('column');\n      var totalMean = M.mean();\n      M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans); // take the SVD of the double centred matrix, and return the\n      // points from it\n\n      var ret = new SingularValueDecomposition(M);\n      var eigenValues_1 = MLMatrix.sqrt(ret.diagonalMatrix).diagonal();\n      return ret.leftSingularVectors.toJSON().map(function (row) {\n        return MLMatrix.mul([row], [eigenValues_1]).toJSON()[0].splice(0, dimension);\n      });\n    } catch (_a) {\n      var res = [];\n\n      for (var i = 0; i < distances.length; i++) {\n        var x = Math.random() * linkDistance;\n        var y = Math.random() * linkDistance;\n        res.push([x, y]);\n      }\n\n      return res;\n    }\n  };\n\n  return MDS;\n}();\n\nexport default MDS;"]},"metadata":{},"sourceType":"module"}