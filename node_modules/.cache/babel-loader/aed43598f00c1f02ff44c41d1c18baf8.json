{"ast":null,"code":"import Group from '../graphic/Group';\nimport ZRImage from '../graphic/Image';\nimport Circle from '../graphic/shape/Circle';\nimport Rect from '../graphic/shape/Rect';\nimport Ellipse from '../graphic/shape/Ellipse';\nimport Line from '../graphic/shape/Line';\nimport Path from '../graphic/Path';\nimport Polygon from '../graphic/shape/Polygon';\nimport Polyline from '../graphic/shape/Polyline';\nimport * as matrix from '../core/matrix';\nimport { createFromString } from './path';\nimport { isString, extend, defaults, trim, each, map } from '../core/util';\nimport LinearGradient from '../graphic/LinearGradient';\nimport TSpan from '../graphic/TSpan';\nvar DILIMITER_REG = /[\\s,]+/;\nexport function parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  }\n\n  var svgNode = svg;\n\n  if (svgNode.nodeType === 9) {\n    svgNode = svgNode.firstChild;\n  }\n\n  while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n    svgNode = svgNode.nextSibling;\n  }\n\n  return svgNode;\n}\nvar nodeParsers;\n\nvar SVGParser = function () {\n  function SVGParser() {\n    this._defs = {};\n    this._root = null;\n    this._isDefine = false;\n    this._isText = false;\n  }\n\n  SVGParser.prototype.parse = function (xml, opt) {\n    opt = opt || {};\n    var svg = parseXML(xml);\n\n    if (!svg) {\n      throw new Error('Illegal svg');\n    }\n\n    var root = new Group();\n    this._root = root;\n    var viewBox = svg.getAttribute('viewBox') || '';\n    var width = parseFloat(svg.getAttribute('width') || opt.width);\n    var height = parseFloat(svg.getAttribute('height') || opt.height);\n    isNaN(width) && (width = null);\n    isNaN(height) && (height = null);\n    parseAttributes(svg, root, null, true);\n    var child = svg.firstChild;\n\n    while (child) {\n      this._parseNode(child, root);\n\n      child = child.nextSibling;\n    }\n\n    var viewBoxRect;\n    var viewBoxTransform;\n\n    if (viewBox) {\n      var viewBoxArr = trim(viewBox).split(DILIMITER_REG);\n\n      if (viewBoxArr.length >= 4) {\n        viewBoxRect = {\n          x: parseFloat(viewBoxArr[0] || 0),\n          y: parseFloat(viewBoxArr[1] || 0),\n          width: parseFloat(viewBoxArr[2]),\n          height: parseFloat(viewBoxArr[3])\n        };\n      }\n    }\n\n    if (viewBoxRect && width != null && height != null) {\n      viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n      if (!opt.ignoreViewBox) {\n        var elRoot = root;\n        root = new Group();\n        root.add(elRoot);\n        elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n        elRoot.x = viewBoxTransform.x;\n        elRoot.y = viewBoxTransform.y;\n      }\n    }\n\n    if (!opt.ignoreRootClip && width != null && height != null) {\n      root.setClipPath(new Rect({\n        shape: {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        }\n      }));\n    }\n\n    return {\n      root: root,\n      width: width,\n      height: height,\n      viewBoxRect: viewBoxRect,\n      viewBoxTransform: viewBoxTransform\n    };\n  };\n\n  SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n    var nodeName = xmlNode.nodeName.toLowerCase();\n\n    if (nodeName === 'defs') {\n      this._isDefine = true;\n    } else if (nodeName === 'text') {\n      this._isText = true;\n    }\n\n    var el;\n\n    if (this._isDefine) {\n      var parser = defineParsers[nodeName];\n\n      if (parser) {\n        var def = parser.call(this, xmlNode);\n        var id = xmlNode.getAttribute('id');\n\n        if (id) {\n          this._defs[id] = def;\n        }\n      }\n    } else {\n      var parser = nodeParsers[nodeName];\n\n      if (parser) {\n        el = parser.call(this, xmlNode, parentGroup);\n        parentGroup.add(el);\n      }\n    }\n\n    if (el) {\n      var child = xmlNode.firstChild;\n\n      while (child) {\n        if (child.nodeType === 1) {\n          this._parseNode(child, el);\n        }\n\n        if (child.nodeType === 3 && this._isText) {\n          this._parseText(child, el);\n        }\n\n        child = child.nextSibling;\n      }\n    }\n\n    if (nodeName === 'defs') {\n      this._isDefine = false;\n    } else if (nodeName === 'text') {\n      this._isText = false;\n    }\n  };\n\n  SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n    if (xmlNode.nodeType === 1) {\n      var dx = xmlNode.getAttribute('dx') || 0;\n      var dy = xmlNode.getAttribute('dy') || 0;\n      this._textX += parseFloat(dx);\n      this._textY += parseFloat(dy);\n    }\n\n    var text = new TSpan({\n      style: {\n        text: xmlNode.textContent\n      },\n      x: this._textX || 0,\n      y: this._textY || 0\n    });\n    inheritStyle(parentGroup, text);\n    parseAttributes(xmlNode, text, this._defs);\n    var textStyle = text.style;\n    var fontSize = textStyle.fontSize;\n\n    if (fontSize && fontSize < 9) {\n      textStyle.fontSize = 9;\n      text.scaleX *= fontSize / 9;\n      text.scaleY *= fontSize / 9;\n    }\n\n    var font = (textStyle.fontSize || textStyle.fontFamily) && [textStyle.fontStyle, textStyle.fontWeight, (textStyle.fontSize || 12) + 'px', textStyle.fontFamily || 'sans-serif'].join(' ');\n    textStyle.font = font;\n    var rect = text.getBoundingRect();\n    this._textX += rect.width;\n    parentGroup.add(text);\n    return text;\n  };\n\n  SVGParser.internalField = function () {\n    nodeParsers = {\n      'g': function (xmlNode, parentGroup) {\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'rect': function (xmlNode, parentGroup) {\n        var rect = new Rect();\n        inheritStyle(parentGroup, rect);\n        parseAttributes(xmlNode, rect, this._defs);\n        rect.setShape({\n          x: parseFloat(xmlNode.getAttribute('x') || '0'),\n          y: parseFloat(xmlNode.getAttribute('y') || '0'),\n          width: parseFloat(xmlNode.getAttribute('width') || '0'),\n          height: parseFloat(xmlNode.getAttribute('height') || '0')\n        });\n        return rect;\n      },\n      'circle': function (xmlNode, parentGroup) {\n        var circle = new Circle();\n        inheritStyle(parentGroup, circle);\n        parseAttributes(xmlNode, circle, this._defs);\n        circle.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          r: parseFloat(xmlNode.getAttribute('r') || '0')\n        });\n        return circle;\n      },\n      'line': function (xmlNode, parentGroup) {\n        var line = new Line();\n        inheritStyle(parentGroup, line);\n        parseAttributes(xmlNode, line, this._defs);\n        line.setShape({\n          x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n          y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n          x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n          y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n        });\n        return line;\n      },\n      'ellipse': function (xmlNode, parentGroup) {\n        var ellipse = new Ellipse();\n        inheritStyle(parentGroup, ellipse);\n        parseAttributes(xmlNode, ellipse, this._defs);\n        ellipse.setShape({\n          cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n          cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n          rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n          ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n        });\n        return ellipse;\n      },\n      'polygon': function (xmlNode, parentGroup) {\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polygon = new Polygon({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        inheritStyle(parentGroup, polygon);\n        parseAttributes(xmlNode, polygon, this._defs);\n        return polygon;\n      },\n      'polyline': function (xmlNode, parentGroup) {\n        var path = new Path();\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        var pointsStr = xmlNode.getAttribute('points');\n        var pointsArr;\n\n        if (pointsStr) {\n          pointsArr = parsePoints(pointsStr);\n        }\n\n        var polyline = new Polyline({\n          shape: {\n            points: pointsArr || []\n          }\n        });\n        return polyline;\n      },\n      'image': function (xmlNode, parentGroup) {\n        var img = new ZRImage();\n        inheritStyle(parentGroup, img);\n        parseAttributes(xmlNode, img, this._defs);\n        img.setStyle({\n          image: xmlNode.getAttribute('xlink:href'),\n          x: +xmlNode.getAttribute('x'),\n          y: +xmlNode.getAttribute('y'),\n          width: +xmlNode.getAttribute('width'),\n          height: +xmlNode.getAttribute('height')\n        });\n        return img;\n      },\n      'text': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x') || '0';\n        var y = xmlNode.getAttribute('y') || '0';\n        var dx = xmlNode.getAttribute('dx') || '0';\n        var dy = xmlNode.getAttribute('dy') || '0';\n        this._textX = parseFloat(x) + parseFloat(dx);\n        this._textY = parseFloat(y) + parseFloat(dy);\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        return g;\n      },\n      'tspan': function (xmlNode, parentGroup) {\n        var x = xmlNode.getAttribute('x');\n        var y = xmlNode.getAttribute('y');\n\n        if (x != null) {\n          this._textX = parseFloat(x);\n        }\n\n        if (y != null) {\n          this._textY = parseFloat(y);\n        }\n\n        var dx = xmlNode.getAttribute('dx') || 0;\n        var dy = xmlNode.getAttribute('dy') || 0;\n        var g = new Group();\n        inheritStyle(parentGroup, g);\n        parseAttributes(xmlNode, g, this._defs);\n        this._textX += dx;\n        this._textY += dy;\n        return g;\n      },\n      'path': function (xmlNode, parentGroup) {\n        var d = xmlNode.getAttribute('d') || '';\n        var path = createFromString(d);\n        inheritStyle(parentGroup, path);\n        parseAttributes(xmlNode, path, this._defs);\n        return path;\n      }\n    };\n  }();\n\n  return SVGParser;\n}();\n\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  }\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offsetStr = stop.getAttribute('offset');\n      var offset = void 0;\n\n      if (offsetStr.indexOf('%') > 0) {\n        offset = parseInt(offsetStr, 10) / 100;\n      } else if (offsetStr) {\n        offset = parseFloat(offsetStr);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.colorStops.push({\n        offset: offset,\n        color: stopColor\n      });\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var disp = el;\n  var zrStyle = disp.__inheritedStyle || {};\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  disp.style = disp.style || {};\n  zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    disp.style.lineDash = map(trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n      return parseFloat(str);\n    });\n  }\n\n  disp.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var transformOps_1 = [];\n    var m = null;\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps_1.push(type, value);\n      return '';\n    });\n\n    for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n      var value = transformOps_1[i];\n      var type = transformOps_1[i - 1];\n      var valueArr = void 0;\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n          break;\n\n        case 'scale':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n          break;\n\n        case 'rotate':\n          valueArr = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(valueArr[0]));\n          break;\n\n        case 'skew':\n          valueArr = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          valueArr = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(valueArr[0]);\n          m[1] = parseFloat(valueArr[1]);\n          m[2] = parseFloat(valueArr[2]);\n          m[3] = parseFloat(valueArr[3]);\n          m[4] = parseFloat(valueArr[4]);\n          m[5] = parseFloat(valueArr[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n}\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n\nexport function makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY);\n  return {\n    scale: scale,\n    x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n    y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n  };\n}\nexport function parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/zrender/esm/tool/parseSVG.js"],"names":["Group","ZRImage","Circle","Rect","Ellipse","Line","Path","Polygon","Polyline","matrix","createFromString","isString","extend","defaults","trim","each","map","LinearGradient","TSpan","DILIMITER_REG","parseXML","svg","parser","DOMParser","parseFromString","svgNode","nodeType","firstChild","nodeName","toLowerCase","nextSibling","nodeParsers","SVGParser","_defs","_root","_isDefine","_isText","prototype","parse","xml","opt","Error","root","viewBox","getAttribute","width","parseFloat","height","isNaN","parseAttributes","child","_parseNode","viewBoxRect","viewBoxTransform","viewBoxArr","split","length","x","y","makeViewBoxTransform","ignoreViewBox","elRoot","add","scaleX","scaleY","scale","ignoreRootClip","setClipPath","shape","xmlNode","parentGroup","el","defineParsers","def","call","id","_parseText","dx","dy","_textX","_textY","text","style","textContent","inheritStyle","textStyle","fontSize","font","fontFamily","fontStyle","fontWeight","join","rect","getBoundingRect","internalField","g","setShape","circle","cx","cy","r","line","x1","y1","x2","y2","ellipse","rx","ry","pointsStr","pointsArr","parsePoints","polygon","points","path","polyline","img","setStyle","image","d","parseInt","gradient","_parseGradientColorStops","stop","offsetStr","offset","indexOf","stopColor","colorStops","push","color","parent","__inheritedStyle","pointsString","list","i","attributesMap","defs","onlyInlineStyle","disp","zrStyle","parseTransformAttribute","parseStyleAttribute","svgAttrName","hasOwnProperty","attrValue","fill","getPaint","stroke","propName","textBaseline","textAlign","lineDash","str","urlRegex","urlMatch","match","url","transformRegex","node","transform","replace","transformOps_1","m","type","value","valueArr","create","translate","rotate","console","warn","setLocalTransform","styleRegex","result","styleList","lastIndex","styleRegResult","exec","Math","min","parseSVG"],"mappings":"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","sourcesContent":["import Group from '../graphic/Group';\nimport ZRImage from '../graphic/Image';\nimport Circle from '../graphic/shape/Circle';\nimport Rect from '../graphic/shape/Rect';\nimport Ellipse from '../graphic/shape/Ellipse';\nimport Line from '../graphic/shape/Line';\nimport Path from '../graphic/Path';\nimport Polygon from '../graphic/shape/Polygon';\nimport Polyline from '../graphic/shape/Polyline';\nimport * as matrix from '../core/matrix';\nimport { createFromString } from './path';\nimport { isString, extend, defaults, trim, each, map } from '../core/util';\nimport LinearGradient from '../graphic/LinearGradient';\nimport TSpan from '../graphic/TSpan';\nvar DILIMITER_REG = /[\\s,]+/;\nexport function parseXML(svg) {\n    if (isString(svg)) {\n        var parser = new DOMParser();\n        svg = parser.parseFromString(svg, 'text/xml');\n    }\n    var svgNode = svg;\n    if (svgNode.nodeType === 9) {\n        svgNode = svgNode.firstChild;\n    }\n    while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {\n        svgNode = svgNode.nextSibling;\n    }\n    return svgNode;\n}\nvar nodeParsers;\nvar SVGParser = (function () {\n    function SVGParser() {\n        this._defs = {};\n        this._root = null;\n        this._isDefine = false;\n        this._isText = false;\n    }\n    SVGParser.prototype.parse = function (xml, opt) {\n        opt = opt || {};\n        var svg = parseXML(xml);\n        if (!svg) {\n            throw new Error('Illegal svg');\n        }\n        var root = new Group();\n        this._root = root;\n        var viewBox = svg.getAttribute('viewBox') || '';\n        var width = parseFloat((svg.getAttribute('width') || opt.width));\n        var height = parseFloat((svg.getAttribute('height') || opt.height));\n        isNaN(width) && (width = null);\n        isNaN(height) && (height = null);\n        parseAttributes(svg, root, null, true);\n        var child = svg.firstChild;\n        while (child) {\n            this._parseNode(child, root);\n            child = child.nextSibling;\n        }\n        var viewBoxRect;\n        var viewBoxTransform;\n        if (viewBox) {\n            var viewBoxArr = trim(viewBox).split(DILIMITER_REG);\n            if (viewBoxArr.length >= 4) {\n                viewBoxRect = {\n                    x: parseFloat((viewBoxArr[0] || 0)),\n                    y: parseFloat((viewBoxArr[1] || 0)),\n                    width: parseFloat(viewBoxArr[2]),\n                    height: parseFloat(viewBoxArr[3])\n                };\n            }\n        }\n        if (viewBoxRect && width != null && height != null) {\n            viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n            if (!opt.ignoreViewBox) {\n                var elRoot = root;\n                root = new Group();\n                root.add(elRoot);\n                elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale;\n                elRoot.x = viewBoxTransform.x;\n                elRoot.y = viewBoxTransform.y;\n            }\n        }\n        if (!opt.ignoreRootClip && width != null && height != null) {\n            root.setClipPath(new Rect({\n                shape: { x: 0, y: 0, width: width, height: height }\n            }));\n        }\n        return {\n            root: root,\n            width: width,\n            height: height,\n            viewBoxRect: viewBoxRect,\n            viewBoxTransform: viewBoxTransform\n        };\n    };\n    SVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n        var nodeName = xmlNode.nodeName.toLowerCase();\n        if (nodeName === 'defs') {\n            this._isDefine = true;\n        }\n        else if (nodeName === 'text') {\n            this._isText = true;\n        }\n        var el;\n        if (this._isDefine) {\n            var parser = defineParsers[nodeName];\n            if (parser) {\n                var def = parser.call(this, xmlNode);\n                var id = xmlNode.getAttribute('id');\n                if (id) {\n                    this._defs[id] = def;\n                }\n            }\n        }\n        else {\n            var parser = nodeParsers[nodeName];\n            if (parser) {\n                el = parser.call(this, xmlNode, parentGroup);\n                parentGroup.add(el);\n            }\n        }\n        if (el) {\n            var child = xmlNode.firstChild;\n            while (child) {\n                if (child.nodeType === 1) {\n                    this._parseNode(child, el);\n                }\n                if (child.nodeType === 3 && this._isText) {\n                    this._parseText(child, el);\n                }\n                child = child.nextSibling;\n            }\n        }\n        if (nodeName === 'defs') {\n            this._isDefine = false;\n        }\n        else if (nodeName === 'text') {\n            this._isText = false;\n        }\n    };\n    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n        if (xmlNode.nodeType === 1) {\n            var dx = xmlNode.getAttribute('dx') || 0;\n            var dy = xmlNode.getAttribute('dy') || 0;\n            this._textX += parseFloat(dx);\n            this._textY += parseFloat(dy);\n        }\n        var text = new TSpan({\n            style: {\n                text: xmlNode.textContent\n            },\n            x: this._textX || 0,\n            y: this._textY || 0\n        });\n        inheritStyle(parentGroup, text);\n        parseAttributes(xmlNode, text, this._defs);\n        var textStyle = text.style;\n        var fontSize = textStyle.fontSize;\n        if (fontSize && fontSize < 9) {\n            textStyle.fontSize = 9;\n            text.scaleX *= fontSize / 9;\n            text.scaleY *= fontSize / 9;\n        }\n        var font = (textStyle.fontSize || textStyle.fontFamily) && [\n            textStyle.fontStyle,\n            textStyle.fontWeight,\n            (textStyle.fontSize || 12) + 'px',\n            textStyle.fontFamily || 'sans-serif'\n        ].join(' ');\n        textStyle.font = font;\n        var rect = text.getBoundingRect();\n        this._textX += rect.width;\n        parentGroup.add(text);\n        return text;\n    };\n    SVGParser.internalField = (function () {\n        nodeParsers = {\n            'g': function (xmlNode, parentGroup) {\n                var g = new Group();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'rect': function (xmlNode, parentGroup) {\n                var rect = new Rect();\n                inheritStyle(parentGroup, rect);\n                parseAttributes(xmlNode, rect, this._defs);\n                rect.setShape({\n                    x: parseFloat(xmlNode.getAttribute('x') || '0'),\n                    y: parseFloat(xmlNode.getAttribute('y') || '0'),\n                    width: parseFloat(xmlNode.getAttribute('width') || '0'),\n                    height: parseFloat(xmlNode.getAttribute('height') || '0')\n                });\n                return rect;\n            },\n            'circle': function (xmlNode, parentGroup) {\n                var circle = new Circle();\n                inheritStyle(parentGroup, circle);\n                parseAttributes(xmlNode, circle, this._defs);\n                circle.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    r: parseFloat(xmlNode.getAttribute('r') || '0')\n                });\n                return circle;\n            },\n            'line': function (xmlNode, parentGroup) {\n                var line = new Line();\n                inheritStyle(parentGroup, line);\n                parseAttributes(xmlNode, line, this._defs);\n                line.setShape({\n                    x1: parseFloat(xmlNode.getAttribute('x1') || '0'),\n                    y1: parseFloat(xmlNode.getAttribute('y1') || '0'),\n                    x2: parseFloat(xmlNode.getAttribute('x2') || '0'),\n                    y2: parseFloat(xmlNode.getAttribute('y2') || '0')\n                });\n                return line;\n            },\n            'ellipse': function (xmlNode, parentGroup) {\n                var ellipse = new Ellipse();\n                inheritStyle(parentGroup, ellipse);\n                parseAttributes(xmlNode, ellipse, this._defs);\n                ellipse.setShape({\n                    cx: parseFloat(xmlNode.getAttribute('cx') || '0'),\n                    cy: parseFloat(xmlNode.getAttribute('cy') || '0'),\n                    rx: parseFloat(xmlNode.getAttribute('rx') || '0'),\n                    ry: parseFloat(xmlNode.getAttribute('ry') || '0')\n                });\n                return ellipse;\n            },\n            'polygon': function (xmlNode, parentGroup) {\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polygon = new Polygon({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                inheritStyle(parentGroup, polygon);\n                parseAttributes(xmlNode, polygon, this._defs);\n                return polygon;\n            },\n            'polyline': function (xmlNode, parentGroup) {\n                var path = new Path();\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                var pointsStr = xmlNode.getAttribute('points');\n                var pointsArr;\n                if (pointsStr) {\n                    pointsArr = parsePoints(pointsStr);\n                }\n                var polyline = new Polyline({\n                    shape: {\n                        points: pointsArr || []\n                    }\n                });\n                return polyline;\n            },\n            'image': function (xmlNode, parentGroup) {\n                var img = new ZRImage();\n                inheritStyle(parentGroup, img);\n                parseAttributes(xmlNode, img, this._defs);\n                img.setStyle({\n                    image: xmlNode.getAttribute('xlink:href'),\n                    x: +xmlNode.getAttribute('x'),\n                    y: +xmlNode.getAttribute('y'),\n                    width: +xmlNode.getAttribute('width'),\n                    height: +xmlNode.getAttribute('height')\n                });\n                return img;\n            },\n            'text': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x') || '0';\n                var y = xmlNode.getAttribute('y') || '0';\n                var dx = xmlNode.getAttribute('dx') || '0';\n                var dy = xmlNode.getAttribute('dy') || '0';\n                this._textX = parseFloat(x) + parseFloat(dx);\n                this._textY = parseFloat(y) + parseFloat(dy);\n                var g = new Group();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                return g;\n            },\n            'tspan': function (xmlNode, parentGroup) {\n                var x = xmlNode.getAttribute('x');\n                var y = xmlNode.getAttribute('y');\n                if (x != null) {\n                    this._textX = parseFloat(x);\n                }\n                if (y != null) {\n                    this._textY = parseFloat(y);\n                }\n                var dx = xmlNode.getAttribute('dx') || 0;\n                var dy = xmlNode.getAttribute('dy') || 0;\n                var g = new Group();\n                inheritStyle(parentGroup, g);\n                parseAttributes(xmlNode, g, this._defs);\n                this._textX += dx;\n                this._textY += dy;\n                return g;\n            },\n            'path': function (xmlNode, parentGroup) {\n                var d = xmlNode.getAttribute('d') || '';\n                var path = createFromString(d);\n                inheritStyle(parentGroup, path);\n                parseAttributes(xmlNode, path, this._defs);\n                return path;\n            }\n        };\n    })();\n    return SVGParser;\n}());\nvar defineParsers = {\n    'lineargradient': function (xmlNode) {\n        var x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10);\n        var y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10);\n        var x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10);\n        var y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10);\n        var gradient = new LinearGradient(x1, y1, x2, y2);\n        _parseGradientColorStops(xmlNode, gradient);\n        return gradient;\n    }\n};\nfunction _parseGradientColorStops(xmlNode, gradient) {\n    var stop = xmlNode.firstChild;\n    while (stop) {\n        if (stop.nodeType === 1) {\n            var offsetStr = stop.getAttribute('offset');\n            var offset = void 0;\n            if (offsetStr.indexOf('%') > 0) {\n                offset = parseInt(offsetStr, 10) / 100;\n            }\n            else if (offsetStr) {\n                offset = parseFloat(offsetStr);\n            }\n            else {\n                offset = 0;\n            }\n            var stopColor = stop.getAttribute('stop-color') || '#000000';\n            gradient.colorStops.push({\n                offset: offset,\n                color: stopColor\n            });\n        }\n        stop = stop.nextSibling;\n    }\n}\nfunction inheritStyle(parent, child) {\n    if (parent && parent.__inheritedStyle) {\n        if (!child.__inheritedStyle) {\n            child.__inheritedStyle = {};\n        }\n        defaults(child.__inheritedStyle, parent.__inheritedStyle);\n    }\n}\nfunction parsePoints(pointsString) {\n    var list = trim(pointsString).split(DILIMITER_REG);\n    var points = [];\n    for (var i = 0; i < list.length; i += 2) {\n        var x = parseFloat(list[i]);\n        var y = parseFloat(list[i + 1]);\n        points.push([x, y]);\n    }\n    return points;\n}\nvar attributesMap = {\n    'fill': 'fill',\n    'stroke': 'stroke',\n    'stroke-width': 'lineWidth',\n    'opacity': 'opacity',\n    'fill-opacity': 'fillOpacity',\n    'stroke-opacity': 'strokeOpacity',\n    'stroke-dasharray': 'lineDash',\n    'stroke-dashoffset': 'lineDashOffset',\n    'stroke-linecap': 'lineCap',\n    'stroke-linejoin': 'lineJoin',\n    'stroke-miterlimit': 'miterLimit',\n    'font-family': 'fontFamily',\n    'font-size': 'fontSize',\n    'font-style': 'fontStyle',\n    'font-weight': 'fontWeight',\n    'text-align': 'textAlign',\n    'alignment-baseline': 'textBaseline'\n};\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n    var disp = el;\n    var zrStyle = disp.__inheritedStyle || {};\n    if (xmlNode.nodeType === 1) {\n        parseTransformAttribute(xmlNode, el);\n        extend(zrStyle, parseStyleAttribute(xmlNode));\n        if (!onlyInlineStyle) {\n            for (var svgAttrName in attributesMap) {\n                if (attributesMap.hasOwnProperty(svgAttrName)) {\n                    var attrValue = xmlNode.getAttribute(svgAttrName);\n                    if (attrValue != null) {\n                        zrStyle[attributesMap[svgAttrName]] = attrValue;\n                    }\n                }\n            }\n        }\n    }\n    disp.style = disp.style || {};\n    zrStyle.fill != null && (disp.style.fill = getPaint(zrStyle.fill, defs));\n    zrStyle.stroke != null && (disp.style.stroke = getPaint(zrStyle.stroke, defs));\n    each([\n        'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = parseFloat(zrStyle[propName]));\n    });\n    if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n        zrStyle.textBaseline = 'alphabetic';\n    }\n    if (zrStyle.textBaseline === 'alphabetic') {\n        zrStyle.textBaseline = 'bottom';\n    }\n    if (zrStyle.textAlign === 'start') {\n        zrStyle.textAlign = 'left';\n    }\n    if (zrStyle.textAlign === 'end') {\n        zrStyle.textAlign = 'right';\n    }\n    each(['lineDashOffset', 'lineCap', 'lineJoin',\n        'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'\n    ], function (propName) {\n        zrStyle[propName] != null && (disp.style[propName] = zrStyle[propName]);\n    });\n    if (zrStyle.lineDash) {\n        disp.style.lineDash = map(trim(zrStyle.lineDash).split(DILIMITER_REG), function (str) {\n            return parseFloat(str);\n        });\n    }\n    disp.__inheritedStyle = zrStyle;\n}\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\nfunction getPaint(str, defs) {\n    var urlMatch = defs && str && str.match(urlRegex);\n    if (urlMatch) {\n        var url = trim(urlMatch[1]);\n        var def = defs[url];\n        return def;\n    }\n    return str;\n}\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\nfunction parseTransformAttribute(xmlNode, node) {\n    var transform = xmlNode.getAttribute('transform');\n    if (transform) {\n        transform = transform.replace(/,/g, ' ');\n        var transformOps_1 = [];\n        var m = null;\n        transform.replace(transformRegex, function (str, type, value) {\n            transformOps_1.push(type, value);\n            return '';\n        });\n        for (var i = transformOps_1.length - 1; i > 0; i -= 2) {\n            var value = transformOps_1[i];\n            var type = transformOps_1[i - 1];\n            var valueArr = void 0;\n            m = m || matrix.create();\n            switch (type) {\n                case 'translate':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    matrix.translate(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')]);\n                    break;\n                case 'scale':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    matrix.scale(m, m, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])]);\n                    break;\n                case 'rotate':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    matrix.rotate(m, m, parseFloat(valueArr[0]));\n                    break;\n                case 'skew':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    console.warn('Skew transform is not supported yet');\n                    break;\n                case 'matrix':\n                    valueArr = trim(value).split(DILIMITER_REG);\n                    m[0] = parseFloat(valueArr[0]);\n                    m[1] = parseFloat(valueArr[1]);\n                    m[2] = parseFloat(valueArr[2]);\n                    m[3] = parseFloat(valueArr[3]);\n                    m[4] = parseFloat(valueArr[4]);\n                    m[5] = parseFloat(valueArr[5]);\n                    break;\n            }\n        }\n        node.setLocalTransform(m);\n    }\n}\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\nfunction parseStyleAttribute(xmlNode) {\n    var style = xmlNode.getAttribute('style');\n    var result = {};\n    if (!style) {\n        return result;\n    }\n    var styleList = {};\n    styleRegex.lastIndex = 0;\n    var styleRegResult;\n    while ((styleRegResult = styleRegex.exec(style)) != null) {\n        styleList[styleRegResult[1]] = styleRegResult[2];\n    }\n    for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n            result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n        }\n    }\n    return result;\n}\nexport function makeViewBoxTransform(viewBoxRect, width, height) {\n    var scaleX = width / viewBoxRect.width;\n    var scaleY = height / viewBoxRect.height;\n    var scale = Math.min(scaleX, scaleY);\n    return {\n        scale: scale,\n        x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2,\n        y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2\n    };\n}\nexport function parseSVG(xml, opt) {\n    var parser = new SVGParser();\n    return parser.parse(xml, opt);\n}\n"]},"metadata":{},"sourceType":"module"}