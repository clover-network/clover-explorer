{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport { each } from '@antv/util';\nexport var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  points.forEach(function (p) {\n    var id = p.x + \"-\" + p.y;\n    p.id = id;\n    pointsMap[id] = p;\n  });\n  each(pointsMap, function (p) {\n    result.push(p);\n  });\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  points = filterConnectPoints(points);\n  return points;\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    // when it is a point\n    return bbox;\n  }\n\n  return {\n    centerX: bbox.centerX,\n    centerY: bbox.centerY,\n    minX: bbox.minX - offset,\n    minY: bbox.minY - offset,\n    maxX: bbox.maxX + offset,\n    maxY: bbox.maxY + offset,\n    height: bbox.height + 2 * offset,\n    width: bbox.width + 2 * offset\n  };\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, point) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  var minX = bbox.minX,\n      minY = bbox.minY,\n      maxX = bbox.maxX,\n      maxY = bbox.maxY;\n  return [{\n    x: minX,\n    y: minY\n  }, {\n    x: maxX,\n    y: minY\n  }, {\n    x: maxX,\n    y: maxY\n  }, {\n    x: minX,\n    y: maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var s1X = p1.x - p0.x;\n  var s1Y = p1.y - p0.y;\n  var s2X = p3.x - p2.x;\n  var s2Y = p3.y - p2.y;\n  var s = (-s1Y * (p0.x - p2.x) + s1X * (p0.y - p2.y)) / (-s2X * s1Y + s1X * s2Y);\n  var t = (s2X * (p0.y - p2.y) - s2Y * (p0.x - p2.x)) / (-s2X * s1Y + s1X * s2Y);\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    return false;\n  }\n\n  var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n\n  return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p !== point) {\n      if (p.x === point.x || p.y === point.y) {\n        if (!isSegmentCrossingBBox(p, point, bbox1) && !isSegmentCrossingBBox(p, point, bbox2)) {\n          neighbors.push(p);\n        }\n      }\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] < lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return {\n        value: pathPoints\n      };\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  };\n\n  while (openSet.length) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  // TODO\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\" + startPoint.x + \" \" + startPoint.y);\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\" + ps.x + \" \" + ps.y);\n        pathSegments.push(\"Q\" + p1.x + \" \" + p1.y + \" \" + pt.x + \" \" + pt.y);\n        pathSegments.push(\"L\" + pt.x + \" \" + pt.y);\n      } else {\n        pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tNodeKeyShape = tNode.getKeyShape();\n    tBBox = tNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(end);\n    tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n    tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n\n  if (isBBoxesOverlapping(sBBox, tBBox)) {\n    // source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n\n  if (isBBoxesOverlapping(sxBBox, txBBox)) {\n    // the expanded bounding boxes of source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start);\n  var tPoint = getExpandedBBoxPoint(txBBox, end);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var outerBBox = mergeBBox(sxBBox, txBBox);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox));\n  connectPoints = connectPoints.concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n        connectPoints.push(p);\n      }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/shape/edges/polyline-util.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","each","getBBoxFromPoint","point","x","y","centerX","centerY","minX","minY","maxX","maxY","height","width","getBBoxFromPoints","points","xs","ys","forEach","p","push","Math","min","apply","max","isBBoxesOverlapping","b1","b2","abs","filterConnectPoints","result","pointsMap","id","simplifyPolyline","getSimplePolyline","sPoint","tPoint","getExpandedBBox","bbox","offset","isHorizontalPort","port","dx","dy","getExpandedBBoxPoint","isHorizontal","mergeBBox","getPointsFromBBox","isPointOutsideBBox","getBBoxXCrossPoints","getBBoxYCrossPoints","getBBoxCrossPointsByPoint","concat","distance","p1","p2","_costByPoints","heuristicCostEstimate","ps","pt","source","target","reconstructPath","pathPoints","pointById","cameFrom","currentId","unshift","removeFrom","arr","item","index","indexOf","splice","isSegmentsIntersected","p0","p3","s1X","s1Y","s2X","s2Y","s","t","isSegmentCrossingBBox","_a","pa","pb","pc","pd","getNeighborPoints","bbox1","bbox2","neighbors","pathFinder","start","goal","sBBox","tBBox","os","ot","closedSet","openSet","gScore","fScore","_loop_1","current","lowestFScore","Infinity","value","neighbor","tentativeGScore","length","state_1","isBending","getBorderRadiusPoints","r","d0","d1","getPathWithBorderRadiusByPolyline","borderRadius","pathSegments","startPoint","i","join","getPolylinePoints","end","sNode","tNode","getType","sNodeKeyShape","getKeyShape","getCanvasBBox","getBBox","tNodeKeyShape","sxBBox","txBBox","lineBBox","outerBBox","sMixBBox","tMixBBox","connectPoints","centerPoint","filter"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { each } from '@antv/util';\nexport var getBBoxFromPoint = function getBBoxFromPoint(point) {\n  var x = point.x,\n      y = point.y;\n  return {\n    x: x,\n    y: y,\n    centerX: x,\n    centerY: y,\n    minX: x,\n    minY: y,\n    maxX: x,\n    maxY: y,\n    height: 0,\n    width: 0\n  };\n};\nexport var getBBoxFromPoints = function getBBoxFromPoints(points) {\n  if (points === void 0) {\n    points = [];\n  }\n\n  var xs = [];\n  var ys = [];\n  points.forEach(function (p) {\n    xs.push(p.x);\n    ys.push(p.y);\n  });\n  var minX = Math.min.apply(Math, xs);\n  var maxX = Math.max.apply(Math, xs);\n  var minY = Math.min.apply(Math, ys);\n  var maxY = Math.max.apply(Math, ys);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    maxX: maxX,\n    maxY: maxY,\n    minX: minX,\n    minY: minY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var isBBoxesOverlapping = function isBBoxesOverlapping(b1, b2) {\n  return Math.abs(b1.centerX - b2.centerX) * 2 < b1.width + b2.width && Math.abs(b1.centerY - b2.centerY) * 2 < b1.height + b2.height;\n};\nexport var filterConnectPoints = function filterConnectPoints(points) {\n  // pre-process: remove duplicated points\n  var result = [];\n  var pointsMap = {};\n  points.forEach(function (p) {\n    var id = p.x + \"-\" + p.y;\n    p.id = id;\n    pointsMap[id] = p;\n  });\n  each(pointsMap, function (p) {\n    result.push(p);\n  });\n  return result;\n};\nexport var simplifyPolyline = function simplifyPolyline(points) {\n  points = filterConnectPoints(points);\n  return points;\n};\nexport var getSimplePolyline = function getSimplePolyline(sPoint, tPoint) {\n  return [sPoint, {\n    x: sPoint.x,\n    y: tPoint.y\n  }, tPoint];\n};\nexport var getExpandedBBox = function getExpandedBBox(bbox, offset) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    // when it is a point\n    return bbox;\n  }\n\n  return {\n    centerX: bbox.centerX,\n    centerY: bbox.centerY,\n    minX: bbox.minX - offset,\n    minY: bbox.minY - offset,\n    maxX: bbox.maxX + offset,\n    maxY: bbox.maxY + offset,\n    height: bbox.height + 2 * offset,\n    width: bbox.width + 2 * offset\n  };\n};\nexport var isHorizontalPort = function isHorizontalPort(port, bbox) {\n  var dx = Math.abs(port.x - bbox.centerX);\n  var dy = Math.abs(port.y - bbox.centerY);\n  return dx / bbox.width > dy / bbox.height;\n};\nexport var getExpandedBBoxPoint = function getExpandedBBoxPoint(bbox, point) {\n  var isHorizontal = isHorizontalPort(point, bbox);\n\n  if (isHorizontal) {\n    return {\n      x: point.x > bbox.centerX ? bbox.maxX : bbox.minX,\n      y: point.y\n    };\n  }\n\n  return {\n    x: point.x,\n    y: point.y > bbox.centerY ? bbox.maxY : bbox.minY\n  };\n};\n/**\n *\n * @param b1\n * @param b2\n */\n\nexport var mergeBBox = function mergeBBox(b1, b2) {\n  var minX = Math.min(b1.minX, b2.minX);\n  var minY = Math.min(b1.minY, b2.minY);\n  var maxX = Math.max(b1.maxX, b2.maxX);\n  var maxY = Math.max(b1.maxY, b2.maxY);\n  return {\n    centerX: (minX + maxX) / 2,\n    centerY: (minY + maxY) / 2,\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY,\n    height: maxY - minY,\n    width: maxX - minX\n  };\n};\nexport var getPointsFromBBox = function getPointsFromBBox(bbox) {\n  // anticlockwise\n  var minX = bbox.minX,\n      minY = bbox.minY,\n      maxX = bbox.maxX,\n      maxY = bbox.maxY;\n  return [{\n    x: minX,\n    y: minY\n  }, {\n    x: maxX,\n    y: minY\n  }, {\n    x: maxX,\n    y: maxY\n  }, {\n    x: minX,\n    y: maxY\n  }];\n};\nexport var isPointOutsideBBox = function isPointOutsideBBox(point, bbox) {\n  var x = point.x,\n      y = point.y;\n  return x < bbox.minX || x > bbox.maxX || y < bbox.minY || y > bbox.maxY;\n};\nexport var getBBoxXCrossPoints = function getBBoxXCrossPoints(bbox, x) {\n  if (x < bbox.minX || x > bbox.maxX) {\n    return [];\n  }\n\n  return [{\n    x: x,\n    y: bbox.minY\n  }, {\n    x: x,\n    y: bbox.maxY\n  }];\n};\nexport var getBBoxYCrossPoints = function getBBoxYCrossPoints(bbox, y) {\n  if (y < bbox.minY || y > bbox.maxY) {\n    return [];\n  }\n\n  return [{\n    x: bbox.minX,\n    y: y\n  }, {\n    x: bbox.maxX,\n    y: y\n  }];\n};\nexport var getBBoxCrossPointsByPoint = function getBBoxCrossPointsByPoint(bbox, point) {\n  return getBBoxXCrossPoints(bbox, point.x).concat(getBBoxYCrossPoints(bbox, point.y));\n};\n/**\n * 曼哈顿距离\n */\n\nexport var distance = function distance(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n/**\n * 如果 points 中的一个节点 x 与 p 相等，则消耗 -2。y 同\n * 即优先选择和 points 在同一水平线 / 垂直线上的点\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\n\nexport var _costByPoints = function _costByPoints(p, points) {\n  var offset = -2;\n  var result = 0;\n  points.forEach(function (point) {\n    if (point) {\n      if (p.x === point.x) {\n        result += offset;\n      }\n\n      if (p.y === point.y) {\n        result += offset;\n      }\n    }\n  });\n  return result;\n};\n/**\n * ps 经过 p 到 pt 的距离，减去其他路过节点造成的消耗\n */\n\nexport var heuristicCostEstimate = function heuristicCostEstimate(p, ps, pt, source, target) {\n  return distance(p, ps) + distance(p, pt) + _costByPoints(p, [ps, pt, source, target]);\n};\nexport var reconstructPath = function reconstructPath(pathPoints, pointById, cameFrom, currentId, iterator) {\n  if (iterator === void 0) {\n    iterator = 0;\n  }\n\n  pathPoints.unshift(pointById[currentId]);\n\n  if (cameFrom[currentId] && cameFrom[currentId] !== currentId && iterator <= 100) {\n    reconstructPath(pathPoints, pointById, cameFrom, cameFrom[currentId], iterator + 1);\n  }\n};\n/**\n * 从 arr 中删去 item\n */\n\nexport var removeFrom = function removeFrom(arr, item) {\n  var index = arr.indexOf(item);\n\n  if (index > -1) {\n    arr.splice(index, 1);\n  }\n};\nexport var isSegmentsIntersected = function isSegmentsIntersected(p0, p1, p2, p3) {\n  var s1X = p1.x - p0.x;\n  var s1Y = p1.y - p0.y;\n  var s2X = p3.x - p2.x;\n  var s2Y = p3.y - p2.y;\n  var s = (-s1Y * (p0.x - p2.x) + s1X * (p0.y - p2.y)) / (-s2X * s1Y + s1X * s2Y);\n  var t = (s2X * (p0.y - p2.y) - s2Y * (p0.x - p2.x)) / (-s2X * s1Y + s1X * s2Y);\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n};\nexport var isSegmentCrossingBBox = function isSegmentCrossingBBox(p1, p2, bbox) {\n  if (bbox.width === 0 && bbox.height === 0) {\n    return false;\n  }\n\n  var _a = getPointsFromBBox(bbox),\n      pa = _a[0],\n      pb = _a[1],\n      pc = _a[2],\n      pd = _a[3];\n\n  return isSegmentsIntersected(p1, p2, pa, pb) || isSegmentsIntersected(p1, p2, pa, pd) || isSegmentsIntersected(p1, p2, pb, pc) || isSegmentsIntersected(p1, p2, pc, pd);\n};\n/**\n * 在 points 中找到满足 x 或 y 和 point 的 x 或 y 相等，且与 point 连线不经过 bbox1 与 bbox2 的点\n */\n\nexport var getNeighborPoints = function getNeighborPoints(points, point, bbox1, bbox2) {\n  var neighbors = [];\n  points.forEach(function (p) {\n    if (p !== point) {\n      if (p.x === point.x || p.y === point.y) {\n        if (!isSegmentCrossingBBox(p, point, bbox1) && !isSegmentCrossingBBox(p, point, bbox2)) {\n          neighbors.push(p);\n        }\n      }\n    }\n  });\n  return filterConnectPoints(neighbors);\n};\nexport var pathFinder = function pathFinder(points, start, goal, sBBox, tBBox, os, ot) {\n  // A-Star Algorithm\n  var closedSet = [];\n  var openSet = [start];\n  var cameFrom = {};\n  var gScore = {}; // all default values are Infinity\n\n  var fScore = {}; // all default values are Infinity\n\n  gScore[start.id] = 0;\n  fScore[start.id] = heuristicCostEstimate(start, goal, start);\n  var pointById = {};\n  points.forEach(function (p) {\n    pointById[p.id] = p;\n  });\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var lowestFScore = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    openSet.forEach(function (p) {\n      if (fScore[p.id] < lowestFScore) {\n        lowestFScore = fScore[p.id];\n        current = p;\n      }\n    }); // 若 openSet 中 fScore 最小的点就是终点\n\n    if (current === goal) {\n      // ending condition\n      var pathPoints = [];\n      reconstructPath(pathPoints, pointById, cameFrom, goal.id);\n      return {\n        value: pathPoints\n      };\n    }\n\n    removeFrom(openSet, current);\n    closedSet.push(current);\n    getNeighborPoints(points, current, sBBox, tBBox).forEach(function (neighbor) {\n      if (closedSet.indexOf(neighbor) !== -1) {\n        return;\n      }\n\n      if (openSet.indexOf(neighbor) === -1) {\n        openSet.push(neighbor);\n      }\n\n      var tentativeGScore = fScore[current.id] + distance(current, neighbor); // + distance(neighbor, goal);\n\n      if (gScore[neighbor.id] && tentativeGScore >= gScore[neighbor.id]) {\n        return;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = tentativeGScore;\n      fScore[neighbor.id] = gScore[neighbor.id] + heuristicCostEstimate(neighbor, goal, start, os, ot);\n    });\n  };\n\n  while (openSet.length) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n  } // throw new Error('Cannot find path');\n\n\n  return [start, goal];\n};\nexport var isBending = function isBending(p0, p1, p2) {\n  return !(p0.x === p1.x && p1.x === p2.x || p0.y === p1.y && p1.y === p2.y);\n};\nexport var getBorderRadiusPoints = function getBorderRadiusPoints(p0, p1, p2, r) {\n  var d0 = distance(p0, p1);\n  var d1 = distance(p2, p1);\n\n  if (d0 < r) {\n    r = d0;\n  }\n\n  if (d1 < r) {\n    r = d1;\n  }\n\n  var ps = {\n    x: p1.x - r / d0 * (p1.x - p0.x),\n    y: p1.y - r / d0 * (p1.y - p0.y)\n  };\n  var pt = {\n    x: p1.x - r / d1 * (p1.x - p2.x),\n    y: p1.y - r / d1 * (p1.y - p2.y)\n  };\n  return [ps, pt];\n};\nexport var getPathWithBorderRadiusByPolyline = function getPathWithBorderRadiusByPolyline(points, borderRadius) {\n  // TODO\n  var pathSegments = [];\n  var startPoint = points[0];\n  pathSegments.push(\"M\" + startPoint.x + \" \" + startPoint.y);\n  points.forEach(function (p, i) {\n    var p1 = points[i + 1];\n    var p2 = points[i + 2];\n\n    if (p1 && p2) {\n      if (isBending(p, p1, p2)) {\n        var _a = getBorderRadiusPoints(p, p1, p2, borderRadius),\n            ps = _a[0],\n            pt = _a[1];\n\n        pathSegments.push(\"L\" + ps.x + \" \" + ps.y);\n        pathSegments.push(\"Q\" + p1.x + \" \" + p1.y + \" \" + pt.x + \" \" + pt.y);\n        pathSegments.push(\"L\" + pt.x + \" \" + pt.y);\n      } else {\n        pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n      }\n    } else if (p1) {\n      pathSegments.push(\"L\" + p1.x + \" \" + p1.y);\n    }\n  });\n  return pathSegments.join('');\n};\nexport var getPolylinePoints = function getPolylinePoints(start, end, sNode, tNode, offset) {\n  var sBBox, tBBox;\n\n  if (!sNode || !sNode.getType()) {\n    sBBox = getBBoxFromPoint(start);\n  } else if (sNode.getType() === 'combo') {\n    var sNodeKeyShape = sNode.getKeyShape();\n    sBBox = sNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(start);\n    sBBox.centerX = (sBBox.minX + sBBox.maxX) / 2;\n    sBBox.centerY = (sBBox.minY + sBBox.maxY) / 2;\n  } else {\n    sBBox = sNode.getBBox();\n  }\n\n  if (!tNode || !tNode.getType()) {\n    tBBox = getBBoxFromPoint(end);\n  } else if (tNode.getType() === 'combo') {\n    var tNodeKeyShape = tNode.getKeyShape();\n    tBBox = tNodeKeyShape.getCanvasBBox() || getBBoxFromPoint(end);\n    tBBox.centerX = (tBBox.minX + tBBox.maxX) / 2;\n    tBBox.centerY = (tBBox.minY + tBBox.maxY) / 2;\n  } else {\n    tBBox = tNode && tNode.getBBox();\n  }\n\n  if (isBBoxesOverlapping(sBBox, tBBox)) {\n    // source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sxBBox = getExpandedBBox(sBBox, offset);\n  var txBBox = getExpandedBBox(tBBox, offset);\n\n  if (isBBoxesOverlapping(sxBBox, txBBox)) {\n    // the expanded bounding boxes of source and target nodes are overlapping\n    return simplifyPolyline(getSimplePolyline(start, end));\n  }\n\n  var sPoint = getExpandedBBoxPoint(sxBBox, start);\n  var tPoint = getExpandedBBoxPoint(txBBox, end);\n  var lineBBox = getBBoxFromPoints([sPoint, tPoint]);\n  var outerBBox = mergeBBox(sxBBox, txBBox);\n  var sMixBBox = mergeBBox(sxBBox, lineBBox);\n  var tMixBBox = mergeBBox(txBBox, lineBBox);\n  var connectPoints = [];\n  connectPoints = connectPoints.concat(getPointsFromBBox(sMixBBox));\n  connectPoints = connectPoints.concat(getPointsFromBBox(tMixBBox));\n  var centerPoint = {\n    x: (start.x + end.x) / 2,\n    y: (start.y + end.y) / 2\n  };\n  [lineBBox, sMixBBox, tMixBBox].forEach(function (bbox) {\n    connectPoints = connectPoints.concat(getBBoxCrossPointsByPoint(bbox, centerPoint).filter(function (p) {\n      return isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox);\n    }));\n  });\n  [{\n    x: sPoint.x,\n    y: tPoint.y\n  }, {\n    x: tPoint.x,\n    y: sPoint.y\n  }].forEach(function (p) {\n    // impossible!!\n    if (isPointOutsideBBox(p, sxBBox) && isPointOutsideBBox(p, txBBox) // &&\n    // isPointInsideBBox(p, sMixBBox) && isPointInsideBBox(p, tMixBBox)\n    ) {\n        connectPoints.push(p);\n      }\n  });\n  connectPoints.unshift(sPoint);\n  connectPoints.push(tPoint); // filter out dulplicated points in connectPoints\n\n  connectPoints = filterConnectPoints(connectPoints); // , sxBBox, txBBox, outerBBox\n\n  var pathPoints = pathFinder(connectPoints, sPoint, tPoint, sBBox, tBBox, start, end);\n  pathPoints.unshift(start);\n  pathPoints.push(end);\n  return simplifyPolyline(pathPoints);\n};"]},"metadata":{},"sourceType":"module"}