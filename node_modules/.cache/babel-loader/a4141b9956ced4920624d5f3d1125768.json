{"ast":null,"code":"import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\nvar primMST = function primMST(graph, weight) {\n  var selectedEdges = [];\n  var nodes = graph.getNodes();\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.getModel()[weight] - b.getModel()[weight];\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  currNode.getEdges().forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.getSource();\n    var target = currEdge.getTarget();\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      source.getEdges().forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      target.getEdges().forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graph, weight) {\n  var selectedEdges = [];\n\n  if (graph.getNodes().length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var edges = graph.getEdges().map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    edges.sort(function (a, b) {\n      return a.getModel()[weight] - b.getModel()[weight];\n    });\n  }\n\n  var disjointSet = new UnionFind(graph.getNodes().map(function (n) {\n    return n.get('id');\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (edges.length > 0) {\n    var curEdge = edges.shift();\n    var source = curEdge.getSource().get('id');\n    var target = curEdge.getTarget().get('id');\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nexport default function mst(graph, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graph, weight);\n  return algos[algo](graph, weight);\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/algorithm/mst.js"],"names":["UnionFind","MinBinaryHeap","primMST","graph","weight","selectedEdges","nodes","getNodes","length","currNode","visited","Set","add","compareWeight","a","b","getModel","edgeQueue","getEdges","forEach","edge","insert","isEmpty","currEdge","delMin","source","getSource","target","getTarget","has","push","kruskalMST","edges","map","sort","disjointSet","n","get","curEdge","shift","connected","union","mst","algo","algos","prim","kruskal"],"mappings":"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","sourcesContent":["import UnionFind from './structs/union-find';\nimport MinBinaryHeap from './structs/binary-heap';\n/**\n * Prim algorithm，use priority queue，复杂度 O(E+V*logV), V: 节点数量，E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Prim%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n */\n\nvar primMST = function primMST(graph, weight) {\n  var selectedEdges = [];\n  var nodes = graph.getNodes();\n\n  if (nodes.length === 0) {\n    return selectedEdges;\n  } // 从nodes[0]开始\n\n\n  var currNode = nodes[0];\n  var visited = new Set();\n  visited.add(currNode); // 用二叉堆维护距已加入节点的其他节点的边的权值\n\n  var compareWeight = function compareWeight(a, b) {\n    if (weight) {\n      return a.getModel()[weight] - b.getModel()[weight];\n    }\n\n    return 0;\n  };\n\n  var edgeQueue = new MinBinaryHeap(compareWeight);\n  currNode.getEdges().forEach(function (edge) {\n    edgeQueue.insert(edge);\n  });\n\n  while (!edgeQueue.isEmpty()) {\n    // 选取与已加入的结点之间边权最小的结点\n    var currEdge = edgeQueue.delMin();\n    var source = currEdge.getSource();\n    var target = currEdge.getTarget();\n    if (visited.has(source) && visited.has(target)) continue;\n    selectedEdges.push(currEdge);\n\n    if (!visited.has(source)) {\n      visited.add(source);\n      source.getEdges().forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n\n    if (!visited.has(target)) {\n      visited.add(target);\n      target.getEdges().forEach(function (edge) {\n        edgeQueue.insert(edge);\n      });\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * Kruskal algorithm，复杂度 O(E*logE), E: 边的数量\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nvar kruskalMST = function kruskalMST(graph, weight) {\n  var selectedEdges = [];\n\n  if (graph.getNodes().length === 0) {\n    return selectedEdges;\n  } // 若指定weight，则将所有的边按权值从小到大排序\n\n\n  var edges = graph.getEdges().map(function (edge) {\n    return edge;\n  });\n\n  if (weight) {\n    edges.sort(function (a, b) {\n      return a.getModel()[weight] - b.getModel()[weight];\n    });\n  }\n\n  var disjointSet = new UnionFind(graph.getNodes().map(function (n) {\n    return n.get('id');\n  })); // 从权值最小的边开始，如果这条边连接的两个节点于图G中不在同一个连通分量中，则添加这条边\n  // 直到遍历完所有点或边\n\n  while (edges.length > 0) {\n    var curEdge = edges.shift();\n    var source = curEdge.getSource().get('id');\n    var target = curEdge.getTarget().get('id');\n\n    if (!disjointSet.connected(source, target)) {\n      selectedEdges.push(curEdge);\n      disjointSet.union(source, target);\n    }\n  }\n\n  return selectedEdges;\n};\n/**\n * 最小生成树\n * refer: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm\n * @param graph\n * @param weight 指定用于作为边权重的属性，若不指定，则认为所有边权重一致\n * @param algo 'prim' | 'kruskal' 算法类型\n * @return IEdge[] 返回构成MST的边的数组\n */\n\n\nexport default function mst(graph, weight, algo) {\n  var algos = {\n    prim: primMST,\n    kruskal: kruskalMST\n  };\n  if (!algo) return kruskalMST(graph, weight);\n  return algos[algo](graph, weight);\n}"]},"metadata":{},"sourceType":"module"}