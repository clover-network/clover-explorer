{"ast":null,"code":"/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport { BaseLayout } from './layout';\nimport { isNumber, isArray, isFunction } from '@antv/util';\nimport { traverseTreeUp } from '../util/graphic';\nimport Global from '../global';\n/**\n * force layout for graph with combos\n */\n\nvar ComboForce =\n/** @class */\nfunction (_super) {\n  __extends(ComboForce, _super);\n\n  function ComboForce() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 100;\n    /** 重力大小，影响图的紧凑程度 */\n\n    _this.gravity = 10;\n    /** 群组中心力大小 */\n\n    _this.comboGravity = 10;\n    /** 默认边长度 */\n\n    _this.linkDistance = 10;\n    /** 每次迭代位移的衰减相关参数 */\n\n    _this.alpha = 1;\n    _this.alphaMin = 0.001;\n    _this.alphaDecay = 1 - Math.pow(_this.alphaMin, 1 / 300);\n    _this.alphaTarget = 0;\n    /** 节点运动速度衰减参数 */\n\n    _this.velocityDecay = 0.6;\n    /** 边引力大小 */\n\n    _this.edgeStrength = 0.2;\n    /** 节点引力大小 */\n\n    _this.nodeStrength = 30;\n    /** 是否开启防止重叠 */\n\n    _this.preventOverlap = false;\n    /** 是否开启节点之间的防止重叠 */\n\n    _this.preventNodeOverlap = false;\n    /** 是否开启 Combo 之间的防止重叠 */\n\n    _this.preventComboOverlap = false;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.collideStrength = undefined;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.nodeCollideStrength = undefined;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.comboCollideStrength = undefined;\n    /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n\n    _this.optimizeRangeFactor = 1;\n    /** 每次迭代的回调函数 */\n\n    _this.onTick = function () {};\n    /** 每次迭代的回调函数 */\n\n\n    _this.onLayoutEnd = function () {};\n    /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n\n\n    _this.depthAttractiveForceScale = 0.5;\n    /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n\n    _this.depthRepulsiveForceScale = 2;\n    /** 内部计算参数 */\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.combos = [];\n    _this.comboTrees = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.bias = [];\n    _this.nodeMap = {};\n    _this.oriComboMap = {};\n    _this.nodeIdxMap = {};\n    _this.comboMap = {};\n    _this.previousLayouted = false;\n    return _this;\n  }\n\n  ComboForce.prototype.getDefaultCfg = function () {\n    return {\n      maxIteration: 100,\n      center: [0, 0],\n      gravity: 10,\n      speed: 1,\n      comboGravity: 30,\n      preventOverlap: false,\n      preventComboOverlap: true,\n      preventNodeOverlap: true,\n      nodeSpacing: undefined,\n      collideStrength: undefined,\n      nodeCollideStrength: 0.5,\n      comboCollideStrength: 0.5,\n      comboSpacing: 20,\n      comboPadding: 10,\n      edgeStrength: 0.2,\n      nodeStrength: 30,\n      linkDistance: 10\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ComboForce.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var center = self.center;\n    self.comboTree = {\n      id: 'comboTreeRoot',\n      depth: -1,\n      children: self.comboTrees\n    };\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    self.initVals(); // layout\n\n    self.run();\n    self.onLayoutEnd();\n  };\n\n  ComboForce.prototype.run = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var maxIteration = self.previousLayouted ? self.maxIteration / 5 : self.maxIteration;\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    var center = self.center;\n    var velocityDecay = self.velocityDecay; // init the positions to make the nodes with same combo gather around the combo\n\n    var comboMap = self.comboMap;\n    if (!self.previousLayouted) self.initPos(comboMap);\n\n    var _loop_1 = function _loop_1(i) {\n      var displacements = [];\n      nodes.forEach(function (_, j) {\n        displacements[j] = {\n          x: 0,\n          y: 0\n        };\n      });\n      self.applyCalculate(displacements); // gravity for combos\n\n      self.applyComboCenterForce(displacements); // move\n\n      nodes.forEach(function (n, j) {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        n.x += displacements[j].x * velocityDecay;\n        n.y += displacements[j].y * velocityDecay;\n      });\n      self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n      self.onTick();\n    }; // iterate\n\n\n    for (var i = 0; i < maxIteration; i++) {\n      _loop_1(i);\n    } // move to center\n\n\n    var meanCenter = [0, 0];\n    nodes.forEach(function (n) {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      meanCenter[0] += n.x;\n      meanCenter[1] += n.y;\n    });\n    meanCenter[0] /= nodes.length;\n    meanCenter[1] /= nodes.length;\n    var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n    nodes.forEach(function (n, j) {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      n.x += centerOffset[0];\n      n.y += centerOffset[1];\n    }); // arrange the empty combo\n\n    self.combos.forEach(function (combo) {\n      var mapped = comboMap[combo.id];\n\n      if (mapped && mapped.empty) {\n        combo.x = mapped.cx || combo.x;\n        combo.y = mapped.cy || combo.y;\n      }\n    });\n    self.previousLayouted = true;\n  };\n\n  ComboForce.prototype.initVals = function () {\n    var self = this;\n    var edges = self.edges;\n    var nodes = self.nodes;\n    var combos = self.combos;\n    var count = {};\n    var nodeMap = {};\n    var nodeIdxMap = {};\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    var oriComboMap = {};\n    combos.forEach(function (combo) {\n      oriComboMap[combo.id] = combo;\n    });\n    self.oriComboMap = oriComboMap;\n    self.comboMap = self.getComboMap();\n    var preventOverlap = self.preventOverlap;\n    self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n    self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n    var collideStrength = self.collideStrength;\n\n    if (collideStrength) {\n      self.comboCollideStrength = collideStrength;\n      self.nodeCollideStrength = collideStrength;\n    } // get edge bias\n\n\n    for (var i = 0; i < edges.length; ++i) {\n      if (count[edges[i].source]) count[edges[i].source]++;else count[edges[i].source] = 1;\n      if (count[edges[i].target]) count[edges[i].target]++;else count[edges[i].target] = 1;\n    }\n\n    var bias = [];\n\n    for (var i = 0; i < edges.length; ++i) {\n      bias[i] = count[edges[i].source] / (count[edges[i].source] + count[edges[i].target]);\n    }\n\n    this.bias = bias;\n    var nodeSize = self.nodeSize;\n    var nodeSpacing = self.nodeSpacing;\n    var nodeSizeFunc;\n    var nodeSpacingFunc; // nodeSpacing to function\n\n    if (isNumber(nodeSpacing)) {\n      nodeSpacingFunc = function nodeSpacingFunc() {\n        return nodeSpacing;\n      };\n    } else if (isFunction(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = function nodeSpacingFunc() {\n        return 0;\n      };\n    }\n\n    this.nodeSpacing = nodeSpacingFunc; // nodeSize to function\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        if (d.size) {\n          if (isArray(d.size)) {\n            var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2;\n          }\n\n          return d.size / 2;\n        }\n\n        return 10;\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return nodeSize(d);\n      };\n    } else if (isArray(nodeSize)) {\n      var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      var radius_1 = larger / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_1;\n      };\n    } else {\n      // number type\n      var radius_2 = nodeSize / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_2;\n      };\n    }\n\n    this.nodeSize = nodeSizeFunc; // comboSpacing to function\n\n    var comboSpacing = self.comboSpacing;\n    var comboSpacingFunc;\n\n    if (isNumber(comboSpacing)) {\n      comboSpacingFunc = function comboSpacingFunc() {\n        return comboSpacing;\n      };\n    } else if (isFunction(comboSpacing)) {\n      comboSpacingFunc = comboSpacing;\n    } else {\n      // null type\n      comboSpacingFunc = function comboSpacingFunc() {\n        return 0;\n      };\n    }\n\n    this.comboSpacing = comboSpacingFunc; // comboPadding to function\n\n    var comboPadding = self.comboPadding;\n    var comboPaddingFunc;\n\n    if (isNumber(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return comboPadding;\n      };\n    } else if (isArray(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return Math.max.apply(null, comboPadding);\n      };\n    } else if (isFunction(comboPadding)) {\n      comboPaddingFunc = comboPadding;\n    } else {\n      // null type\n      comboPaddingFunc = function comboPaddingFunc() {\n        return 0;\n      };\n    }\n\n    this.comboPadding = comboPaddingFunc; // linkDistance to function\n\n    var linkDistance = this.linkDistance;\n    var linkDistanceFunc;\n\n    if (!linkDistance) {\n      linkDistance = 10;\n    }\n\n    if (isNumber(linkDistance)) {\n      linkDistanceFunc = function linkDistanceFunc(d) {\n        return linkDistance;\n      };\n    } else {\n      linkDistanceFunc = linkDistance;\n    }\n\n    this.linkDistance = linkDistanceFunc; // linkStrength to function\n\n    var edgeStrength = this.edgeStrength;\n    var edgeStrengthFunc;\n\n    if (!edgeStrength) {\n      edgeStrength = 1;\n    }\n\n    if (isNumber(edgeStrength)) {\n      edgeStrengthFunc = function edgeStrengthFunc(d) {\n        return edgeStrength;\n      };\n    } else {\n      edgeStrengthFunc = edgeStrength;\n    }\n\n    this.edgeStrength = edgeStrengthFunc; // nodeStrength to function\n\n    var nodeStrength = this.nodeStrength;\n    var nodeStrengthFunc;\n\n    if (!nodeStrength) {\n      nodeStrength = 30;\n    }\n\n    if (isNumber(nodeStrength)) {\n      nodeStrengthFunc = function nodeStrengthFunc(d) {\n        return nodeStrength;\n      };\n    } else {\n      nodeStrengthFunc = nodeStrength;\n    }\n\n    this.nodeStrength = nodeStrengthFunc;\n  };\n\n  ComboForce.prototype.initPos = function (comboMap) {\n    var self = this;\n    var nodes = self.nodes;\n    nodes.forEach(function (node, i) {\n      if (node.comboId) {\n        var combo = comboMap[node.comboId];\n        node.x = combo.cx + 100 / (i + 1);\n        node.y = combo.cy + 100 / (i + 1);\n      } else {\n        node.x = 100 / (i + 1);\n        node.y = 100 / (i + 1);\n      }\n    });\n  };\n\n  ComboForce.prototype.getComboMap = function () {\n    var self = this;\n    var nodeMap = self.nodeMap;\n    var nodeIdxMap = self.nodeIdxMap;\n    var comboTrees = self.comboTrees;\n    var oriComboMap = self.oriComboMap;\n    var comboMap = {};\n    (comboTrees || []).forEach(function (ctree) {\n      var treeChildren = [];\n      traverseTreeUp(ctree, function (treeNode) {\n        if (treeNode.itemType === 'node') return true; // skip it\n\n        if (!oriComboMap[treeNode.id]) return true; // means it is hidden, skip it\n\n        if (comboMap[treeNode.id] === undefined) {\n          var combo = {\n            name: treeNode.id,\n            cx: 0,\n            cy: 0,\n            count: 0,\n            depth: self.oriComboMap[treeNode.id].depth,\n            children: []\n          };\n          comboMap[treeNode.id] = combo;\n        }\n\n        var children = treeNode.children;\n\n        if (children) {\n          children.forEach(function (child) {\n            if (!comboMap[child.id] && !nodeMap[child.id]) return true; // means it is hidden\n\n            treeChildren.push(child);\n          });\n        }\n\n        var c = comboMap[treeNode.id];\n        c.cx = 0;\n        c.cy = 0; // In order to layout the empty combo, add a virtual node to it\n\n        if (treeChildren.length === 0) {\n          c.empty = true;\n          var oriCombo = oriComboMap[treeNode.id];\n          var idx = Object.keys(nodeMap).length;\n          var virtualNodeId = treeNode.id + \"-visual-child-\" + idx;\n          var vnode = {\n            id: virtualNodeId,\n            x: oriCombo.x,\n            y: oriCombo.y,\n            depth: c.depth + 1,\n            itemType: 'node'\n          };\n          self.nodes.push(vnode);\n          nodeMap[virtualNodeId] = vnode;\n          nodeIdxMap[virtualNodeId] = idx;\n          c.cx = oriCombo.x;\n          c.cy = oriCombo.y;\n          treeChildren.push(vnode);\n        }\n\n        treeChildren.forEach(function (child) {\n          c.count++;\n\n          if (child.itemType !== 'node') {\n            var childCombo = comboMap[child.id];\n            if (isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          var node = nodeMap[child.id]; // means the node is hidden, skip it\n\n          if (!node) return;\n\n          if (isNumber(node.x)) {\n            c.cx += node.x;\n          }\n\n          if (isNumber(node.y)) {\n            c.cy += node.y;\n          }\n        });\n        c.cx /= c.count;\n        c.cy /= c.count;\n        c.children = treeChildren;\n        return true;\n      });\n    });\n    return comboMap;\n  };\n\n  ComboForce.prototype.applyComboCenterForce = function (displacements) {\n    var self = this;\n    var gravity = self.gravity;\n    var comboGravity = self.comboGravity || gravity;\n    var alpha = this.alpha;\n    var comboTrees = self.comboTrees;\n    var nodeIdxMap = self.nodeIdxMap;\n    var nodeMap = self.nodeMap;\n    var comboMap = self.comboMap;\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (treeNode) {\n        if (treeNode.itemType === 'node') return true; // skip it\n\n        var combo = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!combo) return true;\n        var c = comboMap[treeNode.id]; // higher depth the combo, larger the gravity\n\n        var gravityScale = (c.depth + 1) * 0.5; // apply combo center force for all the descend nodes in this combo\n        // and update the center position and count for this combo\n\n        var comboX = c.cx;\n        var comboY = c.cy;\n        c.cx = 0;\n        c.cy = 0;\n        c.children.forEach(function (child) {\n          if (child.itemType !== 'node') {\n            var childCombo = comboMap[child.id];\n            if (childCombo && isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (childCombo && isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          var node = nodeMap[child.id];\n          var vecX = node.x - comboX || 0.005;\n          var vecY = node.y - comboY || 0.005;\n          var l = Math.sqrt(vecX * vecX + vecY * vecY);\n          var childIdx = nodeIdxMap[node.id];\n          var params = comboGravity * alpha / l * gravityScale;\n          displacements[childIdx].x -= vecX * params;\n          displacements[childIdx].y -= vecY * params;\n          if (isNumber(node.x)) c.cx += node.x;\n          if (isNumber(node.y)) c.cy += node.y;\n        });\n        c.cx /= c.count;\n        c.cy /= c.count;\n        return true;\n      });\n    });\n  };\n\n  ComboForce.prototype.applyCalculate = function (displacements) {\n    var self = this;\n    var comboMap = self.comboMap;\n    var nodes = self.nodes; // store the vx, vy, and distance to reduce dulplicate calculation\n\n    var vecMap = {};\n    nodes.forEach(function (v, i) {\n      nodes.forEach(function (u, j) {\n        if (i < j) return;\n        var vx = v.x - u.x || 0.005;\n        var vy = v.y - u.y || 0.005;\n        var vl2 = vx * vx + vy * vy;\n        var vl = Math.sqrt(vl2);\n        if (vl2 < 1) vl2 = vl;\n        vecMap[v.id + \"-\" + u.id] = {\n          vx: vx,\n          vy: vy,\n          vl2: vl2,\n          vl: vl\n        };\n        vecMap[u.id + \"-\" + v.id] = {\n          vx: -vx,\n          vy: -vy,\n          vl2: vl2,\n          vl: vl\n        };\n      });\n    }); // get the sizes of the combos\n\n    self.updateComboSizes(comboMap);\n    self.calRepulsive(displacements, vecMap);\n    self.calAttractive(displacements, vecMap);\n    var preventComboOverlap = self.preventComboOverlap;\n    if (preventComboOverlap) self.comboNonOverlapping(displacements, comboMap);\n  };\n  /**\n   * Update the sizes of the combos according to their children\n   * Used for combos nonoverlap, but not re-render the combo shapes\n   */\n\n\n  ComboForce.prototype.updateComboSizes = function (comboMap) {\n    var self = this;\n    var comboTrees = self.comboTrees;\n    var nodeMap = self.nodeMap;\n    var nodeSize = self.nodeSize;\n    var comboSpacing = self.comboSpacing;\n    var comboPadding = self.comboPadding;\n    (comboTrees || []).forEach(function (ctree) {\n      var treeChildren = [];\n      traverseTreeUp(ctree, function (treeNode) {\n        if (treeNode.itemType === 'node') return true; // skip it\n\n        var c = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!c) return;\n        var children = treeNode.children;\n\n        if (children) {\n          children.forEach(function (child) {\n            // means the combo is hidden.\n            if (!comboMap[child.id] && !nodeMap[child.id]) return;\n            treeChildren.push(child);\n          });\n        }\n\n        c.minX = Infinity;\n        c.minY = Infinity;\n        c.maxX = -Infinity;\n        c.maxY = -Infinity;\n        treeChildren.forEach(function (child) {\n          if (child.itemType !== 'node') return true; // skip it\n\n          var node = nodeMap[child.id];\n          if (!node) return true; // means it is hidden\n\n          var r = nodeSize(node);\n          var nodeMinX = node.x - r;\n          var nodeMinY = node.y - r;\n          var nodeMaxX = node.x + r;\n          var nodeMaxY = node.y + r;\n          if (c.minX > nodeMinX) c.minX = nodeMinX;\n          if (c.minY > nodeMinY) c.minY = nodeMinY;\n          if (c.maxX < nodeMaxX) c.maxX = nodeMaxX;\n          if (c.maxY < nodeMaxY) c.maxY = nodeMaxY;\n        });\n        var minSize = self.oriComboMap[treeNode.id].size || Global.defaultCombo.size;\n        if (isArray(minSize)) minSize = minSize[0];\n        var maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n        c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n        return true;\n      });\n    });\n  };\n  /**\n   * prevent the overlappings among combos\n   */\n\n\n  ComboForce.prototype.comboNonOverlapping = function (displacements, comboMap) {\n    var self = this;\n    var comboTree = self.comboTree;\n    var comboCollideStrength = self.comboCollideStrength;\n    var nodeIdxMap = self.nodeIdxMap;\n    var nodeMap = self.nodeMap;\n    traverseTreeUp(comboTree, function (treeNode) {\n      if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== 'comboTreeRoot') return; // means it is hidden\n\n      var children = treeNode.children; // 同个子树下的子 combo 间两两对比\n\n      if (children && children.length > 1) {\n        children.forEach(function (v, i) {\n          if (v.itemType === 'node') return; // skip it\n\n          var cv = comboMap[v.id];\n          if (!cv) return; // means it is hidden, skip it\n\n          children.forEach(function (u, j) {\n            if (i <= j) return;\n            if (u.itemType === 'node') return; // skip it\n\n            var cu = comboMap[u.id];\n            if (!cu) return; // means it is hidden, skip it\n\n            var vx = cv.cx - cu.cx || 0.005;\n            var vy = cv.cy - cu.cy || 0.005;\n            var l = vx * vx + vy * vy;\n            var rv = cv.r;\n            var ru = cu.r;\n            var r = rv + ru;\n            var ru2 = ru * ru;\n            var rv2 = rv * rv; // overlapping\n\n            if (l < r * r) {\n              var vnodes = v.children;\n              if (!vnodes || vnodes.length === 0) return; // skip it\n\n              var unodes_1 = u.children;\n              if (!unodes_1 || unodes_1.length === 0) return; // skip it\n\n              var sqrtl = Math.sqrt(l);\n              var ll = (r - sqrtl) / sqrtl * comboCollideStrength;\n              var xl_1 = vx * ll;\n              var yl_1 = vy * ll;\n              var rratio_1 = ru2 / (rv2 + ru2);\n              var irratio_1 = 1 - rratio_1; // 两兄弟 combo 的子节点上施加斥力\n\n              vnodes.forEach(function (vn) {\n                if (vn.itemType !== 'node') return; // skip it\n\n                if (!nodeMap[vn.id]) return; // means it is hidden, skip it\n\n                var vindex = nodeIdxMap[vn.id];\n                unodes_1.forEach(function (un) {\n                  if (un.itemType !== 'node') return;\n                  if (!nodeMap[un.id]) return; // means it is hidden, skip it\n\n                  var uindex = nodeIdxMap[un.id];\n                  displacements[vindex].x += xl_1 * rratio_1;\n                  displacements[vindex].y += yl_1 * rratio_1;\n                  displacements[uindex].x -= xl_1 * irratio_1;\n                  displacements[uindex].y -= yl_1 * irratio_1;\n                });\n              });\n            }\n          });\n        });\n      }\n\n      return true;\n    });\n  };\n  /**\n   * Calculate the repulsive force between each node pair\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  ComboForce.prototype.calRepulsive = function (displacements, vecMap) {\n    var self = this;\n    var nodes = self.nodes;\n    var max = self.width * self.optimizeRangeFactor;\n    var nodeStrength = self.nodeStrength;\n    var alpha = self.alpha;\n    var nodeCollideStrength = self.nodeCollideStrength;\n    var preventNodeOverlap = self.preventNodeOverlap;\n    var nodeSizeFunc = self.nodeSize;\n    var nodeSpacingFunc = self.nodeSpacing;\n    var scale = self.depthRepulsiveForceScale;\n    var center = self.center;\n    nodes.forEach(function (v, i) {\n      if (!v.x || !v.y) return; // center gravity\n\n      if (center) {\n        var gravity = self.gravity;\n        var vecX = v.x - center[0] || 0.005;\n        var vecY = v.y - center[1] || 0.005;\n        var l = Math.sqrt(vecX * vecX + vecY * vecY);\n        displacements[i].x -= vecX * gravity * alpha / l;\n        displacements[i].y -= vecY * gravity * alpha / l;\n      }\n\n      nodes.forEach(function (u, j) {\n        if (i === j) {\n          return;\n        }\n\n        if (!u.x || !u.y) return;\n        var _a = vecMap[v.id + \"-\" + u.id],\n            vl2 = _a.vl2,\n            vl = _a.vl;\n        if (vl > max) return;\n        var _b = vecMap[v.id + \"-\" + u.id],\n            vx = _b.vx,\n            vy = _b.vy;\n        var depthDiff = Math.abs(u.depth - v.depth) + 1 || 1;\n        if (u.comboId !== v.comboId) depthDiff++;\n        var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n        var params = nodeStrength(u) * alpha / vl2 * depthParam;\n        displacements[i].x += vx * params;\n        displacements[i].y += vy * params; // prevent node overlappings\n\n        if (i < j && preventNodeOverlap) {\n          var ri = nodeSizeFunc(v) + nodeSpacingFunc(v);\n          var rj = nodeSizeFunc(u) + nodeSpacingFunc(u);\n          var r = ri + rj;\n\n          if (vl2 < r * r) {\n            var ll = (r - vl) / vl * nodeCollideStrength;\n            var rj2 = rj * rj;\n            var rratio = rj2 / (ri * ri + rj2);\n            var xl = vx * ll;\n            var yl = vy * ll;\n            displacements[i].x += xl * rratio;\n            displacements[i].y += yl * rratio;\n            rratio = 1 - rratio;\n            displacements[j].x -= xl * rratio;\n            displacements[j].y -= yl * rratio;\n          }\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the attractive force between the node pair with edge\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  ComboForce.prototype.calAttractive = function (displacements, vecMap) {\n    var self = this;\n    var edges = self.edges;\n    var linkDistance = self.linkDistance;\n    var alpha = self.alpha;\n    var edgeStrength = self.edgeStrength;\n    var bias = self.bias;\n    var scale = self.depthAttractiveForceScale;\n    edges.forEach(function (e, i) {\n      if (!e.source || !e.target || e.source === e.target) return;\n      var uIndex = self.nodeIdxMap[e.source];\n      var vIndex = self.nodeIdxMap[e.target];\n      var u = self.nodeMap[e.source];\n      var v = self.nodeMap[e.target];\n      var depthDiff = Math.abs(u.depth - v.depth);\n\n      if (u.comboId === v.comboId) {\n        depthDiff = depthDiff / 2;\n      }\n\n      var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n\n      if (u.comboId !== v.comboId && depthParam === 1) {\n        depthParam = scale / 2;\n      } else if (u.comboId === v.comboId) {\n        depthParam = 2;\n      }\n\n      if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) return;\n      var _a = vecMap[e.target + \"-\" + e.source],\n          vl = _a.vl,\n          vx = _a.vx,\n          vy = _a.vy;\n      var l = (vl - linkDistance(e)) / vl * alpha * edgeStrength(e) * depthParam;\n      var vecX = vx * l;\n      var vecY = vy * l;\n      var b = bias[i];\n      displacements[vIndex].x -= vecX * b;\n      displacements[vIndex].y -= vecY * b;\n      displacements[uIndex].x += vecX * (1 - b);\n      displacements[uIndex].y += vecY * (1 - b);\n    });\n  };\n\n  return ComboForce;\n}(BaseLayout);\n\nexport default ComboForce;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/comboForce.js"],"names":["__extends","BaseLayout","isNumber","isArray","isFunction","traverseTreeUp","Global","ComboForce","_super","_this","apply","arguments","center","maxIteration","gravity","comboGravity","linkDistance","alpha","alphaMin","alphaDecay","Math","pow","alphaTarget","velocityDecay","edgeStrength","nodeStrength","preventOverlap","preventNodeOverlap","preventComboOverlap","collideStrength","undefined","nodeCollideStrength","comboCollideStrength","optimizeRangeFactor","onTick","onLayoutEnd","depthAttractiveForceScale","depthRepulsiveForceScale","nodes","edges","combos","comboTrees","width","height","bias","nodeMap","oriComboMap","nodeIdxMap","comboMap","previousLayouted","prototype","getDefaultCfg","speed","nodeSpacing","comboSpacing","comboPadding","execute","self","comboTree","id","depth","children","length","x","y","initVals","run","window","innerWidth","innerHeight","initPos","_loop_1","i","displacements","forEach","_","j","applyCalculate","applyComboCenterForce","n","meanCenter","centerOffset","combo","mapped","empty","cx","cy","count","node","getComboMap","source","target","nodeSize","nodeSizeFunc","nodeSpacingFunc","d","size","res","larger","radius_1","radius_2","comboSpacingFunc","comboPaddingFunc","max","linkDistanceFunc","edgeStrengthFunc","nodeStrengthFunc","comboId","ctree","treeChildren","treeNode","itemType","name","child","push","c","oriCombo","idx","Object","keys","virtualNodeId","vnode","childCombo","gravityScale","comboX","comboY","vecX","vecY","l","sqrt","childIdx","params","vecMap","v","u","vx","vy","vl2","vl","updateComboSizes","calRepulsive","calAttractive","comboNonOverlapping","minX","Infinity","minY","maxX","maxY","r","nodeMinX","nodeMinY","nodeMaxX","nodeMaxY","minSize","defaultCombo","maxLength","cv","cu","rv","ru","ru2","rv2","vnodes","unodes_1","sqrtl","ll","xl_1","yl_1","rratio_1","irratio_1","vn","vindex","un","uindex","scale","_a","_b","depthDiff","abs","depthParam","ri","rj","rj2","rratio","xl","yl","e","uIndex","vIndex","b"],"mappings":"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","sourcesContent":["/**\n * @fileOverview Combo force layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport { BaseLayout } from './layout';\nimport { isNumber, isArray, isFunction } from '@antv/util';\nimport { traverseTreeUp } from '../util/graphic';\nimport Global from '../global';\n/**\n * force layout for graph with combos\n */\n\nvar ComboForce =\n/** @class */\nfunction (_super) {\n  __extends(ComboForce, _super);\n\n  function ComboForce() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 100;\n    /** 重力大小，影响图的紧凑程度 */\n\n    _this.gravity = 10;\n    /** 群组中心力大小 */\n\n    _this.comboGravity = 10;\n    /** 默认边长度 */\n\n    _this.linkDistance = 10;\n    /** 每次迭代位移的衰减相关参数 */\n\n    _this.alpha = 1;\n    _this.alphaMin = 0.001;\n    _this.alphaDecay = 1 - Math.pow(_this.alphaMin, 1 / 300);\n    _this.alphaTarget = 0;\n    /** 节点运动速度衰减参数 */\n\n    _this.velocityDecay = 0.6;\n    /** 边引力大小 */\n\n    _this.edgeStrength = 0.2;\n    /** 节点引力大小 */\n\n    _this.nodeStrength = 30;\n    /** 是否开启防止重叠 */\n\n    _this.preventOverlap = false;\n    /** 是否开启节点之间的防止重叠 */\n\n    _this.preventNodeOverlap = false;\n    /** 是否开启 Combo 之间的防止重叠 */\n\n    _this.preventComboOverlap = false;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.collideStrength = undefined;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.nodeCollideStrength = undefined;\n    /** 防止重叠的碰撞力大小 */\n\n    _this.comboCollideStrength = undefined;\n    /** 优化计算斥力的速度，两节点间距超过 optimizeRangeFactor * width 则不再计算斥力和重叠斥力 */\n\n    _this.optimizeRangeFactor = 1;\n    /** 每次迭代的回调函数 */\n\n    _this.onTick = function () {};\n    /** 每次迭代的回调函数 */\n\n\n    _this.onLayoutEnd = function () {};\n    /** 根据边两端节点层级差距的调整引力系数的因子，取值范围 [0, 1]。层级差距越大，引力越小 */\n\n\n    _this.depthAttractiveForceScale = 0.5;\n    /** 根据边两端节点层级差距的调整斥力系数的因子，取值范围 [1, Infinity]。层级差距越大，斥力越大 */\n\n    _this.depthRepulsiveForceScale = 2;\n    /** 内部计算参数 */\n\n    _this.nodes = [];\n    _this.edges = [];\n    _this.combos = [];\n    _this.comboTrees = [];\n    _this.width = 300;\n    _this.height = 300;\n    _this.bias = [];\n    _this.nodeMap = {};\n    _this.oriComboMap = {};\n    _this.nodeIdxMap = {};\n    _this.comboMap = {};\n    _this.previousLayouted = false;\n    return _this;\n  }\n\n  ComboForce.prototype.getDefaultCfg = function () {\n    return {\n      maxIteration: 100,\n      center: [0, 0],\n      gravity: 10,\n      speed: 1,\n      comboGravity: 30,\n      preventOverlap: false,\n      preventComboOverlap: true,\n      preventNodeOverlap: true,\n      nodeSpacing: undefined,\n      collideStrength: undefined,\n      nodeCollideStrength: 0.5,\n      comboCollideStrength: 0.5,\n      comboSpacing: 20,\n      comboPadding: 10,\n      edgeStrength: 0.2,\n      nodeStrength: 30,\n      linkDistance: 10\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ComboForce.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var center = self.center;\n    self.comboTree = {\n      id: 'comboTreeRoot',\n      depth: -1,\n      children: self.comboTrees\n    };\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    self.initVals(); // layout\n\n    self.run();\n    self.onLayoutEnd();\n  };\n\n  ComboForce.prototype.run = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var maxIteration = self.previousLayouted ? self.maxIteration / 5 : self.maxIteration;\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    var center = self.center;\n    var velocityDecay = self.velocityDecay; // init the positions to make the nodes with same combo gather around the combo\n\n    var comboMap = self.comboMap;\n    if (!self.previousLayouted) self.initPos(comboMap);\n\n    var _loop_1 = function _loop_1(i) {\n      var displacements = [];\n      nodes.forEach(function (_, j) {\n        displacements[j] = {\n          x: 0,\n          y: 0\n        };\n      });\n      self.applyCalculate(displacements); // gravity for combos\n\n      self.applyComboCenterForce(displacements); // move\n\n      nodes.forEach(function (n, j) {\n        if (!isNumber(n.x) || !isNumber(n.y)) return;\n        n.x += displacements[j].x * velocityDecay;\n        n.y += displacements[j].y * velocityDecay;\n      });\n      self.alpha += (self.alphaTarget - self.alpha) * self.alphaDecay;\n      self.onTick();\n    }; // iterate\n\n\n    for (var i = 0; i < maxIteration; i++) {\n      _loop_1(i);\n    } // move to center\n\n\n    var meanCenter = [0, 0];\n    nodes.forEach(function (n) {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      meanCenter[0] += n.x;\n      meanCenter[1] += n.y;\n    });\n    meanCenter[0] /= nodes.length;\n    meanCenter[1] /= nodes.length;\n    var centerOffset = [center[0] - meanCenter[0], center[1] - meanCenter[1]];\n    nodes.forEach(function (n, j) {\n      if (!isNumber(n.x) || !isNumber(n.y)) return;\n      n.x += centerOffset[0];\n      n.y += centerOffset[1];\n    }); // arrange the empty combo\n\n    self.combos.forEach(function (combo) {\n      var mapped = comboMap[combo.id];\n\n      if (mapped && mapped.empty) {\n        combo.x = mapped.cx || combo.x;\n        combo.y = mapped.cy || combo.y;\n      }\n    });\n    self.previousLayouted = true;\n  };\n\n  ComboForce.prototype.initVals = function () {\n    var self = this;\n    var edges = self.edges;\n    var nodes = self.nodes;\n    var combos = self.combos;\n    var count = {};\n    var nodeMap = {};\n    var nodeIdxMap = {};\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    self.nodeIdxMap = nodeIdxMap;\n    var oriComboMap = {};\n    combos.forEach(function (combo) {\n      oriComboMap[combo.id] = combo;\n    });\n    self.oriComboMap = oriComboMap;\n    self.comboMap = self.getComboMap();\n    var preventOverlap = self.preventOverlap;\n    self.preventComboOverlap = self.preventComboOverlap || preventOverlap;\n    self.preventNodeOverlap = self.preventNodeOverlap || preventOverlap;\n    var collideStrength = self.collideStrength;\n\n    if (collideStrength) {\n      self.comboCollideStrength = collideStrength;\n      self.nodeCollideStrength = collideStrength;\n    } // get edge bias\n\n\n    for (var i = 0; i < edges.length; ++i) {\n      if (count[edges[i].source]) count[edges[i].source]++;else count[edges[i].source] = 1;\n      if (count[edges[i].target]) count[edges[i].target]++;else count[edges[i].target] = 1;\n    }\n\n    var bias = [];\n\n    for (var i = 0; i < edges.length; ++i) {\n      bias[i] = count[edges[i].source] / (count[edges[i].source] + count[edges[i].target]);\n    }\n\n    this.bias = bias;\n    var nodeSize = self.nodeSize;\n    var nodeSpacing = self.nodeSpacing;\n    var nodeSizeFunc;\n    var nodeSpacingFunc; // nodeSpacing to function\n\n    if (isNumber(nodeSpacing)) {\n      nodeSpacingFunc = function nodeSpacingFunc() {\n        return nodeSpacing;\n      };\n    } else if (isFunction(nodeSpacing)) {\n      nodeSpacingFunc = nodeSpacing;\n    } else {\n      nodeSpacingFunc = function nodeSpacingFunc() {\n        return 0;\n      };\n    }\n\n    this.nodeSpacing = nodeSpacingFunc; // nodeSize to function\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        if (d.size) {\n          if (isArray(d.size)) {\n            var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n            return res / 2;\n          }\n\n          return d.size / 2;\n        }\n\n        return 10;\n      };\n    } else if (isFunction(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return nodeSize(d);\n      };\n    } else if (isArray(nodeSize)) {\n      var larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n      var radius_1 = larger / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_1;\n      };\n    } else {\n      // number type\n      var radius_2 = nodeSize / 2;\n\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        return radius_2;\n      };\n    }\n\n    this.nodeSize = nodeSizeFunc; // comboSpacing to function\n\n    var comboSpacing = self.comboSpacing;\n    var comboSpacingFunc;\n\n    if (isNumber(comboSpacing)) {\n      comboSpacingFunc = function comboSpacingFunc() {\n        return comboSpacing;\n      };\n    } else if (isFunction(comboSpacing)) {\n      comboSpacingFunc = comboSpacing;\n    } else {\n      // null type\n      comboSpacingFunc = function comboSpacingFunc() {\n        return 0;\n      };\n    }\n\n    this.comboSpacing = comboSpacingFunc; // comboPadding to function\n\n    var comboPadding = self.comboPadding;\n    var comboPaddingFunc;\n\n    if (isNumber(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return comboPadding;\n      };\n    } else if (isArray(comboPadding)) {\n      comboPaddingFunc = function comboPaddingFunc() {\n        return Math.max.apply(null, comboPadding);\n      };\n    } else if (isFunction(comboPadding)) {\n      comboPaddingFunc = comboPadding;\n    } else {\n      // null type\n      comboPaddingFunc = function comboPaddingFunc() {\n        return 0;\n      };\n    }\n\n    this.comboPadding = comboPaddingFunc; // linkDistance to function\n\n    var linkDistance = this.linkDistance;\n    var linkDistanceFunc;\n\n    if (!linkDistance) {\n      linkDistance = 10;\n    }\n\n    if (isNumber(linkDistance)) {\n      linkDistanceFunc = function linkDistanceFunc(d) {\n        return linkDistance;\n      };\n    } else {\n      linkDistanceFunc = linkDistance;\n    }\n\n    this.linkDistance = linkDistanceFunc; // linkStrength to function\n\n    var edgeStrength = this.edgeStrength;\n    var edgeStrengthFunc;\n\n    if (!edgeStrength) {\n      edgeStrength = 1;\n    }\n\n    if (isNumber(edgeStrength)) {\n      edgeStrengthFunc = function edgeStrengthFunc(d) {\n        return edgeStrength;\n      };\n    } else {\n      edgeStrengthFunc = edgeStrength;\n    }\n\n    this.edgeStrength = edgeStrengthFunc; // nodeStrength to function\n\n    var nodeStrength = this.nodeStrength;\n    var nodeStrengthFunc;\n\n    if (!nodeStrength) {\n      nodeStrength = 30;\n    }\n\n    if (isNumber(nodeStrength)) {\n      nodeStrengthFunc = function nodeStrengthFunc(d) {\n        return nodeStrength;\n      };\n    } else {\n      nodeStrengthFunc = nodeStrength;\n    }\n\n    this.nodeStrength = nodeStrengthFunc;\n  };\n\n  ComboForce.prototype.initPos = function (comboMap) {\n    var self = this;\n    var nodes = self.nodes;\n    nodes.forEach(function (node, i) {\n      if (node.comboId) {\n        var combo = comboMap[node.comboId];\n        node.x = combo.cx + 100 / (i + 1);\n        node.y = combo.cy + 100 / (i + 1);\n      } else {\n        node.x = 100 / (i + 1);\n        node.y = 100 / (i + 1);\n      }\n    });\n  };\n\n  ComboForce.prototype.getComboMap = function () {\n    var self = this;\n    var nodeMap = self.nodeMap;\n    var nodeIdxMap = self.nodeIdxMap;\n    var comboTrees = self.comboTrees;\n    var oriComboMap = self.oriComboMap;\n    var comboMap = {};\n    (comboTrees || []).forEach(function (ctree) {\n      var treeChildren = [];\n      traverseTreeUp(ctree, function (treeNode) {\n        if (treeNode.itemType === 'node') return true; // skip it\n\n        if (!oriComboMap[treeNode.id]) return true; // means it is hidden, skip it\n\n        if (comboMap[treeNode.id] === undefined) {\n          var combo = {\n            name: treeNode.id,\n            cx: 0,\n            cy: 0,\n            count: 0,\n            depth: self.oriComboMap[treeNode.id].depth,\n            children: []\n          };\n          comboMap[treeNode.id] = combo;\n        }\n\n        var children = treeNode.children;\n\n        if (children) {\n          children.forEach(function (child) {\n            if (!comboMap[child.id] && !nodeMap[child.id]) return true; // means it is hidden\n\n            treeChildren.push(child);\n          });\n        }\n\n        var c = comboMap[treeNode.id];\n        c.cx = 0;\n        c.cy = 0; // In order to layout the empty combo, add a virtual node to it\n\n        if (treeChildren.length === 0) {\n          c.empty = true;\n          var oriCombo = oriComboMap[treeNode.id];\n          var idx = Object.keys(nodeMap).length;\n          var virtualNodeId = treeNode.id + \"-visual-child-\" + idx;\n          var vnode = {\n            id: virtualNodeId,\n            x: oriCombo.x,\n            y: oriCombo.y,\n            depth: c.depth + 1,\n            itemType: 'node'\n          };\n          self.nodes.push(vnode);\n          nodeMap[virtualNodeId] = vnode;\n          nodeIdxMap[virtualNodeId] = idx;\n          c.cx = oriCombo.x;\n          c.cy = oriCombo.y;\n          treeChildren.push(vnode);\n        }\n\n        treeChildren.forEach(function (child) {\n          c.count++;\n\n          if (child.itemType !== 'node') {\n            var childCombo = comboMap[child.id];\n            if (isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          var node = nodeMap[child.id]; // means the node is hidden, skip it\n\n          if (!node) return;\n\n          if (isNumber(node.x)) {\n            c.cx += node.x;\n          }\n\n          if (isNumber(node.y)) {\n            c.cy += node.y;\n          }\n        });\n        c.cx /= c.count;\n        c.cy /= c.count;\n        c.children = treeChildren;\n        return true;\n      });\n    });\n    return comboMap;\n  };\n\n  ComboForce.prototype.applyComboCenterForce = function (displacements) {\n    var self = this;\n    var gravity = self.gravity;\n    var comboGravity = self.comboGravity || gravity;\n    var alpha = this.alpha;\n    var comboTrees = self.comboTrees;\n    var nodeIdxMap = self.nodeIdxMap;\n    var nodeMap = self.nodeMap;\n    var comboMap = self.comboMap;\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (treeNode) {\n        if (treeNode.itemType === 'node') return true; // skip it\n\n        var combo = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!combo) return true;\n        var c = comboMap[treeNode.id]; // higher depth the combo, larger the gravity\n\n        var gravityScale = (c.depth + 1) * 0.5; // apply combo center force for all the descend nodes in this combo\n        // and update the center position and count for this combo\n\n        var comboX = c.cx;\n        var comboY = c.cy;\n        c.cx = 0;\n        c.cy = 0;\n        c.children.forEach(function (child) {\n          if (child.itemType !== 'node') {\n            var childCombo = comboMap[child.id];\n            if (childCombo && isNumber(childCombo.cx)) c.cx += childCombo.cx;\n            if (childCombo && isNumber(childCombo.cy)) c.cy += childCombo.cy;\n            return;\n          }\n\n          var node = nodeMap[child.id];\n          var vecX = node.x - comboX || 0.005;\n          var vecY = node.y - comboY || 0.005;\n          var l = Math.sqrt(vecX * vecX + vecY * vecY);\n          var childIdx = nodeIdxMap[node.id];\n          var params = comboGravity * alpha / l * gravityScale;\n          displacements[childIdx].x -= vecX * params;\n          displacements[childIdx].y -= vecY * params;\n          if (isNumber(node.x)) c.cx += node.x;\n          if (isNumber(node.y)) c.cy += node.y;\n        });\n        c.cx /= c.count;\n        c.cy /= c.count;\n        return true;\n      });\n    });\n  };\n\n  ComboForce.prototype.applyCalculate = function (displacements) {\n    var self = this;\n    var comboMap = self.comboMap;\n    var nodes = self.nodes; // store the vx, vy, and distance to reduce dulplicate calculation\n\n    var vecMap = {};\n    nodes.forEach(function (v, i) {\n      nodes.forEach(function (u, j) {\n        if (i < j) return;\n        var vx = v.x - u.x || 0.005;\n        var vy = v.y - u.y || 0.005;\n        var vl2 = vx * vx + vy * vy;\n        var vl = Math.sqrt(vl2);\n        if (vl2 < 1) vl2 = vl;\n        vecMap[v.id + \"-\" + u.id] = {\n          vx: vx,\n          vy: vy,\n          vl2: vl2,\n          vl: vl\n        };\n        vecMap[u.id + \"-\" + v.id] = {\n          vx: -vx,\n          vy: -vy,\n          vl2: vl2,\n          vl: vl\n        };\n      });\n    }); // get the sizes of the combos\n\n    self.updateComboSizes(comboMap);\n    self.calRepulsive(displacements, vecMap);\n    self.calAttractive(displacements, vecMap);\n    var preventComboOverlap = self.preventComboOverlap;\n    if (preventComboOverlap) self.comboNonOverlapping(displacements, comboMap);\n  };\n  /**\n   * Update the sizes of the combos according to their children\n   * Used for combos nonoverlap, but not re-render the combo shapes\n   */\n\n\n  ComboForce.prototype.updateComboSizes = function (comboMap) {\n    var self = this;\n    var comboTrees = self.comboTrees;\n    var nodeMap = self.nodeMap;\n    var nodeSize = self.nodeSize;\n    var comboSpacing = self.comboSpacing;\n    var comboPadding = self.comboPadding;\n    (comboTrees || []).forEach(function (ctree) {\n      var treeChildren = [];\n      traverseTreeUp(ctree, function (treeNode) {\n        if (treeNode.itemType === 'node') return true; // skip it\n\n        var c = comboMap[treeNode.id]; // means the combo is hidden, skip it\n\n        if (!c) return;\n        var children = treeNode.children;\n\n        if (children) {\n          children.forEach(function (child) {\n            // means the combo is hidden.\n            if (!comboMap[child.id] && !nodeMap[child.id]) return;\n            treeChildren.push(child);\n          });\n        }\n\n        c.minX = Infinity;\n        c.minY = Infinity;\n        c.maxX = -Infinity;\n        c.maxY = -Infinity;\n        treeChildren.forEach(function (child) {\n          if (child.itemType !== 'node') return true; // skip it\n\n          var node = nodeMap[child.id];\n          if (!node) return true; // means it is hidden\n\n          var r = nodeSize(node);\n          var nodeMinX = node.x - r;\n          var nodeMinY = node.y - r;\n          var nodeMaxX = node.x + r;\n          var nodeMaxY = node.y + r;\n          if (c.minX > nodeMinX) c.minX = nodeMinX;\n          if (c.minY > nodeMinY) c.minY = nodeMinY;\n          if (c.maxX < nodeMaxX) c.maxX = nodeMaxX;\n          if (c.maxY < nodeMaxY) c.maxY = nodeMaxY;\n        });\n        var minSize = self.oriComboMap[treeNode.id].size || Global.defaultCombo.size;\n        if (isArray(minSize)) minSize = minSize[0];\n        var maxLength = Math.max(c.maxX - c.minX, c.maxY - c.minY, minSize);\n        c.r = maxLength / 2 + comboSpacing(c) / 2 + comboPadding(c);\n        return true;\n      });\n    });\n  };\n  /**\n   * prevent the overlappings among combos\n   */\n\n\n  ComboForce.prototype.comboNonOverlapping = function (displacements, comboMap) {\n    var self = this;\n    var comboTree = self.comboTree;\n    var comboCollideStrength = self.comboCollideStrength;\n    var nodeIdxMap = self.nodeIdxMap;\n    var nodeMap = self.nodeMap;\n    traverseTreeUp(comboTree, function (treeNode) {\n      if (!comboMap[treeNode.id] && !nodeMap[treeNode.id] && treeNode.id !== 'comboTreeRoot') return; // means it is hidden\n\n      var children = treeNode.children; // 同个子树下的子 combo 间两两对比\n\n      if (children && children.length > 1) {\n        children.forEach(function (v, i) {\n          if (v.itemType === 'node') return; // skip it\n\n          var cv = comboMap[v.id];\n          if (!cv) return; // means it is hidden, skip it\n\n          children.forEach(function (u, j) {\n            if (i <= j) return;\n            if (u.itemType === 'node') return; // skip it\n\n            var cu = comboMap[u.id];\n            if (!cu) return; // means it is hidden, skip it\n\n            var vx = cv.cx - cu.cx || 0.005;\n            var vy = cv.cy - cu.cy || 0.005;\n            var l = vx * vx + vy * vy;\n            var rv = cv.r;\n            var ru = cu.r;\n            var r = rv + ru;\n            var ru2 = ru * ru;\n            var rv2 = rv * rv; // overlapping\n\n            if (l < r * r) {\n              var vnodes = v.children;\n              if (!vnodes || vnodes.length === 0) return; // skip it\n\n              var unodes_1 = u.children;\n              if (!unodes_1 || unodes_1.length === 0) return; // skip it\n\n              var sqrtl = Math.sqrt(l);\n              var ll = (r - sqrtl) / sqrtl * comboCollideStrength;\n              var xl_1 = vx * ll;\n              var yl_1 = vy * ll;\n              var rratio_1 = ru2 / (rv2 + ru2);\n              var irratio_1 = 1 - rratio_1; // 两兄弟 combo 的子节点上施加斥力\n\n              vnodes.forEach(function (vn) {\n                if (vn.itemType !== 'node') return; // skip it\n\n                if (!nodeMap[vn.id]) return; // means it is hidden, skip it\n\n                var vindex = nodeIdxMap[vn.id];\n                unodes_1.forEach(function (un) {\n                  if (un.itemType !== 'node') return;\n                  if (!nodeMap[un.id]) return; // means it is hidden, skip it\n\n                  var uindex = nodeIdxMap[un.id];\n                  displacements[vindex].x += xl_1 * rratio_1;\n                  displacements[vindex].y += yl_1 * rratio_1;\n                  displacements[uindex].x -= xl_1 * irratio_1;\n                  displacements[uindex].y -= yl_1 * irratio_1;\n                });\n              });\n            }\n          });\n        });\n      }\n\n      return true;\n    });\n  };\n  /**\n   * Calculate the repulsive force between each node pair\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  ComboForce.prototype.calRepulsive = function (displacements, vecMap) {\n    var self = this;\n    var nodes = self.nodes;\n    var max = self.width * self.optimizeRangeFactor;\n    var nodeStrength = self.nodeStrength;\n    var alpha = self.alpha;\n    var nodeCollideStrength = self.nodeCollideStrength;\n    var preventNodeOverlap = self.preventNodeOverlap;\n    var nodeSizeFunc = self.nodeSize;\n    var nodeSpacingFunc = self.nodeSpacing;\n    var scale = self.depthRepulsiveForceScale;\n    var center = self.center;\n    nodes.forEach(function (v, i) {\n      if (!v.x || !v.y) return; // center gravity\n\n      if (center) {\n        var gravity = self.gravity;\n        var vecX = v.x - center[0] || 0.005;\n        var vecY = v.y - center[1] || 0.005;\n        var l = Math.sqrt(vecX * vecX + vecY * vecY);\n        displacements[i].x -= vecX * gravity * alpha / l;\n        displacements[i].y -= vecY * gravity * alpha / l;\n      }\n\n      nodes.forEach(function (u, j) {\n        if (i === j) {\n          return;\n        }\n\n        if (!u.x || !u.y) return;\n        var _a = vecMap[v.id + \"-\" + u.id],\n            vl2 = _a.vl2,\n            vl = _a.vl;\n        if (vl > max) return;\n        var _b = vecMap[v.id + \"-\" + u.id],\n            vx = _b.vx,\n            vy = _b.vy;\n        var depthDiff = Math.abs(u.depth - v.depth) + 1 || 1;\n        if (u.comboId !== v.comboId) depthDiff++;\n        var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n        var params = nodeStrength(u) * alpha / vl2 * depthParam;\n        displacements[i].x += vx * params;\n        displacements[i].y += vy * params; // prevent node overlappings\n\n        if (i < j && preventNodeOverlap) {\n          var ri = nodeSizeFunc(v) + nodeSpacingFunc(v);\n          var rj = nodeSizeFunc(u) + nodeSpacingFunc(u);\n          var r = ri + rj;\n\n          if (vl2 < r * r) {\n            var ll = (r - vl) / vl * nodeCollideStrength;\n            var rj2 = rj * rj;\n            var rratio = rj2 / (ri * ri + rj2);\n            var xl = vx * ll;\n            var yl = vy * ll;\n            displacements[i].x += xl * rratio;\n            displacements[i].y += yl * rratio;\n            rratio = 1 - rratio;\n            displacements[j].x -= xl * rratio;\n            displacements[j].y -= yl * rratio;\n          }\n        }\n      });\n    });\n  };\n  /**\n   * Calculate the attractive force between the node pair with edge\n   * @param displacements The array stores the displacements for nodes\n   * @param vecMap The map stores vector between each node pair\n   */\n\n\n  ComboForce.prototype.calAttractive = function (displacements, vecMap) {\n    var self = this;\n    var edges = self.edges;\n    var linkDistance = self.linkDistance;\n    var alpha = self.alpha;\n    var edgeStrength = self.edgeStrength;\n    var bias = self.bias;\n    var scale = self.depthAttractiveForceScale;\n    edges.forEach(function (e, i) {\n      if (!e.source || !e.target || e.source === e.target) return;\n      var uIndex = self.nodeIdxMap[e.source];\n      var vIndex = self.nodeIdxMap[e.target];\n      var u = self.nodeMap[e.source];\n      var v = self.nodeMap[e.target];\n      var depthDiff = Math.abs(u.depth - v.depth);\n\n      if (u.comboId === v.comboId) {\n        depthDiff = depthDiff / 2;\n      }\n\n      var depthParam = depthDiff ? Math.pow(scale, depthDiff) : 1;\n\n      if (u.comboId !== v.comboId && depthParam === 1) {\n        depthParam = scale / 2;\n      } else if (u.comboId === v.comboId) {\n        depthParam = 2;\n      }\n\n      if (!isNumber(v.x) || !isNumber(u.x) || !isNumber(v.y) || !isNumber(u.y)) return;\n      var _a = vecMap[e.target + \"-\" + e.source],\n          vl = _a.vl,\n          vx = _a.vx,\n          vy = _a.vy;\n      var l = (vl - linkDistance(e)) / vl * alpha * edgeStrength(e) * depthParam;\n      var vecX = vx * l;\n      var vecY = vy * l;\n      var b = bias[i];\n      displacements[vIndex].x -= vecX * b;\n      displacements[vIndex].y -= vecY * b;\n      displacements[uIndex].x += vecX * (1 - b);\n      displacements[uIndex].y += vecY * (1 - b);\n    });\n  };\n\n  return ComboForce;\n}(BaseLayout);\n\nexport default ComboForce;"]},"metadata":{},"sourceType":"module"}