{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar model_1 = require(\"../util/model\");\n\nvar axisHelper_1 = require(\"./axisHelper\");\n\nvar inner = model_1.makeInner();\n\nfunction createAxisLabels(axis) {\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n\nexports.createAxisLabels = createAxisLabels;\n\nfunction createAxisTicks(axis, tickModel) {\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrUtil.map(axis.scale.getTicks(), function (tick) {\n      return tick.value;\n    })\n  };\n}\n\nexports.createAxisTicks = createAxisTicks;\n\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\n\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = axisHelper_1.getOptionCategoryInterval(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var labels;\n  var numericLabelInterval;\n\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  }\n\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\n\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = axisHelper_1.getOptionCategoryInterval(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var ticks;\n  var tickCategoryInterval;\n\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  } else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  }\n\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\n\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tick, idx) {\n      return {\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value\n      };\n    })\n  };\n}\n\nfunction getListCache(axis, prop) {\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\n\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\n\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\n\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n\nfunction calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var tickCount = ordinalScale.count();\n\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n\n  var step = 1;\n\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0;\n    var rect = textContain.getBoundingRect(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top');\n    width = rect.width * 1.3;\n    height = rect.height * 1.3;\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n\n  var dw = maxW / unitW;\n  var dh = maxH / unitH;\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount;\n\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  } else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtent0 = axisExtent[0];\n    cache.axisExtent1 = axisExtent[1];\n  }\n\n  return interval;\n}\n\nexports.calculateCategoryInterval = calculateCategoryInterval;\n\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\n\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = [];\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count();\n\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  }\n\n  var showAllLabel = axisHelper_1.shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  }\n\n  var tickValue = startTick;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue\n    });\n  }\n\n  return result;\n}\n\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/coord/axisTickLabelBuilder.js"],"names":["exports","__esModule","zrUtil","require","textContain","model_1","axisHelper_1","inner","makeInner","createAxisLabels","axis","type","makeCategoryLabels","makeRealNumberLabels","createAxisTicks","tickModel","makeCategoryTicks","ticks","map","scale","getTicks","tick","value","labelModel","getLabelModel","result","makeCategoryLabelsActually","get","isBlank","labels","labelCategoryInterval","labelsCache","getListCache","optionLabelInterval","getOptionCategoryInterval","listCacheGet","numericLabelInterval","isFunction","makeLabelsByCustomizedCategoryInterval","makeAutoCategoryInterval","makeLabelsByNumericCategoryInterval","listCacheSet","ticksCache","optionTickInterval","tickCategoryInterval","labelsResult","labelItem","tickValue","labelFormatter","makeLabelFormatter","idx","formattedLabel","rawLabel","getLabel","prop","cache","key","i","length","push","autoInterval","calculateCategoryInterval","params","fetchAutoCategoryIntervalCalculationParams","rotation","axisRotate","labelRotate","Math","PI","ordinalScale","ordinalExtent","getExtent","tickCount","count","step","max","floor","unitSpan","dataToCoord","unitW","abs","cos","unitH","sin","maxW","maxH","width","height","rect","getBoundingRect","font","dw","dh","isNaN","Infinity","interval","min","model","axisExtent","lastAutoInterval","lastTickCount","axisExtent0","axisExtent1","getRotate","isHorizontal","getFont","categoryInterval","onlyTick","startTick","round","ceil","showAllLabel","shouldShowAllLabels","includeMinLabel","includeMaxLabel","addItem","tickObj","each"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar textContain = require(\"zrender/lib/contain/text\");\n\nvar model_1 = require(\"../util/model\");\n\nvar axisHelper_1 = require(\"./axisHelper\");\n\nvar inner = model_1.makeInner();\n\nfunction createAxisLabels(axis) {\n  return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis);\n}\n\nexports.createAxisLabels = createAxisLabels;\n\nfunction createAxisTicks(axis, tickModel) {\n  return axis.type === 'category' ? makeCategoryTicks(axis, tickModel) : {\n    ticks: zrUtil.map(axis.scale.getTicks(), function (tick) {\n      return tick.value;\n    })\n  };\n}\n\nexports.createAxisTicks = createAxisTicks;\n\nfunction makeCategoryLabels(axis) {\n  var labelModel = axis.getLabelModel();\n  var result = makeCategoryLabelsActually(axis, labelModel);\n  return !labelModel.get('show') || axis.scale.isBlank() ? {\n    labels: [],\n    labelCategoryInterval: result.labelCategoryInterval\n  } : result;\n}\n\nfunction makeCategoryLabelsActually(axis, labelModel) {\n  var labelsCache = getListCache(axis, 'labels');\n  var optionLabelInterval = axisHelper_1.getOptionCategoryInterval(labelModel);\n  var result = listCacheGet(labelsCache, optionLabelInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var labels;\n  var numericLabelInterval;\n\n  if (zrUtil.isFunction(optionLabelInterval)) {\n    labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval);\n  } else {\n    numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval;\n    labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval);\n  }\n\n  return listCacheSet(labelsCache, optionLabelInterval, {\n    labels: labels,\n    labelCategoryInterval: numericLabelInterval\n  });\n}\n\nfunction makeCategoryTicks(axis, tickModel) {\n  var ticksCache = getListCache(axis, 'ticks');\n  var optionTickInterval = axisHelper_1.getOptionCategoryInterval(tickModel);\n  var result = listCacheGet(ticksCache, optionTickInterval);\n\n  if (result) {\n    return result;\n  }\n\n  var ticks;\n  var tickCategoryInterval;\n\n  if (!tickModel.get('show') || axis.scale.isBlank()) {\n    ticks = [];\n  }\n\n  if (zrUtil.isFunction(optionTickInterval)) {\n    ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true);\n  } else if (optionTickInterval === 'auto') {\n    var labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel());\n    tickCategoryInterval = labelsResult.labelCategoryInterval;\n    ticks = zrUtil.map(labelsResult.labels, function (labelItem) {\n      return labelItem.tickValue;\n    });\n  } else {\n    tickCategoryInterval = optionTickInterval;\n    ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true);\n  }\n\n  return listCacheSet(ticksCache, optionTickInterval, {\n    ticks: ticks,\n    tickCategoryInterval: tickCategoryInterval\n  });\n}\n\nfunction makeRealNumberLabels(axis) {\n  var ticks = axis.scale.getTicks();\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  return {\n    labels: zrUtil.map(ticks, function (tick, idx) {\n      return {\n        formattedLabel: labelFormatter(tick, idx),\n        rawLabel: axis.scale.getLabel(tick),\n        tickValue: tick.value\n      };\n    })\n  };\n}\n\nfunction getListCache(axis, prop) {\n  return inner(axis)[prop] || (inner(axis)[prop] = []);\n}\n\nfunction listCacheGet(cache, key) {\n  for (var i = 0; i < cache.length; i++) {\n    if (cache[i].key === key) {\n      return cache[i].value;\n    }\n  }\n}\n\nfunction listCacheSet(cache, key, value) {\n  cache.push({\n    key: key,\n    value: value\n  });\n  return value;\n}\n\nfunction makeAutoCategoryInterval(axis) {\n  var result = inner(axis).autoInterval;\n  return result != null ? result : inner(axis).autoInterval = axis.calculateCategoryInterval();\n}\n\nfunction calculateCategoryInterval(axis) {\n  var params = fetchAutoCategoryIntervalCalculationParams(axis);\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  var rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI;\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var tickCount = ordinalScale.count();\n\n  if (ordinalExtent[1] - ordinalExtent[0] < 1) {\n    return 0;\n  }\n\n  var step = 1;\n\n  if (tickCount > 40) {\n    step = Math.max(1, Math.floor(tickCount / 40));\n  }\n\n  var tickValue = ordinalExtent[0];\n  var unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue);\n  var unitW = Math.abs(unitSpan * Math.cos(rotation));\n  var unitH = Math.abs(unitSpan * Math.sin(rotation));\n  var maxW = 0;\n  var maxH = 0;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    var width = 0;\n    var height = 0;\n    var rect = textContain.getBoundingRect(labelFormatter({\n      value: tickValue\n    }), params.font, 'center', 'top');\n    width = rect.width * 1.3;\n    height = rect.height * 1.3;\n    maxW = Math.max(maxW, width, 7);\n    maxH = Math.max(maxH, height, 7);\n  }\n\n  var dw = maxW / unitW;\n  var dh = maxH / unitH;\n  isNaN(dw) && (dw = Infinity);\n  isNaN(dh) && (dh = Infinity);\n  var interval = Math.max(0, Math.floor(Math.min(dw, dh)));\n  var cache = inner(axis.model);\n  var axisExtent = axis.getExtent();\n  var lastAutoInterval = cache.lastAutoInterval;\n  var lastTickCount = cache.lastTickCount;\n\n  if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && lastAutoInterval > interval && cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {\n    interval = lastAutoInterval;\n  } else {\n    cache.lastTickCount = tickCount;\n    cache.lastAutoInterval = interval;\n    cache.axisExtent0 = axisExtent[0];\n    cache.axisExtent1 = axisExtent[1];\n  }\n\n  return interval;\n}\n\nexports.calculateCategoryInterval = calculateCategoryInterval;\n\nfunction fetchAutoCategoryIntervalCalculationParams(axis) {\n  var labelModel = axis.getLabelModel();\n  return {\n    axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,\n    labelRotate: labelModel.get('rotate') || 0,\n    font: labelModel.getFont()\n  };\n}\n\nfunction makeLabelsByNumericCategoryInterval(axis, categoryInterval, onlyTick) {\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  var ordinalScale = axis.scale;\n  var ordinalExtent = ordinalScale.getExtent();\n  var labelModel = axis.getLabelModel();\n  var result = [];\n  var step = Math.max((categoryInterval || 0) + 1, 1);\n  var startTick = ordinalExtent[0];\n  var tickCount = ordinalScale.count();\n\n  if (startTick !== 0 && step > 1 && tickCount / step > 2) {\n    startTick = Math.round(Math.ceil(startTick / step) * step);\n  }\n\n  var showAllLabel = axisHelper_1.shouldShowAllLabels(axis);\n  var includeMinLabel = labelModel.get('showMinLabel') || showAllLabel;\n  var includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel;\n\n  if (includeMinLabel && startTick !== ordinalExtent[0]) {\n    addItem(ordinalExtent[0]);\n  }\n\n  var tickValue = startTick;\n\n  for (; tickValue <= ordinalExtent[1]; tickValue += step) {\n    addItem(tickValue);\n  }\n\n  if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {\n    addItem(ordinalExtent[1]);\n  }\n\n  function addItem(tickValue) {\n    var tickObj = {\n      value: tickValue\n    };\n    result.push(onlyTick ? tickValue : {\n      formattedLabel: labelFormatter(tickObj),\n      rawLabel: ordinalScale.getLabel(tickObj),\n      tickValue: tickValue\n    });\n  }\n\n  return result;\n}\n\nfunction makeLabelsByCustomizedCategoryInterval(axis, categoryInterval, onlyTick) {\n  var ordinalScale = axis.scale;\n  var labelFormatter = axisHelper_1.makeLabelFormatter(axis);\n  var result = [];\n  zrUtil.each(ordinalScale.getTicks(), function (tick) {\n    var rawLabel = ordinalScale.getLabel(tick);\n    var tickValue = tick.value;\n\n    if (categoryInterval(tick.value, rawLabel)) {\n      result.push(onlyTick ? tickValue : {\n        formattedLabel: labelFormatter(tick),\n        rawLabel: rawLabel,\n        tickValue: tickValue\n      });\n    }\n  });\n  return result;\n}"]},"metadata":{},"sourceType":"script"}