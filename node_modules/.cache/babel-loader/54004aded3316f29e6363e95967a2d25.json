{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar types_1 = require(\"../../util/types\");\n\nvar model_1 = require(\"../../util/model\");\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar dataProvider_1 = require(\"./dataProvider\");\n\nvar dataValueHelper_1 = require(\"./dataValueHelper\");\n\nvar sourceHelper_1 = require(\"./sourceHelper\");\n\nvar log_1 = require(\"../../util/log\");\n\nvar Source_1 = require(\"../Source\");\n\nvar ExternalSource = function () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return dataValueHelper_1.parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexports.ExternalSource = ExternalSource;\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    util_1.each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n\n      if (name != null) {\n        var errMsg = '';\n\n        if (util_1.hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          log_1.throwError(errMsg);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n\n  var rawItemGetter = dataProvider_1.getRawSourceItemGetter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = util_1.bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = util_1.bind(cloneRawData, null, internalSource);\n  var rawCounter = dataProvider_1.getRawSourceDataCounter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = util_1.bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = dataProvider_1.getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex];\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = util_1.bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = util_1.bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS || !data || util_1.isArray(data) && !data.length) {\n    return upstream.data;\n  }\n\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n  }\n\n  log_1.throwError(errMsg);\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!data) {\n    return data;\n  } else if (util_1.isArray(data) && !data.length) {\n    return [];\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(util_1.extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n\n  if (typeof dim === 'number' || !isNaN(dim) && !util_1.hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (util_1.hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return util_1.clone(dimensions);\n}\n\nvar externalTransformMap = util_1.createHashMap();\n\nfunction registerExternalTransform(externalTransform) {\n  externalTransform = util_1.clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\n\nexports.registerExternalTransform = registerExternalTransform;\n\nfunction applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = model_1.normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nexports.applyDataTransform = applyDataTransform;\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  if (!util_1.isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var extUpSourceList = util_1.map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = model_1.normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: util_1.clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = util_1.map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', log_1.makePrintable(extSource.data), '- transform result dimensions:', log_1.makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log_1.consoleLog(printStrArr);\n    }\n  }\n\n  return util_1.map(resultList, function (result) {\n    var errMsg = '';\n\n    if (!util_1.isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      log_1.throwError(errMsg);\n    }\n\n    var resultData = result.data;\n\n    if (resultData != null) {\n      if (!util_1.isObject(resultData) && !util_1.isArrayLike(resultData)) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Result data should be object or array in data transform.';\n        }\n\n        log_1.throwError(errMsg);\n      }\n    } else {\n      resultData = upSourceList[0].data;\n    }\n\n    var resultMetaRawOption = sourceHelper_1.inheritSourceMetaRawOption(upSourceList[0], {\n      seriesLayoutBy: types_1.SERIES_LAYOUT_BY_COLUMN,\n      sourceHeader: 0,\n      dimensions: result.dimensions\n    });\n    return Source_1.createSource(resultData, resultMetaRawOption, null, null);\n  });\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/data/helper/transform.js"],"names":["exports","__esModule","types_1","require","model_1","util_1","dataProvider_1","dataValueHelper_1","sourceHelper_1","log_1","Source_1","ExternalSource","prototype","getRawData","Error","getRawDataItem","dataIndex","cloneRawData","getDimensionInfo","dim","cloneAllDimensionInfo","count","retrieveValue","dimIndex","retrieveValueFromItem","dataItem","convertValue","rawVal","dimInfo","parseDataValue","createExternalSource","internalSource","externalTransform","extSource","data","sourceFormat","sourceHeaderCount","startIndex","dimensions","dimsByName","dimsDef","dimensionsDefine","each","dimDef","idx","name","dimDefExt","index","displayName","push","errMsg","hasOwn","process","env","NODE_ENV","throwError","i","dimensionsDetectedCount","rawItemGetter","getRawSourceItemGetter","SERIES_LAYOUT_BY_COLUMN","__isBuiltIn","bind","rawCounter","getRawSourceDataCounter","rawValueGetter","getRawSourceValueGetter","rawItem","upstream","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","isArray","length","result","len","slice","extend","isNaN","clone","externalTransformMap","createHashMap","registerExternalTransform","type","typeParsed","split","isBuiltIn","set","applyDataTransform","rawTransOption","sourceList","infoForPrint","pipedTransOption","normalizeToArray","pipeLen","transOption","applySingleDataTransform","Math","max","upSourceList","pipeIndex","isObject","transType","get","extUpSourceList","map","upSource","resultList","transform","upstreamList","config","print","printStrArr","pipeIndexStr","datasetIndex","makePrintable","join","consoleLog","resultData","isArrayLike","resultMetaRawOption","inheritSourceMetaRawOption","seriesLayoutBy","sourceHeader","createSource"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar types_1 = require(\"../../util/types\");\n\nvar model_1 = require(\"../../util/model\");\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar dataProvider_1 = require(\"./dataProvider\");\n\nvar dataValueHelper_1 = require(\"./dataValueHelper\");\n\nvar sourceHelper_1 = require(\"./sourceHelper\");\n\nvar log_1 = require(\"../../util/log\");\n\nvar Source_1 = require(\"../Source\");\n\nvar ExternalSource = function () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return dataValueHelper_1.parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexports.ExternalSource = ExternalSource;\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    util_1.each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n\n      if (name != null) {\n        var errMsg = '';\n\n        if (util_1.hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          log_1.throwError(errMsg);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n\n  var rawItemGetter = dataProvider_1.getRawSourceItemGetter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = util_1.bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = util_1.bind(cloneRawData, null, internalSource);\n  var rawCounter = dataProvider_1.getRawSourceDataCounter(sourceFormat, types_1.SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = util_1.bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = dataProvider_1.getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex];\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = util_1.bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = util_1.bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS || !data || util_1.isArray(data) && !data.length) {\n    return upstream.data;\n  }\n\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n  }\n\n  log_1.throwError(errMsg);\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!data) {\n    return data;\n  } else if (util_1.isArray(data) && !data.length) {\n    return [];\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === types_1.SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(util_1.extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n\n  if (typeof dim === 'number' || !isNaN(dim) && !util_1.hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (util_1.hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return util_1.clone(dimensions);\n}\n\nvar externalTransformMap = util_1.createHashMap();\n\nfunction registerExternalTransform(externalTransform) {\n  externalTransform = util_1.clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\n\nexports.registerExternalTransform = registerExternalTransform;\n\nfunction applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = model_1.normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nexports.applyDataTransform = applyDataTransform;\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  if (!util_1.isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    log_1.throwError(errMsg);\n  }\n\n  var extUpSourceList = util_1.map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = model_1.normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: util_1.clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = util_1.map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', log_1.makePrintable(extSource.data), '- transform result dimensions:', log_1.makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      log_1.consoleLog(printStrArr);\n    }\n  }\n\n  return util_1.map(resultList, function (result) {\n    var errMsg = '';\n\n    if (!util_1.isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      log_1.throwError(errMsg);\n    }\n\n    var resultData = result.data;\n\n    if (resultData != null) {\n      if (!util_1.isObject(resultData) && !util_1.isArrayLike(resultData)) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Result data should be object or array in data transform.';\n        }\n\n        log_1.throwError(errMsg);\n      }\n    } else {\n      resultData = upSourceList[0].data;\n    }\n\n    var resultMetaRawOption = sourceHelper_1.inheritSourceMetaRawOption(upSourceList[0], {\n      seriesLayoutBy: types_1.SERIES_LAYOUT_BY_COLUMN,\n      sourceHeader: 0,\n      dimensions: result.dimensions\n    });\n    return Source_1.createSource(resultData, resultMetaRawOption, null, null);\n  });\n}"]},"metadata":{},"sourceType":"script"}