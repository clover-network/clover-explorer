{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar number_1 = require(\"../util/number\");\n\nvar dataStackHelper_1 = require(\"../data/helper/dataStackHelper\");\n\nvar createRenderPlanner_1 = require(\"../chart/helper/createRenderPlanner\");\n\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nexports.getLayoutOnAxis = getLayoutOnAxis;\n\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\n\nfunction getValueAxesMinGaps(barSeries) {\n  var axisValues = {};\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dim = data.mapDimension(baseAxis.dim);\n\n    for (var i = 0, cnt = data.count(); i < cnt; ++i) {\n      var value = data.get(dim, i);\n\n      if (!axisValues[key]) {\n        axisValues[key] = [value];\n      } else {\n        axisValues[key].push(value);\n      }\n    }\n  });\n  var axisMinGaps = {};\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        }\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nfunction makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = number_1.parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = number_1.parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = number_1.parsePercent(seriesModel.get('barMinWidth') || 1, bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nexports.makeColumnLayout = makeColumnLayout;\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: null,\n      gap: '20%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGapPercent = columnsOnAxis.categoryGap;\n\n    if (categoryGapPercent == null) {\n      var columnCount = zrUtil.keys(stacks).length;\n      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';\n    }\n\n    var categoryGap = number_1.parsePercent(categoryGapPercent, bandWidth);\n    var barGapPercent = number_1.parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    zrUtil.each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        }\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        }\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    });\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      return result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n\nexports.retrieveColumnLayout = retrieveColumnLayout;\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = dataStackHelper_1.isDimensionStacked(data, valueDim);\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart;\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart\n          };\n        }\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var x = void 0;\n      var y = void 0;\n      var width = void 0;\n      var height = void 0;\n\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        if (!isNaN(width)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n        }\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n\n        if (Math.abs(height) < barMinHeight) {\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        if (!isNaN(height)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n        }\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  });\n}\n\nexports.layout = layout;\nexports.largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner_1[\"default\"](),\n  reset: function (seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var coordLayout = cartesian.master.getRect();\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n\n    return {\n      progress: function (params, data) {\n        var count = params.count;\n        var largePoints = new LargeArr(count * 2);\n        var largeBackgroundPoints = new LargeArr(count * 2);\n        var largeDataIndices = new LargeArr(count);\n        var dataIndex;\n        var coord = [];\n        var valuePair = [];\n        var pointsOffset = 0;\n        var idxOffset = 0;\n\n        while ((dataIndex = params.next()) != null) {\n          valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n          valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n          coord = cartesian.dataToPoint(valuePair, null, coord);\n          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];\n          largePoints[pointsOffset++] = coord[0];\n          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;\n          largePoints[pointsOffset++] = coord[1];\n          largeDataIndices[idxOffset++] = dataIndex;\n        }\n\n        data.setLayout({\n          largePoints: largePoints,\n          largeDataIndices: largeDataIndices,\n          largeBackgroundPoints: largeBackgroundPoints,\n          barWidth: barWidth,\n          valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n          backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,\n          valueAxisHorizontal: valueAxisHorizontal\n        });\n      }\n    };\n  }\n};\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n}\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/layout/barGrid.js"],"names":["exports","__esModule","zrUtil","require","number_1","dataStackHelper_1","createRenderPlanner_1","STACK_PREFIX","LARGE_BAR_MIN_WIDTH","LargeArr","Float32Array","Array","getSeriesStackId","seriesModel","get","seriesIndex","getAxisKey","axis","dim","index","getLayoutOnAxis","opt","params","baseAxis","axisKey","type","bandWidth","getBandWidth","i","count","push","defaults","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","offset","width","prepareLayoutBarSeries","seriesType","ecModel","seriesModels","eachSeriesByType","isOnCartesian","isInLargeMode","getValueAxesMinGaps","barSeries","axisValues","each","cartesian","coordinateSystem","getBaseAxis","data","getData","key","mapDimension","cnt","value","axisMinGaps","hasOwnProperty","valuesInAxis","sort","a","b","min","j","length","delta","Math","makeColumnLayout","seriesInfoList","axisExtent","getExtent","minGap","extentSpan","abs","scale","scaleSpan","barWidth","parsePercent","barMaxWidth","barMinWidth","barGap","barCategoryGap","columnsMap","seriesInfo","idx","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","maxWidth","minWidth","coordSysName","categoryGapPercent","columnCount","keys","max","barGapPercent","autoWidth","column","finalWidth","widthSum","lastColumn","retrieveColumnLayout","barWidthAndOffset","layout","lastStackCoords","columnLayoutInfo","columnOffset","columnWidth","valueAxis","getOtherAxis","barMinHeight","setLayout","size","valueDim","baseDim","stacked","isDimensionStacked","isValueAxisH","isHorizontal","valueAxisStart","getValueAxisStart","len","baseValue","sign","baseCoord","p","n","x","y","height","coord","dataToPoint","isNaN","setItemLayout","largeLayout","plan","reset","coordLayout","master","getRect","valueAxisHorizontal","valueDimIdx","progress","largePoints","largeBackgroundPoints","largeDataIndices","dataIndex","valuePair","pointsOffset","idxOffset","next","backgroundStart","pipelineContext","large","toGlobalCoord","dataToCoord"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,gBAAD,CAAtB;;AAEA,IAAIE,iBAAiB,GAAGF,OAAO,CAAC,gCAAD,CAA/B;;AAEA,IAAIG,qBAAqB,GAAGH,OAAO,CAAC,qCAAD,CAAnC;;AAEA,IAAII,YAAY,GAAG,aAAnB;AACA,IAAIC,mBAAmB,GAAG,GAA1B;AACA,IAAIC,QAAQ,GAAG,OAAOC,YAAP,KAAwB,WAAxB,GAAsCA,YAAtC,GAAqDC,KAApE;;AAEA,SAASC,gBAAT,CAA0BC,WAA1B,EAAuC;AACrC,SAAOA,WAAW,CAACC,GAAZ,CAAgB,OAAhB,KAA4BP,YAAY,GAAGM,WAAW,CAACE,WAA9D;AACD;;AAED,SAASC,UAAT,CAAoBC,IAApB,EAA0B;AACxB,SAAOA,IAAI,CAACC,GAAL,GAAWD,IAAI,CAACE,KAAvB;AACD;;AAED,SAASC,eAAT,CAAyBC,GAAzB,EAA8B;AAC5B,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,QAAQ,GAAGF,GAAG,CAACJ,IAAnB;AACA,MAAIO,OAAO,GAAG,OAAd;;AAEA,MAAID,QAAQ,CAACE,IAAT,KAAkB,UAAtB,EAAkC;AAChC;AACD;;AAED,MAAIC,SAAS,GAAGH,QAAQ,CAACI,YAAT,EAAhB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,GAAG,CAACQ,KAAR,IAAiB,CAAjC,EAAoCD,CAAC,EAArC,EAAyC;AACvCN,IAAAA,MAAM,CAACQ,IAAP,CAAY5B,MAAM,CAAC6B,QAAP,CAAgB;AAC1BL,MAAAA,SAAS,EAAEA,SADe;AAE1BF,MAAAA,OAAO,EAAEA,OAFiB;AAG1BQ,MAAAA,OAAO,EAAEzB,YAAY,GAAGqB;AAHE,KAAhB,EAITP,GAJS,CAAZ;AAKD;;AAED,MAAIY,eAAe,GAAGC,sBAAsB,CAACZ,MAAD,CAA5C;AACA,MAAIa,MAAM,GAAG,EAAb;;AAEA,OAAK,IAAIP,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,GAAG,CAACQ,KAAxB,EAA+BD,CAAC,EAAhC,EAAoC;AAClC,QAAIQ,IAAI,GAAGH,eAAe,CAACT,OAAD,CAAf,CAAyBjB,YAAY,GAAGqB,CAAxC,CAAX;AACAQ,IAAAA,IAAI,CAACC,YAAL,GAAoBD,IAAI,CAACE,MAAL,GAAcF,IAAI,CAACG,KAAL,GAAa,CAA/C;AACAJ,IAAAA,MAAM,CAACL,IAAP,CAAYM,IAAZ;AACD;;AAED,SAAOD,MAAP;AACD;;AAEDnC,OAAO,CAACoB,eAAR,GAA0BA,eAA1B;;AAEA,SAASoB,sBAAT,CAAgCC,UAAhC,EAA4CC,OAA5C,EAAqD;AACnD,MAAIC,YAAY,GAAG,EAAnB;AACAD,EAAAA,OAAO,CAACE,gBAAR,CAAyBH,UAAzB,EAAqC,UAAU5B,WAAV,EAAuB;AAC1D,QAAIgC,aAAa,CAAChC,WAAD,CAAb,IAA8B,CAACiC,aAAa,CAACjC,WAAD,CAAhD,EAA+D;AAC7D8B,MAAAA,YAAY,CAACb,IAAb,CAAkBjB,WAAlB;AACD;AACF,GAJD;AAKA,SAAO8B,YAAP;AACD;;AAED3C,OAAO,CAACwC,sBAAR,GAAiCA,sBAAjC;;AAEA,SAASO,mBAAT,CAA6BC,SAA7B,EAAwC;AACtC,MAAIC,UAAU,GAAG,EAAjB;AACA/C,EAAAA,MAAM,CAACgD,IAAP,CAAYF,SAAZ,EAAuB,UAAUnC,WAAV,EAAuB;AAC5C,QAAIsC,SAAS,GAAGtC,WAAW,CAACuC,gBAA5B;AACA,QAAI7B,QAAQ,GAAG4B,SAAS,CAACE,WAAV,EAAf;;AAEA,QAAI9B,QAAQ,CAACE,IAAT,KAAkB,MAAlB,IAA4BF,QAAQ,CAACE,IAAT,KAAkB,OAAlD,EAA2D;AACzD;AACD;;AAED,QAAI6B,IAAI,GAAGzC,WAAW,CAAC0C,OAAZ,EAAX;AACA,QAAIC,GAAG,GAAGjC,QAAQ,CAACL,GAAT,GAAe,GAAf,GAAqBK,QAAQ,CAACJ,KAAxC;AACA,QAAID,GAAG,GAAGoC,IAAI,CAACG,YAAL,CAAkBlC,QAAQ,CAACL,GAA3B,CAAV;;AAEA,SAAK,IAAIU,CAAC,GAAG,CAAR,EAAW8B,GAAG,GAAGJ,IAAI,CAACzB,KAAL,EAAtB,EAAoCD,CAAC,GAAG8B,GAAxC,EAA6C,EAAE9B,CAA/C,EAAkD;AAChD,UAAI+B,KAAK,GAAGL,IAAI,CAACxC,GAAL,CAASI,GAAT,EAAcU,CAAd,CAAZ;;AAEA,UAAI,CAACqB,UAAU,CAACO,GAAD,CAAf,EAAsB;AACpBP,QAAAA,UAAU,CAACO,GAAD,CAAV,GAAkB,CAACG,KAAD,CAAlB;AACD,OAFD,MAEO;AACLV,QAAAA,UAAU,CAACO,GAAD,CAAV,CAAgB1B,IAAhB,CAAqB6B,KAArB;AACD;AACF;AACF,GArBD;AAsBA,MAAIC,WAAW,GAAG,EAAlB;;AAEA,OAAK,IAAIJ,GAAT,IAAgBP,UAAhB,EAA4B;AAC1B,QAAIA,UAAU,CAACY,cAAX,CAA0BL,GAA1B,CAAJ,EAAoC;AAClC,UAAIM,YAAY,GAAGb,UAAU,CAACO,GAAD,CAA7B;;AAEA,UAAIM,YAAJ,EAAkB;AAChBA,QAAAA,YAAY,CAACC,IAAb,CAAkB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChC,iBAAOD,CAAC,GAAGC,CAAX;AACD,SAFD;AAGA,YAAIC,GAAG,GAAG,IAAV;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,YAAY,CAACM,MAAjC,EAAyC,EAAED,CAA3C,EAA8C;AAC5C,cAAIE,KAAK,GAAGP,YAAY,CAACK,CAAD,CAAZ,GAAkBL,YAAY,CAACK,CAAC,GAAG,CAAL,CAA1C;;AAEA,cAAIE,KAAK,GAAG,CAAZ,EAAe;AACbH,YAAAA,GAAG,GAAGA,GAAG,KAAK,IAAR,GAAeG,KAAf,GAAuBC,IAAI,CAACJ,GAAL,CAASA,GAAT,EAAcG,KAAd,CAA7B;AACD;AACF;;AAEDT,QAAAA,WAAW,CAACJ,GAAD,CAAX,GAAmBU,GAAnB;AACD;AACF;AACF;;AAED,SAAON,WAAP;AACD;;AAED,SAASW,gBAAT,CAA0BvB,SAA1B,EAAqC;AACnC,MAAIY,WAAW,GAAGb,mBAAmB,CAACC,SAAD,CAArC;AACA,MAAIwB,cAAc,GAAG,EAArB;AACAtE,EAAAA,MAAM,CAACgD,IAAP,CAAYF,SAAZ,EAAuB,UAAUnC,WAAV,EAAuB;AAC5C,QAAIsC,SAAS,GAAGtC,WAAW,CAACuC,gBAA5B;AACA,QAAI7B,QAAQ,GAAG4B,SAAS,CAACE,WAAV,EAAf;AACA,QAAIoB,UAAU,GAAGlD,QAAQ,CAACmD,SAAT,EAAjB;AACA,QAAIhD,SAAJ;;AAEA,QAAIH,QAAQ,CAACE,IAAT,KAAkB,UAAtB,EAAkC;AAChCC,MAAAA,SAAS,GAAGH,QAAQ,CAACI,YAAT,EAAZ;AACD,KAFD,MAEO,IAAIJ,QAAQ,CAACE,IAAT,KAAkB,OAAlB,IAA6BF,QAAQ,CAACE,IAAT,KAAkB,MAAnD,EAA2D;AAChE,UAAI+B,GAAG,GAAGjC,QAAQ,CAACL,GAAT,GAAe,GAAf,GAAqBK,QAAQ,CAACJ,KAAxC;AACA,UAAIwD,MAAM,GAAGf,WAAW,CAACJ,GAAD,CAAxB;AACA,UAAIoB,UAAU,GAAGN,IAAI,CAACO,GAAL,CAASJ,UAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAAnC,CAAjB;AACA,UAAIK,KAAK,GAAGvD,QAAQ,CAACuD,KAAT,CAAeJ,SAAf,EAAZ;AACA,UAAIK,SAAS,GAAGT,IAAI,CAACO,GAAL,CAASC,KAAK,CAAC,CAAD,CAAL,GAAWA,KAAK,CAAC,CAAD,CAAzB,CAAhB;AACApD,MAAAA,SAAS,GAAGiD,MAAM,GAAGC,UAAU,GAAGG,SAAb,GAAyBJ,MAA5B,GAAqCC,UAAvD;AACD,KAPM,MAOA;AACL,UAAItB,IAAI,GAAGzC,WAAW,CAAC0C,OAAZ,EAAX;AACA7B,MAAAA,SAAS,GAAG4C,IAAI,CAACO,GAAL,CAASJ,UAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAAnC,IAA0CnB,IAAI,CAACzB,KAAL,EAAtD;AACD;;AAED,QAAImD,QAAQ,GAAG5E,QAAQ,CAAC6E,YAAT,CAAsBpE,WAAW,CAACC,GAAZ,CAAgB,UAAhB,CAAtB,EAAmDY,SAAnD,CAAf;AACA,QAAIwD,WAAW,GAAG9E,QAAQ,CAAC6E,YAAT,CAAsBpE,WAAW,CAACC,GAAZ,CAAgB,aAAhB,CAAtB,EAAsDY,SAAtD,CAAlB;AACA,QAAIyD,WAAW,GAAG/E,QAAQ,CAAC6E,YAAT,CAAsBpE,WAAW,CAACC,GAAZ,CAAgB,aAAhB,KAAkC,CAAxD,EAA2DY,SAA3D,CAAlB;AACA,QAAI0D,MAAM,GAAGvE,WAAW,CAACC,GAAZ,CAAgB,QAAhB,CAAb;AACA,QAAIuE,cAAc,GAAGxE,WAAW,CAACC,GAAZ,CAAgB,gBAAhB,CAArB;AACA0D,IAAAA,cAAc,CAAC1C,IAAf,CAAoB;AAClBJ,MAAAA,SAAS,EAAEA,SADO;AAElBsD,MAAAA,QAAQ,EAAEA,QAFQ;AAGlBE,MAAAA,WAAW,EAAEA,WAHK;AAIlBC,MAAAA,WAAW,EAAEA,WAJK;AAKlBC,MAAAA,MAAM,EAAEA,MALU;AAMlBC,MAAAA,cAAc,EAAEA,cANE;AAOlB7D,MAAAA,OAAO,EAAER,UAAU,CAACO,QAAD,CAPD;AAQlBS,MAAAA,OAAO,EAAEpB,gBAAgB,CAACC,WAAD;AARP,KAApB;AAUD,GAnCD;AAoCA,SAAOqB,sBAAsB,CAACsC,cAAD,CAA7B;AACD;;AAEDxE,OAAO,CAACuE,gBAAR,GAA2BA,gBAA3B;;AAEA,SAASrC,sBAAT,CAAgCsC,cAAhC,EAAgD;AAC9C,MAAIc,UAAU,GAAG,EAAjB;AACApF,EAAAA,MAAM,CAACgD,IAAP,CAAYsB,cAAZ,EAA4B,UAAUe,UAAV,EAAsBC,GAAtB,EAA2B;AACrD,QAAIhE,OAAO,GAAG+D,UAAU,CAAC/D,OAAzB;AACA,QAAIE,SAAS,GAAG6D,UAAU,CAAC7D,SAA3B;AACA,QAAI+D,aAAa,GAAGH,UAAU,CAAC9D,OAAD,CAAV,IAAuB;AACzCE,MAAAA,SAAS,EAAEA,SAD8B;AAEzCgE,MAAAA,aAAa,EAAEhE,SAF0B;AAGzCiE,MAAAA,cAAc,EAAE,CAHyB;AAIzCC,MAAAA,WAAW,EAAE,IAJ4B;AAKzCC,MAAAA,GAAG,EAAE,KALoC;AAMzCC,MAAAA,MAAM,EAAE;AANiC,KAA3C;AAQA,QAAIA,MAAM,GAAGL,aAAa,CAACK,MAA3B;AACAR,IAAAA,UAAU,CAAC9D,OAAD,CAAV,GAAsBiE,aAAtB;AACA,QAAIzD,OAAO,GAAGuD,UAAU,CAACvD,OAAzB;;AAEA,QAAI,CAAC8D,MAAM,CAAC9D,OAAD,CAAX,EAAsB;AACpByD,MAAAA,aAAa,CAACE,cAAd;AACD;;AAEDG,IAAAA,MAAM,CAAC9D,OAAD,CAAN,GAAkB8D,MAAM,CAAC9D,OAAD,CAAN,IAAmB;AACnCO,MAAAA,KAAK,EAAE,CAD4B;AAEnCwD,MAAAA,QAAQ,EAAE;AAFyB,KAArC;AAIA,QAAIf,QAAQ,GAAGO,UAAU,CAACP,QAA1B;;AAEA,QAAIA,QAAQ,IAAI,CAACc,MAAM,CAAC9D,OAAD,CAAN,CAAgBO,KAAjC,EAAwC;AACtCuD,MAAAA,MAAM,CAAC9D,OAAD,CAAN,CAAgBO,KAAhB,GAAwByC,QAAxB;AACAA,MAAAA,QAAQ,GAAGV,IAAI,CAACJ,GAAL,CAASuB,aAAa,CAACC,aAAvB,EAAsCV,QAAtC,CAAX;AACAS,MAAAA,aAAa,CAACC,aAAd,IAA+BV,QAA/B;AACD;;AAED,QAAIE,WAAW,GAAGK,UAAU,CAACL,WAA7B;AACAA,IAAAA,WAAW,KAAKY,MAAM,CAAC9D,OAAD,CAAN,CAAgB+D,QAAhB,GAA2Bb,WAAhC,CAAX;AACA,QAAIC,WAAW,GAAGI,UAAU,CAACJ,WAA7B;AACAA,IAAAA,WAAW,KAAKW,MAAM,CAAC9D,OAAD,CAAN,CAAgBgE,QAAhB,GAA2Bb,WAAhC,CAAX;AACA,QAAIC,MAAM,GAAGG,UAAU,CAACH,MAAxB;AACAA,IAAAA,MAAM,IAAI,IAAV,KAAmBK,aAAa,CAACI,GAAd,GAAoBT,MAAvC;AACA,QAAIC,cAAc,GAAGE,UAAU,CAACF,cAAhC;AACAA,IAAAA,cAAc,IAAI,IAAlB,KAA2BI,aAAa,CAACG,WAAd,GAA4BP,cAAvD;AACD,GAvCD;AAwCA,MAAIlD,MAAM,GAAG,EAAb;AACAjC,EAAAA,MAAM,CAACgD,IAAP,CAAYoC,UAAZ,EAAwB,UAAUG,aAAV,EAAyBQ,YAAzB,EAAuC;AAC7D9D,IAAAA,MAAM,CAAC8D,YAAD,CAAN,GAAuB,EAAvB;AACA,QAAIH,MAAM,GAAGL,aAAa,CAACK,MAA3B;AACA,QAAIpE,SAAS,GAAG+D,aAAa,CAAC/D,SAA9B;AACA,QAAIwE,kBAAkB,GAAGT,aAAa,CAACG,WAAvC;;AAEA,QAAIM,kBAAkB,IAAI,IAA1B,EAAgC;AAC9B,UAAIC,WAAW,GAAGjG,MAAM,CAACkG,IAAP,CAAYN,MAAZ,EAAoB1B,MAAtC;AACA8B,MAAAA,kBAAkB,GAAG5B,IAAI,CAAC+B,GAAL,CAAS,KAAKF,WAAW,GAAG,CAA5B,EAA+B,EAA/B,IAAqC,GAA1D;AACD;;AAED,QAAIP,WAAW,GAAGxF,QAAQ,CAAC6E,YAAT,CAAsBiB,kBAAtB,EAA0CxE,SAA1C,CAAlB;AACA,QAAI4E,aAAa,GAAGlG,QAAQ,CAAC6E,YAAT,CAAsBQ,aAAa,CAACI,GAApC,EAAyC,CAAzC,CAApB;AACA,QAAIH,aAAa,GAAGD,aAAa,CAACC,aAAlC;AACA,QAAIC,cAAc,GAAGF,aAAa,CAACE,cAAnC;AACA,QAAIY,SAAS,GAAG,CAACb,aAAa,GAAGE,WAAjB,KAAiCD,cAAc,GAAG,CAACA,cAAc,GAAG,CAAlB,IAAuBW,aAAzE,CAAhB;AACAC,IAAAA,SAAS,GAAGjC,IAAI,CAAC+B,GAAL,CAASE,SAAT,EAAoB,CAApB,CAAZ;AACArG,IAAAA,MAAM,CAACgD,IAAP,CAAY4C,MAAZ,EAAoB,UAAUU,MAAV,EAAkB;AACpC,UAAIT,QAAQ,GAAGS,MAAM,CAACT,QAAtB;AACA,UAAIC,QAAQ,GAAGQ,MAAM,CAACR,QAAtB;;AAEA,UAAI,CAACQ,MAAM,CAACjE,KAAZ,EAAmB;AACjB,YAAIkE,UAAU,GAAGF,SAAjB;;AAEA,YAAIR,QAAQ,IAAIA,QAAQ,GAAGU,UAA3B,EAAuC;AACrCA,UAAAA,UAAU,GAAGnC,IAAI,CAACJ,GAAL,CAAS6B,QAAT,EAAmBL,aAAnB,CAAb;AACD;;AAED,YAAIM,QAAQ,IAAIA,QAAQ,GAAGS,UAA3B,EAAuC;AACrCA,UAAAA,UAAU,GAAGT,QAAb;AACD;;AAED,YAAIS,UAAU,KAAKF,SAAnB,EAA8B;AAC5BC,UAAAA,MAAM,CAACjE,KAAP,GAAekE,UAAf;AACAf,UAAAA,aAAa,IAAIe,UAAU,GAAGH,aAAa,GAAGG,UAA9C;AACAd,UAAAA,cAAc;AACf;AACF,OAhBD,MAgBO;AACL,YAAIc,UAAU,GAAGD,MAAM,CAACjE,KAAxB;;AAEA,YAAIwD,QAAJ,EAAc;AACZU,UAAAA,UAAU,GAAGnC,IAAI,CAACJ,GAAL,CAASuC,UAAT,EAAqBV,QAArB,CAAb;AACD;;AAED,YAAIC,QAAJ,EAAc;AACZS,UAAAA,UAAU,GAAGnC,IAAI,CAAC+B,GAAL,CAASI,UAAT,EAAqBT,QAArB,CAAb;AACD;;AAEDQ,QAAAA,MAAM,CAACjE,KAAP,GAAekE,UAAf;AACAf,QAAAA,aAAa,IAAIe,UAAU,GAAGH,aAAa,GAAGG,UAA9C;AACAd,QAAAA,cAAc;AACf;AACF,KAnCD;AAoCAY,IAAAA,SAAS,GAAG,CAACb,aAAa,GAAGE,WAAjB,KAAiCD,cAAc,GAAG,CAACA,cAAc,GAAG,CAAlB,IAAuBW,aAAzE,CAAZ;AACAC,IAAAA,SAAS,GAAGjC,IAAI,CAAC+B,GAAL,CAASE,SAAT,EAAoB,CAApB,CAAZ;AACA,QAAIG,QAAQ,GAAG,CAAf;AACA,QAAIC,UAAJ;AACAzG,IAAAA,MAAM,CAACgD,IAAP,CAAY4C,MAAZ,EAAoB,UAAUU,MAAV,EAAkBhB,GAAlB,EAAuB;AACzC,UAAI,CAACgB,MAAM,CAACjE,KAAZ,EAAmB;AACjBiE,QAAAA,MAAM,CAACjE,KAAP,GAAegE,SAAf;AACD;;AAEDI,MAAAA,UAAU,GAAGH,MAAb;AACAE,MAAAA,QAAQ,IAAIF,MAAM,CAACjE,KAAP,IAAgB,IAAI+D,aAApB,CAAZ;AACD,KAPD;;AASA,QAAIK,UAAJ,EAAgB;AACdD,MAAAA,QAAQ,IAAIC,UAAU,CAACpE,KAAX,GAAmB+D,aAA/B;AACD;;AAED,QAAIhE,MAAM,GAAG,CAACoE,QAAD,GAAY,CAAzB;AACAxG,IAAAA,MAAM,CAACgD,IAAP,CAAY4C,MAAZ,EAAoB,UAAUU,MAAV,EAAkBxE,OAAlB,EAA2B;AAC7CG,MAAAA,MAAM,CAAC8D,YAAD,CAAN,CAAqBjE,OAArB,IAAgCG,MAAM,CAAC8D,YAAD,CAAN,CAAqBjE,OAArB,KAAiC;AAC/DN,QAAAA,SAAS,EAAEA,SADoD;AAE/DY,QAAAA,MAAM,EAAEA,MAFuD;AAG/DC,QAAAA,KAAK,EAAEiE,MAAM,CAACjE;AAHiD,OAAjE;AAKAD,MAAAA,MAAM,IAAIkE,MAAM,CAACjE,KAAP,IAAgB,IAAI+D,aAApB,CAAV;AACD,KAPD;AAQD,GA/ED;AAgFA,SAAOnE,MAAP;AACD;;AAED,SAASyE,oBAAT,CAA8BC,iBAA9B,EAAiD5F,IAAjD,EAAuDJ,WAAvD,EAAoE;AAClE,MAAIgG,iBAAiB,IAAI5F,IAAzB,EAA+B;AAC7B,QAAIkB,MAAM,GAAG0E,iBAAiB,CAAC7F,UAAU,CAACC,IAAD,CAAX,CAA9B;;AAEA,QAAIkB,MAAM,IAAI,IAAV,IAAkBtB,WAAW,IAAI,IAArC,EAA2C;AACzC,aAAOsB,MAAM,CAACvB,gBAAgB,CAACC,WAAD,CAAjB,CAAb;AACD;;AAED,WAAOsB,MAAP;AACD;AACF;;AAEDnC,OAAO,CAAC4G,oBAAR,GAA+BA,oBAA/B;;AAEA,SAASE,MAAT,CAAgBrE,UAAhB,EAA4BC,OAA5B,EAAqC;AACnC,MAAIC,YAAY,GAAGH,sBAAsB,CAACC,UAAD,EAAaC,OAAb,CAAzC;AACA,MAAImE,iBAAiB,GAAGtC,gBAAgB,CAAC5B,YAAD,CAAxC;AACA,MAAIoE,eAAe,GAAG,EAAtB;AACA7G,EAAAA,MAAM,CAACgD,IAAP,CAAYP,YAAZ,EAA0B,UAAU9B,WAAV,EAAuB;AAC/C,QAAIyC,IAAI,GAAGzC,WAAW,CAAC0C,OAAZ,EAAX;AACA,QAAIJ,SAAS,GAAGtC,WAAW,CAACuC,gBAA5B;AACA,QAAI7B,QAAQ,GAAG4B,SAAS,CAACE,WAAV,EAAf;AACA,QAAIrB,OAAO,GAAGpB,gBAAgB,CAACC,WAAD,CAA9B;AACA,QAAImG,gBAAgB,GAAGH,iBAAiB,CAAC7F,UAAU,CAACO,QAAD,CAAX,CAAjB,CAAwCS,OAAxC,CAAvB;AACA,QAAIiF,YAAY,GAAGD,gBAAgB,CAAC1E,MAApC;AACA,QAAI4E,WAAW,GAAGF,gBAAgB,CAACzE,KAAnC;AACA,QAAI4E,SAAS,GAAGhE,SAAS,CAACiE,YAAV,CAAuB7F,QAAvB,CAAhB;AACA,QAAI8F,YAAY,GAAGxG,WAAW,CAACC,GAAZ,CAAgB,cAAhB,KAAmC,CAAtD;AACAiG,IAAAA,eAAe,CAAC/E,OAAD,CAAf,GAA2B+E,eAAe,CAAC/E,OAAD,CAAf,IAA4B,EAAvD;AACAsB,IAAAA,IAAI,CAACgE,SAAL,CAAe;AACb5F,MAAAA,SAAS,EAAEsF,gBAAgB,CAACtF,SADf;AAEbY,MAAAA,MAAM,EAAE2E,YAFK;AAGbM,MAAAA,IAAI,EAAEL;AAHO,KAAf;AAKA,QAAIM,QAAQ,GAAGlE,IAAI,CAACG,YAAL,CAAkB0D,SAAS,CAACjG,GAA5B,CAAf;AACA,QAAIuG,OAAO,GAAGnE,IAAI,CAACG,YAAL,CAAkBlC,QAAQ,CAACL,GAA3B,CAAd;AACA,QAAIwG,OAAO,GAAGrH,iBAAiB,CAACsH,kBAAlB,CAAqCrE,IAArC,EAA2CkE,QAA3C,CAAd;AACA,QAAII,YAAY,GAAGT,SAAS,CAACU,YAAV,EAAnB;AACA,QAAIC,cAAc,GAAGC,iBAAiB,CAACxG,QAAD,EAAW4F,SAAX,EAAsBO,OAAtB,CAAtC;;AAEA,SAAK,IAAIlC,GAAG,GAAG,CAAV,EAAawC,GAAG,GAAG1E,IAAI,CAACzB,KAAL,EAAxB,EAAsC2D,GAAG,GAAGwC,GAA5C,EAAiDxC,GAAG,EAApD,EAAwD;AACtD,UAAI7B,KAAK,GAAGL,IAAI,CAACxC,GAAL,CAAS0G,QAAT,EAAmBhC,GAAnB,CAAZ;AACA,UAAIyC,SAAS,GAAG3E,IAAI,CAACxC,GAAL,CAAS2G,OAAT,EAAkBjC,GAAlB,CAAhB;AACA,UAAI0C,IAAI,GAAGvE,KAAK,IAAI,CAAT,GAAa,GAAb,GAAmB,GAA9B;AACA,UAAIwE,SAAS,GAAGL,cAAhB;;AAEA,UAAIJ,OAAJ,EAAa;AACX,YAAI,CAACX,eAAe,CAAC/E,OAAD,CAAf,CAAyBiG,SAAzB,CAAL,EAA0C;AACxClB,UAAAA,eAAe,CAAC/E,OAAD,CAAf,CAAyBiG,SAAzB,IAAsC;AACpCG,YAAAA,CAAC,EAAEN,cADiC;AAEpCO,YAAAA,CAAC,EAAEP;AAFiC,WAAtC;AAID;;AAEDK,QAAAA,SAAS,GAAGpB,eAAe,CAAC/E,OAAD,CAAf,CAAyBiG,SAAzB,EAAoCC,IAApC,CAAZ;AACD;;AAED,UAAII,CAAC,GAAG,KAAK,CAAb;AACA,UAAIC,CAAC,GAAG,KAAK,CAAb;AACA,UAAIhG,KAAK,GAAG,KAAK,CAAjB;AACA,UAAIiG,MAAM,GAAG,KAAK,CAAlB;;AAEA,UAAIZ,YAAJ,EAAkB;AAChB,YAAIa,KAAK,GAAGtF,SAAS,CAACuF,WAAV,CAAsB,CAAC/E,KAAD,EAAQsE,SAAR,CAAtB,CAAZ;AACAK,QAAAA,CAAC,GAAGH,SAAJ;AACAI,QAAAA,CAAC,GAAGE,KAAK,CAAC,CAAD,CAAL,GAAWxB,YAAf;AACA1E,QAAAA,KAAK,GAAGkG,KAAK,CAAC,CAAD,CAAL,GAAWX,cAAnB;AACAU,QAAAA,MAAM,GAAGtB,WAAT;;AAEA,YAAI5C,IAAI,CAACO,GAAL,CAAStC,KAAT,IAAkB8E,YAAtB,EAAoC;AAClC9E,UAAAA,KAAK,GAAG,CAACA,KAAK,GAAG,CAAR,GAAY,CAAC,CAAb,GAAiB,CAAlB,IAAuB8E,YAA/B;AACD;;AAED,YAAI,CAACsB,KAAK,CAACpG,KAAD,CAAV,EAAmB;AACjBmF,UAAAA,OAAO,KAAKX,eAAe,CAAC/E,OAAD,CAAf,CAAyBiG,SAAzB,EAAoCC,IAApC,KAA6C3F,KAAlD,CAAP;AACD;AACF,OAdD,MAcO;AACL,YAAIkG,KAAK,GAAGtF,SAAS,CAACuF,WAAV,CAAsB,CAACT,SAAD,EAAYtE,KAAZ,CAAtB,CAAZ;AACA2E,QAAAA,CAAC,GAAGG,KAAK,CAAC,CAAD,CAAL,GAAWxB,YAAf;AACAsB,QAAAA,CAAC,GAAGJ,SAAJ;AACA5F,QAAAA,KAAK,GAAG2E,WAAR;AACAsB,QAAAA,MAAM,GAAGC,KAAK,CAAC,CAAD,CAAL,GAAWX,cAApB;;AAEA,YAAIxD,IAAI,CAACO,GAAL,CAAS2D,MAAT,IAAmBnB,YAAvB,EAAqC;AACnCmB,UAAAA,MAAM,GAAG,CAACA,MAAM,IAAI,CAAV,GAAc,CAAC,CAAf,GAAmB,CAApB,IAAyBnB,YAAlC;AACD;;AAED,YAAI,CAACsB,KAAK,CAACH,MAAD,CAAV,EAAoB;AAClBd,UAAAA,OAAO,KAAKX,eAAe,CAAC/E,OAAD,CAAf,CAAyBiG,SAAzB,EAAoCC,IAApC,KAA6CM,MAAlD,CAAP;AACD;AACF;;AAEDlF,MAAAA,IAAI,CAACsF,aAAL,CAAmBpD,GAAnB,EAAwB;AACtB8C,QAAAA,CAAC,EAAEA,CADmB;AAEtBC,QAAAA,CAAC,EAAEA,CAFmB;AAGtBhG,QAAAA,KAAK,EAAEA,KAHe;AAItBiG,QAAAA,MAAM,EAAEA;AAJc,OAAxB;AAMD;AACF,GAjFD;AAkFD;;AAEDxI,OAAO,CAAC8G,MAAR,GAAiBA,MAAjB;AACA9G,OAAO,CAAC6I,WAAR,GAAsB;AACpBpG,EAAAA,UAAU,EAAE,KADQ;AAEpBqG,EAAAA,IAAI,EAAExI,qBAAqB,CAAC,SAAD,CAArB,EAFc;AAGpByI,EAAAA,KAAK,EAAE,UAAUlI,WAAV,EAAuB;AAC5B,QAAI,CAACgC,aAAa,CAAChC,WAAD,CAAd,IAA+B,CAACiC,aAAa,CAACjC,WAAD,CAAjD,EAAgE;AAC9D;AACD;;AAED,QAAIyC,IAAI,GAAGzC,WAAW,CAAC0C,OAAZ,EAAX;AACA,QAAIJ,SAAS,GAAGtC,WAAW,CAACuC,gBAA5B;AACA,QAAI4F,WAAW,GAAG7F,SAAS,CAAC8F,MAAV,CAAiBC,OAAjB,EAAlB;AACA,QAAI3H,QAAQ,GAAG4B,SAAS,CAACE,WAAV,EAAf;AACA,QAAI8D,SAAS,GAAGhE,SAAS,CAACiE,YAAV,CAAuB7F,QAAvB,CAAhB;AACA,QAAIiG,QAAQ,GAAGlE,IAAI,CAACG,YAAL,CAAkB0D,SAAS,CAACjG,GAA5B,CAAf;AACA,QAAIuG,OAAO,GAAGnE,IAAI,CAACG,YAAL,CAAkBlC,QAAQ,CAACL,GAA3B,CAAd;AACA,QAAIiI,mBAAmB,GAAGhC,SAAS,CAACU,YAAV,EAA1B;AACA,QAAIuB,WAAW,GAAGD,mBAAmB,GAAG,CAAH,GAAO,CAA5C;AACA,QAAInE,QAAQ,GAAG4B,oBAAoB,CAACrC,gBAAgB,CAAC,CAAC1D,WAAD,CAAD,CAAjB,EAAkCU,QAAlC,EAA4CV,WAA5C,CAApB,CAA6E0B,KAA5F;;AAEA,QAAI,EAAEyC,QAAQ,GAAGxE,mBAAb,CAAJ,EAAuC;AACrCwE,MAAAA,QAAQ,GAAGxE,mBAAX;AACD;;AAED,WAAO;AACL6I,MAAAA,QAAQ,EAAE,UAAU/H,MAAV,EAAkBgC,IAAlB,EAAwB;AAChC,YAAIzB,KAAK,GAAGP,MAAM,CAACO,KAAnB;AACA,YAAIyH,WAAW,GAAG,IAAI7I,QAAJ,CAAaoB,KAAK,GAAG,CAArB,CAAlB;AACA,YAAI0H,qBAAqB,GAAG,IAAI9I,QAAJ,CAAaoB,KAAK,GAAG,CAArB,CAA5B;AACA,YAAI2H,gBAAgB,GAAG,IAAI/I,QAAJ,CAAaoB,KAAb,CAAvB;AACA,YAAI4H,SAAJ;AACA,YAAIhB,KAAK,GAAG,EAAZ;AACA,YAAIiB,SAAS,GAAG,EAAhB;AACA,YAAIC,YAAY,GAAG,CAAnB;AACA,YAAIC,SAAS,GAAG,CAAhB;;AAEA,eAAO,CAACH,SAAS,GAAGnI,MAAM,CAACuI,IAAP,EAAb,KAA+B,IAAtC,EAA4C;AAC1CH,UAAAA,SAAS,CAACN,WAAD,CAAT,GAAyB9F,IAAI,CAACxC,GAAL,CAAS0G,QAAT,EAAmBiC,SAAnB,CAAzB;AACAC,UAAAA,SAAS,CAAC,IAAIN,WAAL,CAAT,GAA6B9F,IAAI,CAACxC,GAAL,CAAS2G,OAAT,EAAkBgC,SAAlB,CAA7B;AACAhB,UAAAA,KAAK,GAAGtF,SAAS,CAACuF,WAAV,CAAsBgB,SAAtB,EAAiC,IAAjC,EAAuCjB,KAAvC,CAAR;AACAc,UAAAA,qBAAqB,CAACI,YAAD,CAArB,GAAsCR,mBAAmB,GAAGH,WAAW,CAACV,CAAZ,GAAgBU,WAAW,CAACzG,KAA/B,GAAuCkG,KAAK,CAAC,CAAD,CAArG;AACAa,UAAAA,WAAW,CAACK,YAAY,EAAb,CAAX,GAA8BlB,KAAK,CAAC,CAAD,CAAnC;AACAc,UAAAA,qBAAqB,CAACI,YAAD,CAArB,GAAsCR,mBAAmB,GAAGV,KAAK,CAAC,CAAD,CAAR,GAAcO,WAAW,CAACT,CAAZ,GAAgBS,WAAW,CAACR,MAAnG;AACAc,UAAAA,WAAW,CAACK,YAAY,EAAb,CAAX,GAA8BlB,KAAK,CAAC,CAAD,CAAnC;AACAe,UAAAA,gBAAgB,CAACI,SAAS,EAAV,CAAhB,GAAgCH,SAAhC;AACD;;AAEDnG,QAAAA,IAAI,CAACgE,SAAL,CAAe;AACbgC,UAAAA,WAAW,EAAEA,WADA;AAEbE,UAAAA,gBAAgB,EAAEA,gBAFL;AAGbD,UAAAA,qBAAqB,EAAEA,qBAHV;AAIbvE,UAAAA,QAAQ,EAAEA,QAJG;AAKb8C,UAAAA,cAAc,EAAEC,iBAAiB,CAACxG,QAAD,EAAW4F,SAAX,EAAsB,KAAtB,CALpB;AAMb2C,UAAAA,eAAe,EAAEX,mBAAmB,GAAGH,WAAW,CAACV,CAAf,GAAmBU,WAAW,CAACT,CANtD;AAObY,UAAAA,mBAAmB,EAAEA;AAPR,SAAf;AASD;AAhCI,KAAP;AAkCD;AAzDmB,CAAtB;;AA4DA,SAAStG,aAAT,CAAuBhC,WAAvB,EAAoC;AAClC,SAAOA,WAAW,CAACuC,gBAAZ,IAAgCvC,WAAW,CAACuC,gBAAZ,CAA6B3B,IAA7B,KAAsC,aAA7E;AACD;;AAED,SAASqB,aAAT,CAAuBjC,WAAvB,EAAoC;AAClC,SAAOA,WAAW,CAACkJ,eAAZ,IAA+BlJ,WAAW,CAACkJ,eAAZ,CAA4BC,KAAlE;AACD;;AAED,SAASjC,iBAAT,CAA2BxG,QAA3B,EAAqC4F,SAArC,EAAgDO,OAAhD,EAAyD;AACvD,SAAOP,SAAS,CAAC8C,aAAV,CAAwB9C,SAAS,CAAC+C,WAAV,CAAsB/C,SAAS,CAAC1F,IAAV,KAAmB,KAAnB,GAA2B,CAA3B,GAA+B,CAArD,CAAxB,CAAP;AACD","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar number_1 = require(\"../util/number\");\n\nvar dataStackHelper_1 = require(\"../data/helper/dataStackHelper\");\n\nvar createRenderPlanner_1 = require(\"../chart/helper/createRenderPlanner\");\n\nvar STACK_PREFIX = '__ec_stack_';\nvar LARGE_BAR_MIN_WIDTH = 0.5;\nvar LargeArr = typeof Float32Array !== 'undefined' ? Float32Array : Array;\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n\nfunction getLayoutOnAxis(opt) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nexports.getLayoutOnAxis = getLayoutOnAxis;\n\nfunction prepareLayoutBarSeries(seriesType, ecModel) {\n  var seriesModels = [];\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    if (isOnCartesian(seriesModel) && !isInLargeMode(seriesModel)) {\n      seriesModels.push(seriesModel);\n    }\n  });\n  return seriesModels;\n}\n\nexports.prepareLayoutBarSeries = prepareLayoutBarSeries;\n\nfunction getValueAxesMinGaps(barSeries) {\n  var axisValues = {};\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n\n    if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var key = baseAxis.dim + '_' + baseAxis.index;\n    var dim = data.mapDimension(baseAxis.dim);\n\n    for (var i = 0, cnt = data.count(); i < cnt; ++i) {\n      var value = data.get(dim, i);\n\n      if (!axisValues[key]) {\n        axisValues[key] = [value];\n      } else {\n        axisValues[key].push(value);\n      }\n    }\n  });\n  var axisMinGaps = {};\n\n  for (var key in axisValues) {\n    if (axisValues.hasOwnProperty(key)) {\n      var valuesInAxis = axisValues[key];\n\n      if (valuesInAxis) {\n        valuesInAxis.sort(function (a, b) {\n          return a - b;\n        });\n        var min = null;\n\n        for (var j = 1; j < valuesInAxis.length; ++j) {\n          var delta = valuesInAxis[j] - valuesInAxis[j - 1];\n\n          if (delta > 0) {\n            min = min === null ? delta : Math.min(min, delta);\n          }\n        }\n\n        axisMinGaps[key] = min;\n      }\n    }\n  }\n\n  return axisMinGaps;\n}\n\nfunction makeColumnLayout(barSeries) {\n  var axisMinGaps = getValueAxesMinGaps(barSeries);\n  var seriesInfoList = [];\n  zrUtil.each(barSeries, function (seriesModel) {\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth;\n\n    if (baseAxis.type === 'category') {\n      bandWidth = baseAxis.getBandWidth();\n    } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {\n      var key = baseAxis.dim + '_' + baseAxis.index;\n      var minGap = axisMinGaps[key];\n      var extentSpan = Math.abs(axisExtent[1] - axisExtent[0]);\n      var scale = baseAxis.scale.getExtent();\n      var scaleSpan = Math.abs(scale[1] - scale[0]);\n      bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan;\n    } else {\n      var data = seriesModel.getData();\n      bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    }\n\n    var barWidth = number_1.parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = number_1.parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barMinWidth = number_1.parsePercent(seriesModel.get('barMinWidth') || 1, bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    seriesInfoList.push({\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barMinWidth: barMinWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    });\n  });\n  return doCalBarWidthAndOffset(seriesInfoList);\n}\n\nexports.makeColumnLayout = makeColumnLayout;\n\nfunction doCalBarWidthAndOffset(seriesInfoList) {\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: null,\n      gap: '20%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    };\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barMinWidth = seriesInfo.barMinWidth;\n    barMinWidth && (stacks[stackId].minWidth = barMinWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGapPercent = columnsOnAxis.categoryGap;\n\n    if (categoryGapPercent == null) {\n      var columnCount = zrUtil.keys(stacks).length;\n      categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%';\n    }\n\n    var categoryGap = number_1.parsePercent(categoryGapPercent, bandWidth);\n    var barGapPercent = number_1.parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    zrUtil.each(stacks, function (column) {\n      var maxWidth = column.maxWidth;\n      var minWidth = column.minWidth;\n\n      if (!column.width) {\n        var finalWidth = autoWidth;\n\n        if (maxWidth && maxWidth < finalWidth) {\n          finalWidth = Math.min(maxWidth, remainedWidth);\n        }\n\n        if (minWidth && minWidth > finalWidth) {\n          finalWidth = minWidth;\n        }\n\n        if (finalWidth !== autoWidth) {\n          column.width = finalWidth;\n          remainedWidth -= finalWidth + barGapPercent * finalWidth;\n          autoWidthCount--;\n        }\n      } else {\n        var finalWidth = column.width;\n\n        if (maxWidth) {\n          finalWidth = Math.min(finalWidth, maxWidth);\n        }\n\n        if (minWidth) {\n          finalWidth = Math.max(finalWidth, minWidth);\n        }\n\n        column.width = finalWidth;\n        remainedWidth -= finalWidth + barGapPercent * finalWidth;\n        autoWidthCount--;\n      }\n    });\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        bandWidth: bandWidth,\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n\nfunction retrieveColumnLayout(barWidthAndOffset, axis, seriesModel) {\n  if (barWidthAndOffset && axis) {\n    var result = barWidthAndOffset[getAxisKey(axis)];\n\n    if (result != null && seriesModel != null) {\n      return result[getSeriesStackId(seriesModel)];\n    }\n\n    return result;\n  }\n}\n\nexports.retrieveColumnLayout = retrieveColumnLayout;\n\nfunction layout(seriesType, ecModel) {\n  var seriesModels = prepareLayoutBarSeries(seriesType, ecModel);\n  var barWidthAndOffset = makeColumnLayout(seriesModels);\n  var lastStackCoords = {};\n  zrUtil.each(seriesModels, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    data.setLayout({\n      bandWidth: columnLayoutInfo.bandWidth,\n      offset: columnOffset,\n      size: columnWidth\n    });\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var stacked = dataStackHelper_1.isDimensionStacked(data, valueDim);\n    var isValueAxisH = valueAxis.isHorizontal();\n    var valueAxisStart = getValueAxisStart(baseAxis, valueAxis, stacked);\n\n    for (var idx = 0, len = data.count(); idx < len; idx++) {\n      var value = data.get(valueDim, idx);\n      var baseValue = data.get(baseDim, idx);\n      var sign = value >= 0 ? 'p' : 'n';\n      var baseCoord = valueAxisStart;\n\n      if (stacked) {\n        if (!lastStackCoords[stackId][baseValue]) {\n          lastStackCoords[stackId][baseValue] = {\n            p: valueAxisStart,\n            n: valueAxisStart\n          };\n        }\n\n        baseCoord = lastStackCoords[stackId][baseValue][sign];\n      }\n\n      var x = void 0;\n      var y = void 0;\n      var width = void 0;\n      var height = void 0;\n\n      if (isValueAxisH) {\n        var coord = cartesian.dataToPoint([value, baseValue]);\n        x = baseCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - valueAxisStart;\n        height = columnWidth;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        if (!isNaN(width)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += width);\n        }\n      } else {\n        var coord = cartesian.dataToPoint([baseValue, value]);\n        x = coord[0] + columnOffset;\n        y = baseCoord;\n        width = columnWidth;\n        height = coord[1] - valueAxisStart;\n\n        if (Math.abs(height) < barMinHeight) {\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        if (!isNaN(height)) {\n          stacked && (lastStackCoords[stackId][baseValue][sign] += height);\n        }\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }\n  });\n}\n\nexports.layout = layout;\nexports.largeLayout = {\n  seriesType: 'bar',\n  plan: createRenderPlanner_1[\"default\"](),\n  reset: function (seriesModel) {\n    if (!isOnCartesian(seriesModel) || !isInLargeMode(seriesModel)) {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var coordLayout = cartesian.master.getRect();\n    var baseAxis = cartesian.getBaseAxis();\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var valueDim = data.mapDimension(valueAxis.dim);\n    var baseDim = data.mapDimension(baseAxis.dim);\n    var valueAxisHorizontal = valueAxis.isHorizontal();\n    var valueDimIdx = valueAxisHorizontal ? 0 : 1;\n    var barWidth = retrieveColumnLayout(makeColumnLayout([seriesModel]), baseAxis, seriesModel).width;\n\n    if (!(barWidth > LARGE_BAR_MIN_WIDTH)) {\n      barWidth = LARGE_BAR_MIN_WIDTH;\n    }\n\n    return {\n      progress: function (params, data) {\n        var count = params.count;\n        var largePoints = new LargeArr(count * 2);\n        var largeBackgroundPoints = new LargeArr(count * 2);\n        var largeDataIndices = new LargeArr(count);\n        var dataIndex;\n        var coord = [];\n        var valuePair = [];\n        var pointsOffset = 0;\n        var idxOffset = 0;\n\n        while ((dataIndex = params.next()) != null) {\n          valuePair[valueDimIdx] = data.get(valueDim, dataIndex);\n          valuePair[1 - valueDimIdx] = data.get(baseDim, dataIndex);\n          coord = cartesian.dataToPoint(valuePair, null, coord);\n          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coordLayout.x + coordLayout.width : coord[0];\n          largePoints[pointsOffset++] = coord[0];\n          largeBackgroundPoints[pointsOffset] = valueAxisHorizontal ? coord[1] : coordLayout.y + coordLayout.height;\n          largePoints[pointsOffset++] = coord[1];\n          largeDataIndices[idxOffset++] = dataIndex;\n        }\n\n        data.setLayout({\n          largePoints: largePoints,\n          largeDataIndices: largeDataIndices,\n          largeBackgroundPoints: largeBackgroundPoints,\n          barWidth: barWidth,\n          valueAxisStart: getValueAxisStart(baseAxis, valueAxis, false),\n          backgroundStart: valueAxisHorizontal ? coordLayout.x : coordLayout.y,\n          valueAxisHorizontal: valueAxisHorizontal\n        });\n      }\n    };\n  }\n};\n\nfunction isOnCartesian(seriesModel) {\n  return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n}\n\nfunction isInLargeMode(seriesModel) {\n  return seriesModel.pipelineContext && seriesModel.pipelineContext.large;\n}\n\nfunction getValueAxisStart(baseAxis, valueAxis, stacked) {\n  return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0));\n}"]},"metadata":{},"sourceType":"script"}