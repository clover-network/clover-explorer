{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { registerShape } from '@antv/g2';\nimport { get } from '@antv/util';\nimport { deepAssign } from '../../utils';\n/**\n * 获取柱子 path\n * @param points\n */\n\nfunction getRectPath(points) {\n  var path = [];\n\n  for (var i = 0; i < points.length; i++) {\n    var point = points[i];\n\n    if (point) {\n      var action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n\n  var first = points[0];\n  path.push(['L', first.x, first.y]);\n  path.push(['z']);\n  return path;\n}\n/**\n * 获取填充属性\n * @param cfg 图形绘制数据\n */\n\n\nfunction getFillAttrs(cfg) {\n  return deepAssign({}, cfg.defaultStyle, cfg.style, {\n    fill: cfg.color\n  });\n}\n\nregisterShape('interval', 'waterfall', {\n  draw: function (cfg, container) {\n    var customInfo = cfg.customInfo,\n        points = cfg.points,\n        nextPoints = cfg.nextPoints;\n    var group = container.addGroup(); // ① 绘制柱体\n\n    var rectPath = this.parsePath(getRectPath(points));\n    var fillAttrs = getFillAttrs(cfg);\n    group.addShape('path', {\n      attrs: __assign(__assign({}, fillAttrs), {\n        path: rectPath\n      })\n    }); // ② 绘制连接线\n\n    var leaderLineCfg = get(customInfo, 'leaderLine');\n\n    if (leaderLineCfg && nextPoints) {\n      var linkPath = [['M', points[2].x, points[2].y], ['L', nextPoints[0].x, nextPoints[0].y]];\n\n      if (points[2].y === nextPoints[1].y) {\n        linkPath[1] = ['L', nextPoints[1].x, nextPoints[1].y];\n      }\n\n      linkPath = this.parsePath(linkPath);\n      group.addShape('path', {\n        attrs: __assign({\n          path: linkPath\n        }, leaderLineCfg.style || {})\n      });\n    }\n\n    return group;\n  }\n});","map":{"version":3,"sources":["../../../src/plots/waterfall/shape.ts"],"names":[],"mappings":"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","sourcesContent":["import { IGroup } from '@antv/g-base';\nimport { registerShape } from '@antv/g2';\nimport { ShapeInfo } from '@antv/g2/lib/interface';\nimport { get } from '@antv/util';\nimport { deepAssign } from '../../utils';\nimport { Point } from '../../types';\n\n/**\n * 获取柱子 path\n * @param points\n */\nfunction getRectPath(points: Point[]) {\n  const path = [];\n  for (let i = 0; i < points.length; i++) {\n    const point = points[i];\n    if (point) {\n      const action = i === 0 ? 'M' : 'L';\n      path.push([action, point.x, point.y]);\n    }\n  }\n\n  const first = points[0];\n  path.push(['L', first.x, first.y]);\n  path.push(['z']);\n\n  return path;\n}\n\n/**\n * 获取填充属性\n * @param cfg 图形绘制数据\n */\nfunction getFillAttrs(cfg: ShapeInfo) {\n  return deepAssign({}, cfg.defaultStyle, cfg.style, { fill: cfg.color });\n}\n\nregisterShape('interval', 'waterfall', {\n  draw(cfg: ShapeInfo & { points: Point[]; nextPoints: Point[] }, container: IGroup) {\n    const { customInfo, points, nextPoints } = cfg;\n\n    const group = container.addGroup();\n\n    // ① 绘制柱体\n    const rectPath = this.parsePath(getRectPath(points));\n    const fillAttrs = getFillAttrs(cfg);\n\n    group.addShape('path', {\n      attrs: {\n        ...fillAttrs,\n        path: rectPath,\n      },\n    });\n\n    // ② 绘制连接线\n    const leaderLineCfg = get(customInfo, 'leaderLine');\n    if (leaderLineCfg && nextPoints) {\n      let linkPath = [\n        ['M', points[2].x, points[2].y],\n        ['L', nextPoints[0].x, nextPoints[0].y],\n      ];\n\n      if (points[2].y === nextPoints[1].y) {\n        linkPath[1] = ['L', nextPoints[1].x, nextPoints[1].y];\n      }\n\n      linkPath = this.parsePath(linkPath);\n      group.addShape('path', {\n        attrs: {\n          path: linkPath,\n          ...(leaderLineCfg.style || {}),\n        },\n      });\n    }\n\n    return group;\n  },\n});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}