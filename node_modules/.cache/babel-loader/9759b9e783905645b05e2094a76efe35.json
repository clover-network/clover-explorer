{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport { BaseLayout } from './layout';\nimport { getDegree } from '../util/math';\nimport { clone } from '@antv/util';\n\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n  nodes.forEach(function (_, i) {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n\n  if (directed) {\n    edges.forEach(function (e) {\n      var sourceIdx = 0;\n\n      if (e.source) {\n        sourceIdx = nodeMap[e.source];\n      }\n\n      var targetIdx = 0;\n\n      if (e.target) {\n        targetIdx = nodeMap[e.target];\n      }\n\n      nodes[sourceIdx].children.push(nodes[targetIdx].id);\n      nodes[targetIdx].parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach(function (e) {\n      var sourceIdx = 0;\n\n      if (e.source) {\n        sourceIdx = nodeMap[e.source];\n      }\n\n      var targetIdx = 0;\n\n      if (e.target) {\n        targetIdx = nodeMap[e.target];\n      }\n\n      nodes[sourceIdx].children.push(nodes[targetIdx].id);\n      nodes[targetIdx].children.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a, b, edges) {\n  var m = edges.length;\n\n  for (var i = 0; i < m; i++) {\n    if (a.id === edges[i].source && b.id === edges[i].target || b.id === edges[i].source && a.id === edges[i].target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction compareDegree(a, b) {\n  if (a.degree < b.degree) {\n    return -1;\n  }\n\n  if (a.degree > b.degree) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * 圆形布局\n */\n\n\nvar CircularLayout =\n/** @class */\nfunction (_super) {\n  __extends(CircularLayout, _super);\n\n  function CircularLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n\n    _this.radius = null;\n    /** 起始半径 */\n\n    _this.startRadius = null;\n    /** 终止半径 */\n\n    _this.endRadius = null;\n    /** 起始角度 */\n\n    _this.startAngle = 0;\n    /** 终止角度 */\n\n    _this.endAngle = 2 * Math.PI;\n    /** 是否顺时针 */\n\n    _this.clockwise = true;\n    /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n\n    _this.divisions = 1;\n    /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n\n    _this.ordering = null;\n    /** how many 2*pi from first to last nodes */\n\n    _this.angleRatio = 1;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.nodeMap = {};\n    _this.degrees = [];\n    _this.width = 300;\n    _this.height = 300;\n    return _this;\n  }\n\n  CircularLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      radius: null,\n      startRadius: null,\n      endRadius: null,\n      startAngle: 0,\n      endAngle: 2 * Math.PI,\n      clockwise: true,\n      divisions: 1,\n      ordering: null,\n      angleRatio: 1\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  CircularLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var edges = self.edges;\n    var n = nodes.length;\n    var center = self.center;\n\n    if (n === 0) {\n      return;\n    }\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var radius = self.radius;\n    var startRadius = self.startRadius;\n    var endRadius = self.endRadius;\n    var divisions = self.divisions;\n    var startAngle = self.startAngle;\n    var endAngle = self.endAngle;\n    var angleStep = (endAngle - startAngle) / n; // layout\n\n    var nodeMap = {};\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    var degrees = getDegree(nodes.length, nodeMap, edges);\n    self.degrees = degrees;\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    if (!radius && !startRadius && !endRadius) {\n      radius = self.height > self.width ? self.width / 2 : self.height / 2;\n    } else if (!startRadius && endRadius) {\n      startRadius = endRadius;\n    } else if (startRadius && !endRadius) {\n      endRadius = startRadius;\n    }\n\n    var angleRatio = self.angleRatio;\n    var astep = angleStep * angleRatio;\n    self.astep = astep;\n    var ordering = self.ordering;\n    var layoutNodes = [];\n\n    if (ordering === 'topology') {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering();\n    } else if (ordering === 'topology-directed') {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering(true);\n    } else if (ordering === 'degree') {\n      // layout according to the descent order of degrees\n      layoutNodes = self.degreeOrdering();\n    } else {\n      // layout according to the original order in the data.nodes\n      layoutNodes = nodes;\n    }\n\n    var clockwise = self.clockwise;\n    var divN = Math.ceil(n / divisions); // node number in each division\n\n    for (var i = 0; i < n; ++i) {\n      var r = radius;\n\n      if (!r && startRadius !== null && endRadius !== null) {\n        r = startRadius + i * (endRadius - startRadius) / (n - 1);\n      }\n\n      if (!r) {\n        r = 10 + i * 100 / (n - 1);\n      }\n\n      var angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n\n      if (!clockwise) {\n        angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n      }\n\n      layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n      layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n      layoutNodes[i].weight = degrees[i];\n    }\n  };\n  /**\n   * 根据节点的拓扑结构排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  CircularLayout.prototype.topologyOrdering = function (directed) {\n    if (directed === void 0) {\n      directed = false;\n    }\n\n    var self = this;\n    var degrees = self.degrees;\n    var edges = self.edges;\n    var nodes = self.nodes;\n    var cnodes = clone(nodes);\n    var nodeMap = self.nodeMap;\n    var orderedCNodes = [cnodes[0]];\n    var resNodes = [nodes[0]];\n    var pickFlags = [];\n    var n = nodes.length;\n    pickFlags[0] = true;\n    initHierarchy(cnodes, edges, nodeMap, directed);\n    var k = 0;\n    cnodes.forEach(function (cnode, i) {\n      if (i !== 0) {\n        if ((i === n - 1 || degrees[i] !== degrees[i + 1] || connect(orderedCNodes[k], cnode, edges)) && pickFlags[i] !== true) {\n          orderedCNodes.push(cnode);\n          resNodes.push(nodes[nodeMap[cnode.id]]);\n          pickFlags[i] = true;\n          k++;\n        } else {\n          var children = orderedCNodes[k].children;\n          var foundChild = false;\n\n          for (var j = 0; j < children.length; j++) {\n            var childIdx = nodeMap[children[j]];\n\n            if (degrees[childIdx] === degrees[i] && pickFlags[childIdx] !== true) {\n              orderedCNodes.push(cnodes[childIdx]);\n              resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n              pickFlags[childIdx] = true;\n              foundChild = true;\n              break;\n            }\n          }\n\n          var ii = 0;\n\n          while (!foundChild) {\n            if (!pickFlags[ii]) {\n              orderedCNodes.push(cnodes[ii]);\n              resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n              pickFlags[ii] = true;\n              foundChild = true;\n            }\n\n            ii++;\n\n            if (ii === n) {\n              break;\n            }\n          }\n        }\n      }\n    });\n    return resNodes;\n  };\n  /**\n   * 根据节点度数大小排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  CircularLayout.prototype.degreeOrdering = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var orderedNodes = [];\n    var degrees = self.degrees;\n    nodes.forEach(function (node, i) {\n      node.degree = degrees[i];\n      orderedNodes.push(node);\n    });\n    orderedNodes.sort(compareDegree);\n    return orderedNodes;\n  };\n\n  return CircularLayout;\n}(BaseLayout);\n\nexport default CircularLayout;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/circular.js"],"names":["__extends","BaseLayout","getDegree","clone","initHierarchy","nodes","edges","nodeMap","directed","forEach","_","i","children","parent","e","sourceIdx","source","targetIdx","target","push","id","connect","a","b","m","length","compareDegree","degree","CircularLayout","_super","_this","apply","arguments","center","radius","startRadius","endRadius","startAngle","endAngle","Math","PI","clockwise","divisions","ordering","angleRatio","degrees","width","height","prototype","getDefaultCfg","execute","self","n","x","y","angleStep","node","window","innerWidth","innerHeight","astep","layoutNodes","topologyOrdering","degreeOrdering","divN","ceil","r","angle","floor","cos","sin","weight","cnodes","orderedCNodes","resNodes","pickFlags","k","cnode","foundChild","j","childIdx","ii","orderedNodes","sort"],"mappings":"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","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport { BaseLayout } from './layout';\nimport { getDegree } from '../util/math';\nimport { clone } from '@antv/util';\n\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n  nodes.forEach(function (_, i) {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n\n  if (directed) {\n    edges.forEach(function (e) {\n      var sourceIdx = 0;\n\n      if (e.source) {\n        sourceIdx = nodeMap[e.source];\n      }\n\n      var targetIdx = 0;\n\n      if (e.target) {\n        targetIdx = nodeMap[e.target];\n      }\n\n      nodes[sourceIdx].children.push(nodes[targetIdx].id);\n      nodes[targetIdx].parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach(function (e) {\n      var sourceIdx = 0;\n\n      if (e.source) {\n        sourceIdx = nodeMap[e.source];\n      }\n\n      var targetIdx = 0;\n\n      if (e.target) {\n        targetIdx = nodeMap[e.target];\n      }\n\n      nodes[sourceIdx].children.push(nodes[targetIdx].id);\n      nodes[targetIdx].children.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a, b, edges) {\n  var m = edges.length;\n\n  for (var i = 0; i < m; i++) {\n    if (a.id === edges[i].source && b.id === edges[i].target || b.id === edges[i].source && a.id === edges[i].target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction compareDegree(a, b) {\n  if (a.degree < b.degree) {\n    return -1;\n  }\n\n  if (a.degree > b.degree) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * 圆形布局\n */\n\n\nvar CircularLayout =\n/** @class */\nfunction (_super) {\n  __extends(CircularLayout, _super);\n\n  function CircularLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n\n    _this.radius = null;\n    /** 起始半径 */\n\n    _this.startRadius = null;\n    /** 终止半径 */\n\n    _this.endRadius = null;\n    /** 起始角度 */\n\n    _this.startAngle = 0;\n    /** 终止角度 */\n\n    _this.endAngle = 2 * Math.PI;\n    /** 是否顺时针 */\n\n    _this.clockwise = true;\n    /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n\n    _this.divisions = 1;\n    /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n\n    _this.ordering = null;\n    /** how many 2*pi from first to last nodes */\n\n    _this.angleRatio = 1;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.nodeMap = {};\n    _this.degrees = [];\n    _this.width = 300;\n    _this.height = 300;\n    return _this;\n  }\n\n  CircularLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      radius: null,\n      startRadius: null,\n      endRadius: null,\n      startAngle: 0,\n      endAngle: 2 * Math.PI,\n      clockwise: true,\n      divisions: 1,\n      ordering: null,\n      angleRatio: 1\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  CircularLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var edges = self.edges;\n    var n = nodes.length;\n    var center = self.center;\n\n    if (n === 0) {\n      return;\n    }\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var radius = self.radius;\n    var startRadius = self.startRadius;\n    var endRadius = self.endRadius;\n    var divisions = self.divisions;\n    var startAngle = self.startAngle;\n    var endAngle = self.endAngle;\n    var angleStep = (endAngle - startAngle) / n; // layout\n\n    var nodeMap = {};\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n    });\n    self.nodeMap = nodeMap;\n    var degrees = getDegree(nodes.length, nodeMap, edges);\n    self.degrees = degrees;\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    if (!radius && !startRadius && !endRadius) {\n      radius = self.height > self.width ? self.width / 2 : self.height / 2;\n    } else if (!startRadius && endRadius) {\n      startRadius = endRadius;\n    } else if (startRadius && !endRadius) {\n      endRadius = startRadius;\n    }\n\n    var angleRatio = self.angleRatio;\n    var astep = angleStep * angleRatio;\n    self.astep = astep;\n    var ordering = self.ordering;\n    var layoutNodes = [];\n\n    if (ordering === 'topology') {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering();\n    } else if (ordering === 'topology-directed') {\n      // layout according to the topology\n      layoutNodes = self.topologyOrdering(true);\n    } else if (ordering === 'degree') {\n      // layout according to the descent order of degrees\n      layoutNodes = self.degreeOrdering();\n    } else {\n      // layout according to the original order in the data.nodes\n      layoutNodes = nodes;\n    }\n\n    var clockwise = self.clockwise;\n    var divN = Math.ceil(n / divisions); // node number in each division\n\n    for (var i = 0; i < n; ++i) {\n      var r = radius;\n\n      if (!r && startRadius !== null && endRadius !== null) {\n        r = startRadius + i * (endRadius - startRadius) / (n - 1);\n      }\n\n      if (!r) {\n        r = 10 + i * 100 / (n - 1);\n      }\n\n      var angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n\n      if (!clockwise) {\n        angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n      }\n\n      layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n      layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n      layoutNodes[i].weight = degrees[i];\n    }\n  };\n  /**\n   * 根据节点的拓扑结构排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  CircularLayout.prototype.topologyOrdering = function (directed) {\n    if (directed === void 0) {\n      directed = false;\n    }\n\n    var self = this;\n    var degrees = self.degrees;\n    var edges = self.edges;\n    var nodes = self.nodes;\n    var cnodes = clone(nodes);\n    var nodeMap = self.nodeMap;\n    var orderedCNodes = [cnodes[0]];\n    var resNodes = [nodes[0]];\n    var pickFlags = [];\n    var n = nodes.length;\n    pickFlags[0] = true;\n    initHierarchy(cnodes, edges, nodeMap, directed);\n    var k = 0;\n    cnodes.forEach(function (cnode, i) {\n      if (i !== 0) {\n        if ((i === n - 1 || degrees[i] !== degrees[i + 1] || connect(orderedCNodes[k], cnode, edges)) && pickFlags[i] !== true) {\n          orderedCNodes.push(cnode);\n          resNodes.push(nodes[nodeMap[cnode.id]]);\n          pickFlags[i] = true;\n          k++;\n        } else {\n          var children = orderedCNodes[k].children;\n          var foundChild = false;\n\n          for (var j = 0; j < children.length; j++) {\n            var childIdx = nodeMap[children[j]];\n\n            if (degrees[childIdx] === degrees[i] && pickFlags[childIdx] !== true) {\n              orderedCNodes.push(cnodes[childIdx]);\n              resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n              pickFlags[childIdx] = true;\n              foundChild = true;\n              break;\n            }\n          }\n\n          var ii = 0;\n\n          while (!foundChild) {\n            if (!pickFlags[ii]) {\n              orderedCNodes.push(cnodes[ii]);\n              resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n              pickFlags[ii] = true;\n              foundChild = true;\n            }\n\n            ii++;\n\n            if (ii === n) {\n              break;\n            }\n          }\n        }\n      }\n    });\n    return resNodes;\n  };\n  /**\n   * 根据节点度数大小排序\n   * @return {array} orderedNodes 排序后的结果\n   */\n\n\n  CircularLayout.prototype.degreeOrdering = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var orderedNodes = [];\n    var degrees = self.degrees;\n    nodes.forEach(function (node, i) {\n      node.degree = degrees[i];\n      orderedNodes.push(node);\n    });\n    orderedNodes.sort(compareDegree);\n    return orderedNodes;\n  };\n\n  return CircularLayout;\n}(BaseLayout);\n\nexport default CircularLayout;"]},"metadata":{},"sourceType":"module"}