{"ast":null,"code":"import { vec2 } from '@antv/matrix-util';\nexport function points2Path(points, isInCircle) {\n  var path = [];\n\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n\n    for (var i = 1, length_1 = points.length; i < length_1; i += 1) {\n      var item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n\n  return path;\n}\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\n\nexport var smoothBezier = function (points, smooth, isLoop, constraint) {\n  var cps = [];\n  var prevPoint;\n  var nextPoint;\n  var hasConstraint = !!constraint;\n  var min;\n  var max;\n\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, l = points.length; i < l; i++) {\n      var point = points[i];\n      min = vec2.min([0, 0], min, point);\n      max = vec2.max([0, 0], max, point);\n    }\n\n    min = vec2.min([0, 0], min, constraint[0]);\n    max = vec2.max([0, 0], max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    var v = [0, 0];\n    v = vec2.sub(v, nextPoint, prevPoint);\n    v = vec2.scale(v, v, smooth);\n    var d0 = vec2.distance(point, prevPoint);\n    var d1 = vec2.distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    var v1 = vec2.scale([0, 0], v, -d0);\n    var v2 = vec2.scale([0, 0], v, d1);\n    var cp0 = vec2.add([0, 0], point, v1);\n    var cp1 = vec2.add([0, 0], point, v2);\n\n    if (hasConstraint) {\n      cp0 = vec2.max([0, 0], cp0, min);\n      cp0 = vec2.min([0, 0], cp0, max);\n      cp1 = vec2.max([0, 0], cp1, min);\n      cp1 = vec2.min([0, 0], cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n};\n/**\n * @ignore\n * 贝塞尔曲线\n */\n\nexport function catmullRom2bezier(crp, z, constraint) {\n  var isLoop = !!z;\n  var pointList = [];\n\n  for (var i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  return d1;\n}\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\n\nexport function getSplinePath(points, isInCircle, constaint) {\n  var data = [];\n  var first = points[0];\n  var prePoint = null;\n\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return points2Path(points, isInCircle);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n\n  var constraint = constaint || [// 范围\n  [0, 0], [1, 1]];\n  var splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}","map":{"version":3,"sources":["../../src/utils/path.ts"],"names":[],"mappings":"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","sourcesContent":["import { vec2 } from '@antv/matrix-util';\nimport { Position, Point } from '@antv/g2/lib/interface';\n\nexport function points2Path(points: Point[], isInCircle: boolean) {\n  const path = [];\n  if (points.length) {\n    path.push(['M', points[0].x, points[0].y]);\n    for (let i = 1, length = points.length; i < length; i += 1) {\n      const item = points[i];\n      path.push(['L', item.x, item.y]);\n    }\n    if (isInCircle) {\n      path.push(['Z']);\n    }\n  }\n  return path;\n}\n\n/**\n * @ignore\n * 计算光滑的贝塞尔曲线\n */\nexport const smoothBezier = (\n  points: Position[],\n  smooth: number,\n  isLoop: boolean,\n  constraint: Position[]\n): Position[] => {\n  const cps = [];\n  let prevPoint: Position;\n  let nextPoint: Position;\n  const hasConstraint = !!constraint;\n  let min: Position;\n  let max: Position;\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      min = vec2.min([0, 0], min, point) as [number, number];\n      max = vec2.max([0, 0], max, point) as [number, number];\n    }\n    min = vec2.min([0, 0], min, constraint[0]) as [number, number];\n    max = vec2.max([0, 0], max, constraint[1]) as [number, number];\n  }\n\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(point);\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n    let v: [number, number] = [0, 0];\n    v = vec2.sub(v, nextPoint, prevPoint) as [number, number];\n    v = vec2.scale(v, v, smooth) as [number, number];\n\n    let d0 = vec2.distance(point, prevPoint);\n    let d1 = vec2.distance(point, nextPoint);\n\n    const sum = d0 + d1;\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    const v1 = vec2.scale([0, 0], v, -d0);\n    const v2 = vec2.scale([0, 0], v, d1);\n\n    let cp0 = vec2.add([0, 0], point, v1);\n    let cp1 = vec2.add([0, 0], point, v2);\n\n    if (hasConstraint) {\n      cp0 = vec2.max([0, 0], cp0, min);\n      cp0 = vec2.min([0, 0], cp0, max);\n      cp1 = vec2.max([0, 0], cp1, min);\n      cp1 = vec2.min([0, 0], cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n  return cps;\n};\n\n/**\n * @ignore\n * 贝塞尔曲线\n */\nexport function catmullRom2bezier(crp: number[], z: boolean, constraint: Position[]) {\n  const isLoop = !!z;\n  const pointList = [];\n  for (let i = 0, l = crp.length; i < l; i += 2) {\n    pointList.push([crp[i], crp[i + 1]]);\n  }\n\n  const controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  const len = pointList.length;\n  const d1 = [];\n\n  let cp1: Position;\n  let cp2: Position;\n  let p: Position;\n\n  for (let i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);\n  }\n  return d1;\n}\n\n/**\n * @ignore\n * 根据关键点获取限定了范围的平滑线\n */\nexport function getSplinePath(points: Point[], isInCircle?: boolean, constaint?: Position[]) {\n  const data = [];\n  const first = points[0];\n  let prePoint = null;\n  if (points.length <= 2) {\n    // 两点以内直接绘制成路径\n    return points2Path(points, isInCircle);\n  }\n  for (let i = 0, len = points.length; i < len; i++) {\n    const point = points[i];\n    if (!prePoint || !(prePoint.x === point.x && prePoint.y === point.y)) {\n      data.push(point.x);\n      data.push(point.y);\n      prePoint = point;\n    }\n  }\n  const constraint = constaint || [\n    // 范围\n    [0, 0],\n    [1, 1],\n  ];\n  const splinePath = catmullRom2bezier(data, isInCircle, constraint);\n  splinePath.unshift(['M', first.x, first.y]);\n  return splinePath;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}