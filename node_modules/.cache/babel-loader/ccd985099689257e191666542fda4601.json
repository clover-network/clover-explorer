{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model_1 = require(\"../model/Model\");\n\nvar DataDiffer_1 = require(\"./DataDiffer\");\n\nvar dataProvider_1 = require(\"./helper/dataProvider\");\n\nvar dimensionHelper_1 = require(\"./helper/dimensionHelper\");\n\nvar DataDimensionInfo_1 = require(\"./DataDimensionInfo\");\n\nvar types_1 = require(\"../util/types\");\n\nvar model_1 = require(\"../util/model\");\n\nvar innerStore_1 = require(\"../util/innerStore\");\n\nvar dataValueHelper_1 = require(\"./helper/dataValueHelper\");\n\nvar Source_1 = require(\"./Source\");\n\nvar mathFloor = Math.floor;\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1;\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\nvar defaultDimValueGetters;\nvar prepareInvertedIndex;\nvar getIndicesCtor;\nvar prepareStorage;\nvar getRawIndexWithoutIndices;\nvar getRawIndexWithIndices;\nvar getId;\nvar getIdNameFromStore;\nvar makeIdFromName;\nvar normalizeDimensions;\nvar validateDimensions;\nvar cloneListForMapAndSample;\nvar getInitialExtent;\nvar setItemDataAndSeriesIndex;\nvar transferProperties;\n\nvar List = function () {\n  function List(dimensions, hostModel) {\n    this.type = 'list';\n    this._count = 0;\n    this._rawCount = 0;\n    this._storage = {};\n    this._storageArr = [];\n    this._nameList = [];\n    this._idList = [];\n    this._visual = {};\n    this._layout = {};\n    this._itemVisuals = [];\n    this._itemLayouts = [];\n    this._graphicEls = [];\n    this._rawExtent = {};\n    this._extent = {};\n    this._approximateExtent = {};\n    this._calculationInfo = {};\n    this.hasItemOption = true;\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    this.getRawIndex = getRawIndexWithoutIndices;\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new DataDimensionInfo_1[\"default\"]({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof DataDimensionInfo_1[\"default\"]) ? new DataDimensionInfo_1[\"default\"](dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      dimensionInfo.index = i;\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n        this._nameOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n        this._idOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimensionInfos = dimensionInfos;\n    this.hostModel = hostModel;\n    this._dimensionsSummary = dimensionHelper_1.summarizeDimensions(this);\n    this._invertedIndicesMap = invertedIndicesMap;\n    this.userOutput = this._dimensionsSummary.userOutput;\n  }\n\n  List.prototype.getDimension = function (dim) {\n    if (typeof dim === 'number' || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n      dim = this.dimensions[dim];\n    }\n\n    return dim;\n  };\n\n  List.prototype.getDimensionInfo = function (dim) {\n    return this._dimensionInfos[this.getDimension(dim)];\n  };\n\n  List.prototype.getDimensionsOnCoord = function () {\n    return this._dimensionsSummary.dataDimsOnCoord.slice();\n  };\n\n  List.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimensionsSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  List.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimensionsSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  List.prototype.initData = function (data, nameList, dimValueGetter) {\n    var notProvider = Source_1.isSourceInstance(data) || zrUtil.isArrayLike(data);\n    var provider = notProvider ? new dataProvider_1.DefaultDataProvider(data, this.dimensions.length) : data;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(notProvider || zrUtil.isFunction(provider.getItem) && zrUtil.isFunction(provider.count), 'Inavlid data provider.');\n    }\n\n    this._rawData = provider;\n    var sourceFormat = provider.getSource().sourceFormat;\n    this._storage = {};\n    this._indices = null;\n    this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY || !!provider.fillStorage;\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    if (!dimValueGetter) {\n      this.hasItemOption = false;\n    }\n\n    this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat];\n    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n    this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;\n    this._rawExtent = {};\n\n    this._initDataFromProvider(0, provider.count());\n\n    if (provider.pure) {\n      this.hasItemOption = false;\n    }\n  };\n\n  List.prototype.getProvider = function () {\n    return this._rawData;\n  };\n\n  List.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var rawData = this._rawData;\n    var start = this.count();\n    rawData.appendData(data);\n    var end = rawData.count();\n\n    if (!rawData.persistent) {\n      end += start;\n    }\n\n    this._initDataFromProvider(start, end, true);\n  };\n\n  List.prototype.appendValues = function (values, names) {\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, names ? names.length : 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, this._dimensionInfos[dim], end, true);\n    }\n\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start;\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n\n        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);\n\n        storageArr[dimIdx][idx] = val;\n        var dimRawExtent = rawExtentArr[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n\n      if (names) {\n        this._nameList[idx] = names[sourceIdx];\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype._initDataFromProvider = function (start, end, append) {\n    if (start >= end) {\n      return;\n    }\n\n    var rawData = this._rawData;\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var dimensionInfoMap = this._dimensionInfos;\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var rawExtent = this._rawExtent;\n    var sourceFormat = rawData.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL;\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, dimensionInfoMap[dim], end, append);\n    }\n\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n\n    if (rawData.fillStorage) {\n      rawData.fillStorage(start, end, storageArr, rawExtentArr);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        dataItem = rawData.getItem(idx, dataItem);\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dim = dimensions[dimIdx];\n          var dimStorage = storageArr[dimIdx];\n\n          var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtentArr[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n\n        if (isFormatOriginal && !rawData.pure && dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = model_1.convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = model_1.convertOptionIdName(itemId, null);\n          }\n        }\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    if (!rawData.persistent && rawData.clean) {\n      rawData.clean();\n    }\n\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype.count = function () {\n    return this._count;\n  };\n\n  List.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count;\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n\n  List.prototype.getByDimIdx = function (dimIdx, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storageArr[dimIdx];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  List.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  List.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n\n  List.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n\n    if (!zrUtil.isArray(dimensions)) {\n      idx = dimensions;\n      dimensions = this.dimensions;\n    }\n\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n      values.push(this.get(dimensions[i], idx));\n    }\n\n    return values;\n  };\n\n  List.prototype.hasValue = function (idx) {\n    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  List.prototype.getDataExtent = function (dim) {\n    dim = this.getDimension(dim);\n    var dimData = this._storage[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    }\n\n    var currEnd = this.count();\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n\n  List.prototype.getApproximateExtent = function (dim) {\n    dim = this.getDimension(dim);\n    return this._approximateExtent[dim] || this.getDataExtent(dim);\n  };\n\n  List.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  List.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  List.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n\n  List.prototype.getSum = function (dim) {\n    var dimData = this._storage[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n\n  List.prototype.getMedian = function (dim) {\n    var dimDataArray = [];\n    this.each(dim, function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    });\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count();\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n\n  List.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n\n  List.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  List.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    }\n\n    var indices = this._indices;\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n\n  List.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  List.prototype.getRawDataItem = function (idx) {\n    if (!this._rawData.persistent) {\n      var val = [];\n\n      for (var i = 0; i < this.dimensions.length; i++) {\n        var dim = this.dimensions[i];\n        val.push(this.get(dim, idx));\n      }\n\n      return val;\n    } else {\n      return this._rawData.getItem(this.getRawIndex(idx));\n    }\n  };\n\n  List.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  List.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  List.prototype.each = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var dimSize = dimNames.length;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var storageArr = this._storageArr;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i);\n\n      switch (dimSize) {\n        case 0:\n          cb.call(fCtx, i);\n          break;\n\n        case 1:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = storageArr[dimIndices[k]][rawIdx];\n          }\n\n          value[k] = i;\n          cb.apply(fCtx, value);\n      }\n    }\n  };\n\n  List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var count = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dimNames.length;\n    var offset = 0;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var dim0 = dimIndices[0];\n    var storageArr = this._storageArr;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = this.getRawIndex(i);\n\n      if (dimSize === 0) {\n        keep = cb.call(fCtx, i);\n      } else if (dimSize === 1) {\n        var val = storageArr[dim0][rawIdx];\n        keep = cb.call(fCtx, val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = storageArr[dimIndices[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(fCtx, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    }\n\n    if (offset < count) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n\n  List.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var len = this._count;\n\n    if (!len) {\n      return;\n    }\n\n    var dimensions = [];\n\n    for (var dim in range) {\n      if (range.hasOwnProperty(dim)) {\n        dimensions.push(dim);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimensions);\n    }\n\n    var dimSize = dimensions.length;\n\n    if (!dimSize) {\n      return;\n    }\n\n    var originalCount = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dimensions[0];\n    var dimIndices = map(dimensions, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storageArr = this._storageArr;\n    var quickFinished = false;\n\n    if (!this._indices) {\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storageArr[dimIndices[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storageArr[dimIndices[0]];\n        var dimStorage2 = storageArr[dimIndices[1]];\n        var min2 = range[dimensions[1]][0];\n        var max2 = range[dimensions[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i];\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = this.getRawIndex(i);\n          var val = storageArr[dimIndices[0]][rawIndex];\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = this.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dimensions[k];\n            var val = storageArr[dimIndices[k]][rawIndex];\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = this.getRawIndex(i);\n          }\n        }\n      }\n    }\n\n    if (offset < originalCount) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n\n  List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    ctx = ctx || ctxCompat || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  List.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var list = cloneListForMapAndSample(this, dimNames);\n    var storage = list._storage;\n    list._indices = this._indices;\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    var tmpRetValue = [];\n    var dimSize = dimNames.length;\n    var dataCount = this.count();\n    var values = [];\n    var rawExtent = list._rawExtent;\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n        values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(fCtx, values);\n\n      if (retValue != null) {\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        var rawIndex = this.getRawIndex(dataIndex);\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dimNames[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = storage[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n\n    return list;\n  };\n\n  List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this, [dimension]);\n    var targetStorage = list._storage;\n    var frameValues = [];\n    var frameSize = mathFloor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = list._rawExtent[dimension];\n    var newIndices = new (getIndicesCtor(this))(len);\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    list._count = offset;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n\n  List.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this, []);\n    var targetStorage = list._storage;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var newIndices = new (getIndicesCtor(this))(len);\n    var sampledIndex = 0;\n    var frameSize = mathFloor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex;\n        }\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex;\n    }\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    list._count = sampledIndex;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n\n  List.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model_1[\"default\"](dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n\n  List.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer_1[\"default\"](otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n\n  List.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  List.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n\n  List.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n\n  List.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n\n  List.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key);\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  };\n\n  List.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n\n  List.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  List.prototype.setLayout = function (key, val) {\n    if (isObject(key)) {\n      for (var name_1 in key) {\n        if (key.hasOwnProperty(name_1)) {\n          this.setLayout(name_1, key[name_1]);\n        }\n      }\n\n      return;\n    }\n\n    this._layout[key] = val;\n  };\n\n  List.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n\n  List.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n\n  List.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n\n  List.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n\n  List.prototype.setItemGraphicEl = function (idx, el) {\n    var hostModel = this.hostModel;\n\n    if (el) {\n      var ecData = innerStore_1.getECData(el);\n      ecData.dataIndex = idx;\n      ecData.dataType = this.dataType;\n      ecData.seriesIndex = hostModel && hostModel.seriesIndex;\n\n      if (el.type === 'group') {\n        el.traverse(setItemDataAndSeriesIndex, el);\n      }\n    }\n\n    this._graphicEls[idx] = el;\n  };\n\n  List.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  List.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n\n  List.prototype.cloneShallow = function (list) {\n    if (!list) {\n      var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);\n      list = new List(dimensionInfoList, this.hostModel);\n    }\n\n    list._storage = this._storage;\n    list._storageArr = this._storageArr;\n    transferProperties(list, this);\n\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        list._indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          list._indices[i] = this._indices[i];\n        }\n      } else {\n        list._indices = new Ctor(this._indices);\n      }\n    } else {\n      list._indices = null;\n    }\n\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return list;\n  };\n\n  List.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (typeof originalMethod !== 'function') {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  };\n\n  List.internalField = function () {\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataValueHelper_1.parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, dimName, dataIndex, dimIndex) {\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\n        if (!this._rawData.pure && model_1.isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        return dataValueHelper_1.parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);\n      },\n      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n\n    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {\n      return dataValueHelper_1.parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);\n    }\n\n    prepareInvertedIndex = function (list) {\n      var invertedIndicesMap = list._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = list._dimensionInfos[dim];\n        var ordinalMeta = dimInfo.ordinalMeta;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < list._count; i++) {\n            invertedIndices[list.get(dim, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {\n      var val;\n      var chunk = list._storageArr[dimIdx];\n\n      if (chunk) {\n        val = chunk[rawIndex];\n\n        if (ordinalMeta && ordinalMeta.categories.length) {\n          val = ordinalMeta.categories[val];\n        }\n      }\n\n      return model_1.convertOptionIdName(val, null);\n    };\n\n    getIndicesCtor = function (list) {\n      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n    };\n\n    prepareStorage = function (storage, dimInfo, end, append) {\n      var DataCtor = dataCtors[dimInfo.type];\n      var dim = dimInfo.name;\n\n      if (append) {\n        var oldStore = storage[dim];\n        var oldLen = oldStore && oldStore.length;\n\n        if (!(oldLen === end)) {\n          var newStore = new DataCtor(end);\n\n          for (var j = 0; j < oldLen; j++) {\n            newStore[j] = oldStore[j];\n          }\n\n          storage[dim] = newStore;\n        }\n      } else {\n        storage[dim] = new DataCtor(end);\n      }\n    };\n\n    getRawIndexWithoutIndices = function (idx) {\n      return idx;\n    };\n\n    getRawIndexWithIndices = function (idx) {\n      if (idx < this._count && idx >= 0) {\n        return this._indices[idx];\n      }\n\n      return -1;\n    };\n\n    getId = function (list, rawIndex) {\n      var id = list._idList[rawIndex];\n\n      if (id == null && list._idDimIdx != null) {\n        id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n\n    validateDimensions = function (list, dims) {\n      for (var i = 0; i < dims.length; i++) {\n        if (!list._dimensionInfos[dims[i]]) {\n          console.error('Unkown dimension ' + dims[i]);\n        }\n      }\n    };\n\n    cloneListForMapAndSample = function (original, excludeDimensions) {\n      var allDimensions = original.dimensions;\n      var list = new List(map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n      transferProperties(list, original);\n      var storage = list._storage = {};\n      var originalStorage = original._storage;\n      var storageArr = list._storageArr = [];\n\n      for (var i = 0; i < allDimensions.length; i++) {\n        var dim = allDimensions[i];\n\n        if (originalStorage[dim]) {\n          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n            storage[dim] = cloneChunk(originalStorage[dim]);\n            list._rawExtent[dim] = getInitialExtent();\n            list._extent[dim] = null;\n          } else {\n            storage[dim] = originalStorage[dim];\n          }\n\n          storageArr.push(storage[dim]);\n        }\n      }\n\n      return list;\n    };\n\n    function cloneChunk(originalChunk) {\n      var Ctor = originalChunk.constructor;\n      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n    }\n\n    getInitialExtent = function () {\n      return [Infinity, -Infinity];\n    };\n\n    setItemDataAndSeriesIndex = function (child) {\n      var childECData = innerStore_1.getECData(child);\n      var thisECData = innerStore_1.getECData(this);\n      childECData.seriesIndex = thisECData.seriesIndex;\n      childECData.dataIndex = thisECData.dataIndex;\n      childECData.dataType = thisECData.dataType;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (list, idx) {\n      var nameList = list._nameList;\n      var idList = list._idList;\n      var nameDimIdx = list._nameDimIdx;\n      var idDimIdx = list._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = list._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return List;\n}();\n\nexports[\"default\"] = List;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/data/List.js"],"names":["exports","__esModule","zrUtil","require","Model_1","DataDiffer_1","dataProvider_1","dimensionHelper_1","DataDimensionInfo_1","types_1","model_1","innerStore_1","dataValueHelper_1","Source_1","mathFloor","Math","floor","isObject","map","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","defaultDimValueGetters","prepareInvertedIndex","getIndicesCtor","prepareStorage","getRawIndexWithoutIndices","getRawIndexWithIndices","getId","getIdNameFromStore","makeIdFromName","normalizeDimensions","validateDimensions","cloneListForMapAndSample","getInitialExtent","setItemDataAndSeriesIndex","transferProperties","List","dimensions","hostModel","type","_count","_rawCount","_storage","_storageArr","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawExtent","_extent","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","getRawIndex","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimInfoInput","dimensionInfo","isString","name","dimensionName","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","itemName","_nameDimIdx","_nameOrdinalMeta","ordinalMeta","itemId","_idDimIdx","_idOrdinalMeta","_dimensionInfos","_dimensionsSummary","summarizeDimensions","_invertedIndicesMap","userOutput","prototype","getDimension","dim","isNaN","hasOwnProperty","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","slice","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","mapDimensionsAll","initData","data","nameList","dimValueGetter","notProvider","isSourceInstance","isArrayLike","provider","DefaultDataProvider","process","env","NODE_ENV","assert","isFunction","getItem","count","_rawData","sourceFormat","getSource","_indices","_dontMakeIdFromName","SOURCE_FORMAT_TYPED_ARRAY","fillStorage","_nameRepeatCount","defaultDimValueGetter","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","storage","dimLen","rawExtent","max","rawExtentArr","storageArr","emptyDataItem","sourceIdx","dimIdx","val","dimRawExtent","append","dimensionInfoMap","idList","isFormatOriginal","SOURCE_FORMAT_ORIGINAL","dataItem","dimStorage","convertOptionIdName","id","clean","getIndices","newIndices","indices","Ctor","constructor","thisCount","buffer","getByDimIdx","NaN","dimStore","get","getByRawIndex","rawIdx","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","min","value","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","extend","getSum","sum","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","rawIndexOf","invertedIndices","Error","rawIndex","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getRawDataItem","cb","ctx","ctxCompat","_this","fCtx","dimNames","dimSize","dimIndices","dimName","call","k","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","dimStorage2","min2","max2","val2","dimk","mapArray","result","arguments","list","tmpRetValue","dataCount","dimIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","sampleFrameIdx","lttbDownSample","valueDimension","sampledIndex","currentRawIndex","maxArea","area","nextRawIndex","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","kvObj","getItemVisual","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","setItemVisual","clearAllVisual","setLayout","name_1","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","setItemGraphicEl","el","ecData","getECData","dataType","seriesIndex","traverse","getItemGraphicEl","eachItemGraphicEl","context","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","internalField","getDimValueSimply","objectRows","parseDataValue","keyedColumns","original","isDataItemOption","typedArray","dimInfo","categories","chunk","DataCtor","oldStore","oldLen","newStore","j","console","error","excludeDimensions","allDimensions","originalStorage","indexOf","cloneChunk","originalChunk","child","childECData","thisECData","target","source","propName","clone","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model_1 = require(\"../model/Model\");\n\nvar DataDiffer_1 = require(\"./DataDiffer\");\n\nvar dataProvider_1 = require(\"./helper/dataProvider\");\n\nvar dimensionHelper_1 = require(\"./helper/dimensionHelper\");\n\nvar DataDimensionInfo_1 = require(\"./DataDimensionInfo\");\n\nvar types_1 = require(\"../util/types\");\n\nvar model_1 = require(\"../util/model\");\n\nvar innerStore_1 = require(\"../util/innerStore\");\n\nvar dataValueHelper_1 = require(\"./helper/dataValueHelper\");\n\nvar Source_1 = require(\"./Source\");\n\nvar mathFloor = Math.floor;\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1;\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n};\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\nvar defaultDimValueGetters;\nvar prepareInvertedIndex;\nvar getIndicesCtor;\nvar prepareStorage;\nvar getRawIndexWithoutIndices;\nvar getRawIndexWithIndices;\nvar getId;\nvar getIdNameFromStore;\nvar makeIdFromName;\nvar normalizeDimensions;\nvar validateDimensions;\nvar cloneListForMapAndSample;\nvar getInitialExtent;\nvar setItemDataAndSeriesIndex;\nvar transferProperties;\n\nvar List = function () {\n  function List(dimensions, hostModel) {\n    this.type = 'list';\n    this._count = 0;\n    this._rawCount = 0;\n    this._storage = {};\n    this._storageArr = [];\n    this._nameList = [];\n    this._idList = [];\n    this._visual = {};\n    this._layout = {};\n    this._itemVisuals = [];\n    this._itemLayouts = [];\n    this._graphicEls = [];\n    this._rawExtent = {};\n    this._extent = {};\n    this._approximateExtent = {};\n    this._calculationInfo = {};\n    this.hasItemOption = true;\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'];\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    this.getRawIndex = getRawIndexWithoutIndices;\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new DataDimensionInfo_1[\"default\"]({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof DataDimensionInfo_1[\"default\"]) ? new DataDimensionInfo_1[\"default\"](dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      dimensionInfo.index = i;\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n        this._nameOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n        this._idOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimensionInfos = dimensionInfos;\n    this.hostModel = hostModel;\n    this._dimensionsSummary = dimensionHelper_1.summarizeDimensions(this);\n    this._invertedIndicesMap = invertedIndicesMap;\n    this.userOutput = this._dimensionsSummary.userOutput;\n  }\n\n  List.prototype.getDimension = function (dim) {\n    if (typeof dim === 'number' || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n      dim = this.dimensions[dim];\n    }\n\n    return dim;\n  };\n\n  List.prototype.getDimensionInfo = function (dim) {\n    return this._dimensionInfos[this.getDimension(dim)];\n  };\n\n  List.prototype.getDimensionsOnCoord = function () {\n    return this._dimensionsSummary.dataDimsOnCoord.slice();\n  };\n\n  List.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimensionsSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  List.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimensionsSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n\n  List.prototype.initData = function (data, nameList, dimValueGetter) {\n    var notProvider = Source_1.isSourceInstance(data) || zrUtil.isArrayLike(data);\n    var provider = notProvider ? new dataProvider_1.DefaultDataProvider(data, this.dimensions.length) : data;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(notProvider || zrUtil.isFunction(provider.getItem) && zrUtil.isFunction(provider.count), 'Inavlid data provider.');\n    }\n\n    this._rawData = provider;\n    var sourceFormat = provider.getSource().sourceFormat;\n    this._storage = {};\n    this._indices = null;\n    this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === types_1.SOURCE_FORMAT_TYPED_ARRAY || !!provider.fillStorage;\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    if (!dimValueGetter) {\n      this.hasItemOption = false;\n    }\n\n    this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat];\n    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n    this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows;\n    this._rawExtent = {};\n\n    this._initDataFromProvider(0, provider.count());\n\n    if (provider.pure) {\n      this.hasItemOption = false;\n    }\n  };\n\n  List.prototype.getProvider = function () {\n    return this._rawData;\n  };\n\n  List.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var rawData = this._rawData;\n    var start = this.count();\n    rawData.appendData(data);\n    var end = rawData.count();\n\n    if (!rawData.persistent) {\n      end += start;\n    }\n\n    this._initDataFromProvider(start, end, true);\n  };\n\n  List.prototype.appendValues = function (values, names) {\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, names ? names.length : 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, this._dimensionInfos[dim], end, true);\n    }\n\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start;\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n\n        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);\n\n        storageArr[dimIdx][idx] = val;\n        var dimRawExtent = rawExtentArr[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n\n      if (names) {\n        this._nameList[idx] = names[sourceIdx];\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype._initDataFromProvider = function (start, end, append) {\n    if (start >= end) {\n      return;\n    }\n\n    var rawData = this._rawData;\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var dimensionInfoMap = this._dimensionInfos;\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var rawExtent = this._rawExtent;\n    var sourceFormat = rawData.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === types_1.SOURCE_FORMAT_ORIGINAL;\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, dimensionInfoMap[dim], end, append);\n    }\n\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n\n    if (rawData.fillStorage) {\n      rawData.fillStorage(start, end, storageArr, rawExtentArr);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        dataItem = rawData.getItem(idx, dataItem);\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dim = dimensions[dimIdx];\n          var dimStorage = storageArr[dimIdx];\n\n          var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtentArr[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        }\n\n        if (isFormatOriginal && !rawData.pure && dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = model_1.convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = model_1.convertOptionIdName(itemId, null);\n          }\n        }\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    if (!rawData.persistent && rawData.clean) {\n      rawData.clean();\n    }\n\n    this._rawCount = this._count = end;\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype.count = function () {\n    return this._count;\n  };\n\n  List.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count;\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  };\n\n  List.prototype.getByDimIdx = function (dimIdx, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storageArr[dimIdx];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  List.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n\n  List.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n\n  List.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n\n    if (!zrUtil.isArray(dimensions)) {\n      idx = dimensions;\n      dimensions = this.dimensions;\n    }\n\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n      values.push(this.get(dimensions[i], idx));\n    }\n\n    return values;\n  };\n\n  List.prototype.hasValue = function (idx) {\n    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  List.prototype.getDataExtent = function (dim) {\n    dim = this.getDimension(dim);\n    var dimData = this._storage[dim];\n    var initialExtent = getInitialExtent();\n\n    if (!dimData) {\n      return initialExtent;\n    }\n\n    var currEnd = this.count();\n    var useRaw = !this._indices;\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n\n  List.prototype.getApproximateExtent = function (dim) {\n    dim = this.getDimension(dim);\n    return this._approximateExtent[dim] || this.getDataExtent(dim);\n  };\n\n  List.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  List.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  List.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n\n  List.prototype.getSum = function (dim) {\n    var dimData = this._storage[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n\n  List.prototype.getMedian = function (dim) {\n    var dimDataArray = [];\n    this.each(dim, function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    });\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count();\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  };\n\n  List.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n\n  List.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  List.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    }\n\n    var indices = this._indices;\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n\n  List.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n\n  List.prototype.getRawDataItem = function (idx) {\n    if (!this._rawData.persistent) {\n      var val = [];\n\n      for (var i = 0; i < this.dimensions.length; i++) {\n        var dim = this.dimensions[i];\n        val.push(this.get(dim, idx));\n      }\n\n      return val;\n    } else {\n      return this._rawData.getItem(this.getRawIndex(idx));\n    }\n  };\n\n  List.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n\n  List.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  List.prototype.each = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var dimSize = dimNames.length;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var storageArr = this._storageArr;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i);\n\n      switch (dimSize) {\n        case 0:\n          cb.call(fCtx, i);\n          break;\n\n        case 1:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = storageArr[dimIndices[k]][rawIdx];\n          }\n\n          value[k] = i;\n          cb.apply(fCtx, value);\n      }\n    }\n  };\n\n  List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var count = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dimNames.length;\n    var offset = 0;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var dim0 = dimIndices[0];\n    var storageArr = this._storageArr;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = this.getRawIndex(i);\n\n      if (dimSize === 0) {\n        keep = cb.call(fCtx, i);\n      } else if (dimSize === 1) {\n        var val = storageArr[dim0][rawIdx];\n        keep = cb.call(fCtx, val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = storageArr[dimIndices[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(fCtx, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    }\n\n    if (offset < count) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n\n  List.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var len = this._count;\n\n    if (!len) {\n      return;\n    }\n\n    var dimensions = [];\n\n    for (var dim in range) {\n      if (range.hasOwnProperty(dim)) {\n        dimensions.push(dim);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimensions);\n    }\n\n    var dimSize = dimensions.length;\n\n    if (!dimSize) {\n      return;\n    }\n\n    var originalCount = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dimensions[0];\n    var dimIndices = map(dimensions, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storageArr = this._storageArr;\n    var quickFinished = false;\n\n    if (!this._indices) {\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storageArr[dimIndices[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storageArr[dimIndices[0]];\n        var dimStorage2 = storageArr[dimIndices[1]];\n        var min2 = range[dimensions[1]][0];\n        var max2 = range[dimensions[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i];\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = this.getRawIndex(i);\n          var val = storageArr[dimIndices[0]][rawIndex];\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = this.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dimensions[k];\n            var val = storageArr[dimIndices[k]][rawIndex];\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = this.getRawIndex(i);\n          }\n        }\n      }\n    }\n\n    if (offset < originalCount) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset;\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n\n  List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    }\n\n    ctx = ctx || ctxCompat || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  List.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var list = cloneListForMapAndSample(this, dimNames);\n    var storage = list._storage;\n    list._indices = this._indices;\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    var tmpRetValue = [];\n    var dimSize = dimNames.length;\n    var dataCount = this.count();\n    var values = [];\n    var rawExtent = list._rawExtent;\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n        values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(fCtx, values);\n\n      if (retValue != null) {\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        var rawIndex = this.getRawIndex(dataIndex);\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dimNames[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = storage[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n\n    return list;\n  };\n\n  List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this, [dimension]);\n    var targetStorage = list._storage;\n    var frameValues = [];\n    var frameSize = mathFloor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = list._rawExtent[dimension];\n    var newIndices = new (getIndicesCtor(this))(len);\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    list._count = offset;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n\n  List.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this, []);\n    var targetStorage = list._storage;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var newIndices = new (getIndicesCtor(this))(len);\n    var sampledIndex = 0;\n    var frameSize = mathFloor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex;\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart;\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex;\n        }\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex;\n    }\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    list._count = sampledIndex;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n\n  List.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model_1[\"default\"](dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n\n  List.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer_1[\"default\"](otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n\n  List.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  List.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n\n  List.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n\n  List.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n\n  List.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key);\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  };\n\n  List.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n\n  List.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  List.prototype.setLayout = function (key, val) {\n    if (isObject(key)) {\n      for (var name_1 in key) {\n        if (key.hasOwnProperty(name_1)) {\n          this.setLayout(name_1, key[name_1]);\n        }\n      }\n\n      return;\n    }\n\n    this._layout[key] = val;\n  };\n\n  List.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n\n  List.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n\n  List.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n\n  List.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n\n  List.prototype.setItemGraphicEl = function (idx, el) {\n    var hostModel = this.hostModel;\n\n    if (el) {\n      var ecData = innerStore_1.getECData(el);\n      ecData.dataIndex = idx;\n      ecData.dataType = this.dataType;\n      ecData.seriesIndex = hostModel && hostModel.seriesIndex;\n\n      if (el.type === 'group') {\n        el.traverse(setItemDataAndSeriesIndex, el);\n      }\n    }\n\n    this._graphicEls[idx] = el;\n  };\n\n  List.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  List.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n\n  List.prototype.cloneShallow = function (list) {\n    if (!list) {\n      var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);\n      list = new List(dimensionInfoList, this.hostModel);\n    }\n\n    list._storage = this._storage;\n    list._storageArr = this._storageArr;\n    transferProperties(list, this);\n\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        list._indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          list._indices[i] = this._indices[i];\n        }\n      } else {\n        list._indices = new Ctor(this._indices);\n      }\n    } else {\n      list._indices = null;\n    }\n\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return list;\n  };\n\n  List.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (typeof originalMethod !== 'function') {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  };\n\n  List.internalField = function () {\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataValueHelper_1.parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, dimName, dataIndex, dimIndex) {\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value);\n\n        if (!this._rawData.pure && model_1.isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        return dataValueHelper_1.parseDataValue(value instanceof Array ? value[dimIndex] : value, this._dimensionInfos[dimName]);\n      },\n      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n\n    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {\n      return dataValueHelper_1.parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);\n    }\n\n    prepareInvertedIndex = function (list) {\n      var invertedIndicesMap = list._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = list._dimensionInfos[dim];\n        var ordinalMeta = dimInfo.ordinalMeta;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length);\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < list._count; i++) {\n            invertedIndices[list.get(dim, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {\n      var val;\n      var chunk = list._storageArr[dimIdx];\n\n      if (chunk) {\n        val = chunk[rawIndex];\n\n        if (ordinalMeta && ordinalMeta.categories.length) {\n          val = ordinalMeta.categories[val];\n        }\n      }\n\n      return model_1.convertOptionIdName(val, null);\n    };\n\n    getIndicesCtor = function (list) {\n      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n    };\n\n    prepareStorage = function (storage, dimInfo, end, append) {\n      var DataCtor = dataCtors[dimInfo.type];\n      var dim = dimInfo.name;\n\n      if (append) {\n        var oldStore = storage[dim];\n        var oldLen = oldStore && oldStore.length;\n\n        if (!(oldLen === end)) {\n          var newStore = new DataCtor(end);\n\n          for (var j = 0; j < oldLen; j++) {\n            newStore[j] = oldStore[j];\n          }\n\n          storage[dim] = newStore;\n        }\n      } else {\n        storage[dim] = new DataCtor(end);\n      }\n    };\n\n    getRawIndexWithoutIndices = function (idx) {\n      return idx;\n    };\n\n    getRawIndexWithIndices = function (idx) {\n      if (idx < this._count && idx >= 0) {\n        return this._indices[idx];\n      }\n\n      return -1;\n    };\n\n    getId = function (list, rawIndex) {\n      var id = list._idList[rawIndex];\n\n      if (id == null && list._idDimIdx != null) {\n        id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n\n    validateDimensions = function (list, dims) {\n      for (var i = 0; i < dims.length; i++) {\n        if (!list._dimensionInfos[dims[i]]) {\n          console.error('Unkown dimension ' + dims[i]);\n        }\n      }\n    };\n\n    cloneListForMapAndSample = function (original, excludeDimensions) {\n      var allDimensions = original.dimensions;\n      var list = new List(map(allDimensions, original.getDimensionInfo, original), original.hostModel);\n      transferProperties(list, original);\n      var storage = list._storage = {};\n      var originalStorage = original._storage;\n      var storageArr = list._storageArr = [];\n\n      for (var i = 0; i < allDimensions.length; i++) {\n        var dim = allDimensions[i];\n\n        if (originalStorage[dim]) {\n          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n            storage[dim] = cloneChunk(originalStorage[dim]);\n            list._rawExtent[dim] = getInitialExtent();\n            list._extent[dim] = null;\n          } else {\n            storage[dim] = originalStorage[dim];\n          }\n\n          storageArr.push(storage[dim]);\n        }\n      }\n\n      return list;\n    };\n\n    function cloneChunk(originalChunk) {\n      var Ctor = originalChunk.constructor;\n      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n    }\n\n    getInitialExtent = function () {\n      return [Infinity, -Infinity];\n    };\n\n    setItemDataAndSeriesIndex = function (child) {\n      var childECData = innerStore_1.getECData(child);\n      var thisECData = innerStore_1.getECData(this);\n      childECData.seriesIndex = thisECData.seriesIndex;\n      childECData.dataIndex = thisECData.dataIndex;\n      childECData.dataType = thisECData.dataType;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (list, idx) {\n      var nameList = list._nameList;\n      var idList = list._idList;\n      var nameDimIdx = list._nameDimIdx;\n      var idDimIdx = list._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = list._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return List;\n}();\n\nexports[\"default\"] = List;"]},"metadata":{},"sourceType":"script"}