{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar tslib_1 = require(\"tslib\");\n\nvar Path_1 = require(\"../Path\");\n\nvar vec2 = require(\"../../core/vector\");\n\nvar curve_1 = require(\"../../core/curve\");\n\nvar out = [];\n\nvar BezierCurveShape = function () {\n  function BezierCurveShape() {\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.cpx1 = 0;\n    this.cpy1 = 0;\n    this.percent = 1;\n  }\n\n  return BezierCurveShape;\n}();\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? curve_1.cubicDerivativeAt : curve_1.cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? curve_1.cubicDerivativeAt : curve_1.cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? curve_1.quadraticDerivativeAt : curve_1.quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? curve_1.quadraticDerivativeAt : curve_1.quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar BezierCurve = function (_super) {\n  tslib_1.__extends(BezierCurve, _super);\n\n  function BezierCurve(opts) {\n    return _super.call(this, opts) || this;\n  }\n\n  BezierCurve.prototype.getDefaultStyle = function () {\n    return {\n      stroke: '#000',\n      fill: null\n    };\n  };\n\n  BezierCurve.prototype.getDefaultShape = function () {\n    return new BezierCurveShape();\n  };\n\n  BezierCurve.prototype.buildPath = function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        curve_1.quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        curve_1.quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        curve_1.cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        curve_1.cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  };\n\n  BezierCurve.prototype.pointAt = function (t) {\n    return someVectorAt(this.shape, t, false);\n  };\n\n  BezierCurve.prototype.tangentAt = function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  };\n\n  return BezierCurve;\n}(Path_1[\"default\"]);\n\n;\nBezierCurve.prototype.type = 'bezier-curve';\nexports[\"default\"] = BezierCurve;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/zrender/lib/graphic/shape/BezierCurve.js"],"names":["exports","__esModule","tslib_1","require","Path_1","vec2","curve_1","out","BezierCurveShape","x1","y1","x2","y2","cpx1","cpy1","percent","someVectorAt","shape","t","isTangent","cpx2","cpy2","cubicDerivativeAt","cubicAt","quadraticDerivativeAt","quadraticAt","BezierCurve","_super","__extends","opts","call","prototype","getDefaultStyle","stroke","fill","getDefaultShape","buildPath","ctx","moveTo","quadraticSubdivide","quadraticCurveTo","cubicSubdivide","bezierCurveTo","pointAt","tangentAt","p","normalize","type"],"mappings":"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","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar tslib_1 = require(\"tslib\");\nvar Path_1 = require(\"../Path\");\nvar vec2 = require(\"../../core/vector\");\nvar curve_1 = require(\"../../core/curve\");\nvar out = [];\nvar BezierCurveShape = (function () {\n    function BezierCurveShape() {\n        this.x1 = 0;\n        this.y1 = 0;\n        this.x2 = 0;\n        this.y2 = 0;\n        this.cpx1 = 0;\n        this.cpy1 = 0;\n        this.percent = 1;\n    }\n    return BezierCurveShape;\n}());\nfunction someVectorAt(shape, t, isTangent) {\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    if (cpx2 === null || cpy2 === null) {\n        return [\n            (isTangent ? curve_1.cubicDerivativeAt : curve_1.cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),\n            (isTangent ? curve_1.cubicDerivativeAt : curve_1.cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)\n        ];\n    }\n    else {\n        return [\n            (isTangent ? curve_1.quadraticDerivativeAt : curve_1.quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),\n            (isTangent ? curve_1.quadraticDerivativeAt : curve_1.quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)\n        ];\n    }\n}\nvar BezierCurve = (function (_super) {\n    tslib_1.__extends(BezierCurve, _super);\n    function BezierCurve(opts) {\n        return _super.call(this, opts) || this;\n    }\n    BezierCurve.prototype.getDefaultStyle = function () {\n        return {\n            stroke: '#000',\n            fill: null\n        };\n    };\n    BezierCurve.prototype.getDefaultShape = function () {\n        return new BezierCurveShape();\n    };\n    BezierCurve.prototype.buildPath = function (ctx, shape) {\n        var x1 = shape.x1;\n        var y1 = shape.y1;\n        var x2 = shape.x2;\n        var y2 = shape.y2;\n        var cpx1 = shape.cpx1;\n        var cpy1 = shape.cpy1;\n        var cpx2 = shape.cpx2;\n        var cpy2 = shape.cpy2;\n        var percent = shape.percent;\n        if (percent === 0) {\n            return;\n        }\n        ctx.moveTo(x1, y1);\n        if (cpx2 == null || cpy2 == null) {\n            if (percent < 1) {\n                curve_1.quadraticSubdivide(x1, cpx1, x2, percent, out);\n                cpx1 = out[1];\n                x2 = out[2];\n                curve_1.quadraticSubdivide(y1, cpy1, y2, percent, out);\n                cpy1 = out[1];\n                y2 = out[2];\n            }\n            ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n        }\n        else {\n            if (percent < 1) {\n                curve_1.cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n                cpx1 = out[1];\n                cpx2 = out[2];\n                x2 = out[3];\n                curve_1.cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n                cpy1 = out[1];\n                cpy2 = out[2];\n                y2 = out[3];\n            }\n            ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n        }\n    };\n    BezierCurve.prototype.pointAt = function (t) {\n        return someVectorAt(this.shape, t, false);\n    };\n    BezierCurve.prototype.tangentAt = function (t) {\n        var p = someVectorAt(this.shape, t, true);\n        return vec2.normalize(p, p);\n    };\n    return BezierCurve;\n}(Path_1[\"default\"]));\n;\nBezierCurve.prototype.type = 'bezier-curve';\nexports[\"default\"] = BezierCurve;\n"]},"metadata":{},"sourceType":"script"}