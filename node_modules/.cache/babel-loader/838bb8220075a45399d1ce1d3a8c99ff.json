{"ast":null,"code":"import { assign, isString, isFunction } from '@antv/util';\nimport { sankey, sankeyLeft, sankeyRight, sankeyCenter, sankeyJustify } from 'd3-sankey';\nvar ALIGN_METHOD = {\n  left: sankeyLeft,\n  right: sankeyRight,\n  center: sankeyCenter,\n  justify: sankeyJustify\n};\n/**\n * 默认值\n */\n\nvar DEFAULT_OPTIONS = {\n  nodeId: function (node) {\n    return node.index;\n  },\n  nodeAlign: 'justify',\n  nodeWidth: 0.008,\n  nodePadding: 0.03,\n  nodeSort: undefined\n};\n/**\n * 获得 align function\n * @param nodeAlign\n */\n\nexport function getNodeAlignFunction(nodeAlign) {\n  var func = isString(nodeAlign) ? ALIGN_METHOD[nodeAlign] : isFunction(nodeAlign) ? nodeAlign : null;\n  return func || sankeyJustify;\n}\nexport function getDefaultOptions(sankeyLayoutOptions) {\n  return assign({}, DEFAULT_OPTIONS, sankeyLayoutOptions);\n}\n/**\n * 桑基图利用数据进行布局的函数，最终返回节点、边的位置（0 - 1 的信息）\n * 将会修改 data 数据\n * @param sankeyLayoutOptions\n * @param data\n */\n\nexport function sankeyLayout(sankeyLayoutOptions, data) {\n  var options = getDefaultOptions(sankeyLayoutOptions);\n  var nodeId = options.nodeId,\n      nodeSort = options.nodeSort,\n      nodeAlign = options.nodeAlign,\n      nodeWidth = options.nodeWidth,\n      nodePadding = options.nodePadding;\n  var sankeyProcessor = sankey().nodeSort(nodeSort).links(function (d) {\n    return d.links;\n  }).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeAlign(getNodeAlignFunction(nodeAlign)).extent([[0, 0], [1, 1]]).nodeId(nodeId); // 进行桑基图布局处理\n\n  var layoutData = sankeyProcessor(data); // post process (x, y), etc.\n\n  layoutData.nodes.forEach(function (node) {\n    var x0 = node.x0,\n        x1 = node.x1,\n        y0 = node.y0,\n        y1 = node.y1;\n    /* points\n     * 3---2\n     * |   |\n     * 0---1\n     */\n\n    node.x = [x0, x1, x1, x0];\n    node.y = [y0, y0, y1, y1];\n  });\n  layoutData.links.forEach(function (edge) {\n    var source = edge.source,\n        target = edge.target;\n    var sx = source.x1;\n    var tx = target.x0;\n    edge.x = [sx, sx, tx, tx];\n    var offset = edge.width / 2;\n    edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];\n  });\n  return layoutData;\n}","map":{"version":3,"sources":["../../../src/utils/transform/sankey.ts"],"names":[],"mappings":"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","sourcesContent":["import { assign, isString, isFunction } from '@antv/util';\nimport { sankey, sankeyLeft, sankeyRight, sankeyCenter, sankeyJustify } from 'd3-sankey';\nimport { Datum } from '../../types';\n\nconst ALIGN_METHOD = {\n  left: sankeyLeft,\n  right: sankeyRight,\n  center: sankeyCenter,\n  justify: sankeyJustify,\n};\n\ntype InputNode = {\n  readonly name: string;\n};\n\ntype InputLink = {\n  readonly source: number;\n  readonly target: number;\n  readonly value: number;\n};\n\ntype OutputNode = {\n  readonly name: string;\n  readonly x0: number;\n  readonly x1: number;\n  readonly y0: number;\n  readonly y1: number;\n  readonly depth: number;\n  readonly value: number;\n\n  // 用于绘制 polygon\n  x: number[];\n  y: number[];\n};\n\ntype OutputLink = {\n  readonly source: OutputNode;\n  readonly target: OutputNode;\n  readonly value: number;\n  readonly width: number;\n  readonly y0: number;\n  readonly y1: number;\n\n  // 用于绘制 edge\n  x?: number[];\n  y?: number[];\n};\n\n/**\n * 桑基图布局的数据结构定义\n */\nexport type SankeyLayoutInputData = {\n  readonly nodes: InputNode[];\n  readonly links: InputLink[];\n};\n\ntype SankeyLayoutOutputData = {\n  readonly nodes: OutputNode[];\n  readonly links: OutputLink[];\n};\n\n/**\n * 对齐方式的类型定义\n */\nexport type NodeAlign = keyof typeof ALIGN_METHOD;\n\n/**\n * 布局参数的定义\n */\nexport type SankeyLayoutOptions = {\n  readonly nodeId?: (node: Datum) => any;\n  // readonly value?: (node: Datum) => any;\n  // readonly source?: (edge: Datum) => any;\n  // readonly target?: (edge: Datum) => any;\n  // sankey.nodeSort(undefined) is the default and resorts by ascending breadth during each iteration.\n  // sankey.nodeSort(null) specifies the input order of nodes and never sorts.\n  // sankey.nodeSort(function) specifies the given order as a comparator function and sorts once on initialization.\n  readonly nodeSort?: (a: any, b: any) => number;\n  readonly nodeAlign?: NodeAlign;\n  readonly nodeWidth?: number;\n  readonly nodePadding?: number;\n};\n\n/**\n * 默认值\n */\nconst DEFAULT_OPTIONS: Partial<SankeyLayoutOptions> = {\n  nodeId: (node: Datum) => node.index,\n  nodeAlign: 'justify',\n  nodeWidth: 0.008,\n  nodePadding: 0.03,\n  nodeSort: undefined,\n};\n\n/**\n * 获得 align function\n * @param nodeAlign\n */\nexport function getNodeAlignFunction(nodeAlign: NodeAlign) {\n  const func = isString(nodeAlign) ? ALIGN_METHOD[nodeAlign] : isFunction(nodeAlign) ? nodeAlign : null;\n\n  return func || sankeyJustify;\n}\n\nexport function getDefaultOptions(sankeyLayoutOptions: SankeyLayoutOptions) {\n  return assign({}, DEFAULT_OPTIONS, sankeyLayoutOptions);\n}\n\n/**\n * 桑基图利用数据进行布局的函数，最终返回节点、边的位置（0 - 1 的信息）\n * 将会修改 data 数据\n * @param sankeyLayoutOptions\n * @param data\n */\nexport function sankeyLayout(\n  sankeyLayoutOptions: SankeyLayoutOptions,\n  data: SankeyLayoutInputData\n): SankeyLayoutOutputData {\n  const options = getDefaultOptions(sankeyLayoutOptions);\n\n  const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding } = options;\n\n  const sankeyProcessor = sankey()\n    .nodeSort(nodeSort)\n    .links((d: any) => d.links)\n    .nodeWidth(nodeWidth)\n    .nodePadding(nodePadding)\n    .nodeAlign(getNodeAlignFunction(nodeAlign))\n    .extent([\n      [0, 0],\n      [1, 1],\n    ])\n    .nodeId(nodeId);\n\n  // 进行桑基图布局处理\n  const layoutData: SankeyLayoutOutputData = sankeyProcessor(data);\n\n  // post process (x, y), etc.\n  layoutData.nodes.forEach((node) => {\n    const { x0, x1, y0, y1 } = node;\n    /* points\n     * 3---2\n     * |   |\n     * 0---1\n     */\n    node.x = [x0, x1, x1, x0];\n    node.y = [y0, y0, y1, y1];\n  });\n\n  layoutData.links.forEach((edge) => {\n    const { source, target } = edge;\n    const sx = source.x1;\n    const tx = target.x0;\n    edge.x = [sx, sx, tx, tx];\n    const offset = edge.width / 2;\n    edge.y = [edge.y0 + offset, edge.y0 - offset, edge.y1 + offset, edge.y1 - offset];\n  });\n\n  return layoutData;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}