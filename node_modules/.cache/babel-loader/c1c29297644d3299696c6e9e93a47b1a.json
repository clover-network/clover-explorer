{"ast":null,"code":"// Adapted from science.js by Jason Davies\n// License: https://github.com/jasondavies/science.js/blob/master/LICENSE\n// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js\n// Adapted from vega-statistics by Jeffrey Heer\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n// Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/loess.js\nimport { median } from \"./utils/median\";\nimport { ols } from \"./utils/ols\";\nimport { points } from \"./utils/points\";\nconst maxiters = 2,\n      epsilon = 1e-12;\nexport default function () {\n  let x = d => d[0],\n      y = d => d[1],\n      bandwidth = .3;\n\n  function loess(data) {\n    const [xv, yv, ux, uy] = points(data, x, y, true),\n          n = xv.length,\n          bw = Math.max(2, ~~(bandwidth * n)),\n          // # nearest neighbors\n    yhat = new Float64Array(n),\n          residuals = new Float64Array(n),\n          robustWeights = new Float64Array(n).fill(1);\n\n    for (let iter = -1; ++iter <= maxiters;) {\n      const interval = [0, bw - 1];\n\n      for (let i = 0; i < n; ++i) {\n        const dx = xv[i],\n              i0 = interval[0],\n              i1 = interval[1],\n              edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;\n        let W = 0,\n            X = 0,\n            Y = 0,\n            XY = 0,\n            X2 = 0,\n            denom = 1 / Math.abs(xv[edge] - dx || 1); // Avoid singularity\n\n        for (let k = i0; k <= i1; ++k) {\n          const xk = xv[k],\n                yk = yv[k],\n                w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],\n                xkw = xk * w;\n          W += w;\n          X += xkw;\n          Y += yk * w;\n          XY += yk * xkw;\n          X2 += xk * xkw;\n        } // Linear regression fit\n\n\n        const [a, b] = ols(X / W, Y / W, XY / W, X2 / W);\n        yhat[i] = a + b * dx;\n        residuals[i] = Math.abs(yv[i] - yhat[i]);\n        updateInterval(xv, i + 1, interval);\n      }\n\n      if (iter === maxiters) {\n        break;\n      }\n\n      const medianResidual = median(residuals);\n      if (Math.abs(medianResidual) < epsilon) break;\n\n      for (let i = 0, arg, w; i < n; ++i) {\n        arg = residuals[i] / (6 * medianResidual); // Default to epsilon (rather than zero) for large deviations\n        // Keeping weights tiny but non-zero prevents singularites\n\n        robustWeights[i] = arg >= 1 ? epsilon : (w = 1 - arg * arg) * w;\n      }\n    }\n\n    return output(xv, yhat, ux, uy);\n  }\n\n  loess.bandwidth = function (bw) {\n    return arguments.length ? (bandwidth = bw, loess) : bandwidth;\n  };\n\n  loess.x = function (fn) {\n    return arguments.length ? (x = fn, loess) : x;\n  };\n\n  loess.y = function (fn) {\n    return arguments.length ? (y = fn, loess) : y;\n  };\n\n  return loess;\n} // Weighting kernel for local regression\n\nfunction tricube(x) {\n  return (x = 1 - x * x * x) * x * x;\n} // Advance sliding window interval of nearest neighbors\n\n\nfunction updateInterval(xv, i, interval) {\n  let val = xv[i],\n      left = interval[0],\n      right = interval[1] + 1;\n  if (right >= xv.length) return; // Step right if distance to new right edge is <= distance to old left edge\n  // Step when distance is equal to ensure movement over duplicate x values\n\n  while (i > left && xv[right] - val <= val - xv[left]) {\n    interval[0] = ++left;\n    interval[1] = right;\n    ++right;\n  }\n} // Generate smoothed output points\n// Average points with repeated x values\n\n\nfunction output(xv, yhat, ux, uy) {\n  const n = xv.length,\n        out = [];\n  let i = 0,\n      cnt = 0,\n      prev = [],\n      v;\n\n  for (; i < n; ++i) {\n    v = xv[i] + ux;\n\n    if (prev[0] === v) {\n      // Average output values via online update\n      prev[1] += (yhat[i] - prev[1]) / ++cnt;\n    } else {\n      // Add new output point\n      cnt = 0;\n      prev[1] += uy;\n      prev = [v, yhat[i]];\n      out.push(prev);\n    }\n  }\n\n  prev[1] += uy;\n  return out;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/d3-regression/src/loess.js"],"names":["median","ols","points","maxiters","epsilon","x","d","y","bandwidth","loess","data","xv","yv","ux","uy","n","length","bw","Math","max","yhat","Float64Array","residuals","robustWeights","fill","iter","interval","i","dx","i0","i1","edge","W","X","Y","XY","X2","denom","abs","k","xk","yk","w","tricube","xkw","a","b","updateInterval","medianResidual","arg","output","arguments","fn","val","left","right","out","cnt","prev","v","push"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB;AACA,SAASC,GAAT,QAAoB,aAApB;AACA,SAASC,MAAT,QAAuB,gBAAvB;AAEA,MAAMC,QAAQ,GAAG,CAAjB;AAAA,MAAoBC,OAAO,GAAG,KAA9B;AAEA,eAAe,YAAW;AACxB,MAAIC,CAAC,GAAGC,CAAC,IAAIA,CAAC,CAAC,CAAD,CAAd;AAAA,MACIC,CAAC,GAAGD,CAAC,IAAIA,CAAC,CAAC,CAAD,CADd;AAAA,MAEIE,SAAS,GAAG,EAFhB;;AAIA,WAASC,KAAT,CAAeC,IAAf,EAAqB;AACnB,UAAM,CAACC,EAAD,EAAKC,EAAL,EAASC,EAAT,EAAaC,EAAb,IAAmBZ,MAAM,CAACQ,IAAD,EAAOL,CAAP,EAAUE,CAAV,EAAa,IAAb,CAA/B;AAAA,UACMQ,CAAC,GAAGJ,EAAE,CAACK,MADb;AAAA,UAEMC,EAAE,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,CAAC,EAAEX,SAAS,GAAGO,CAAd,CAAb,CAFX;AAAA,UAE2C;AACrCK,IAAAA,IAAI,GAAG,IAAIC,YAAJ,CAAiBN,CAAjB,CAHb;AAAA,UAIMO,SAAS,GAAG,IAAID,YAAJ,CAAiBN,CAAjB,CAJlB;AAAA,UAKMQ,aAAa,GAAG,IAAIF,YAAJ,CAAiBN,CAAjB,EAAoBS,IAApB,CAAyB,CAAzB,CALtB;;AAOA,SAAK,IAAIC,IAAI,GAAG,CAAC,CAAjB,EAAoB,EAAEA,IAAF,IAAUtB,QAA9B,GAA0C;AACxC,YAAMuB,QAAQ,GAAG,CAAC,CAAD,EAAIT,EAAE,GAAG,CAAT,CAAjB;;AAEA,WAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGZ,CAApB,EAAuB,EAAEY,CAAzB,EAA4B;AAC1B,cAAMC,EAAE,GAAGjB,EAAE,CAACgB,CAAD,CAAb;AAAA,cACME,EAAE,GAAGH,QAAQ,CAAC,CAAD,CADnB;AAAA,cAEMI,EAAE,GAAGJ,QAAQ,CAAC,CAAD,CAFnB;AAAA,cAGMK,IAAI,GAAIH,EAAE,GAAGjB,EAAE,CAACkB,EAAD,CAAR,GAAiBlB,EAAE,CAACmB,EAAD,CAAF,GAASF,EAA1B,GAAgCC,EAAhC,GAAqCC,EAHlD;AAKA,YAAIE,CAAC,GAAG,CAAR;AAAA,YAAWC,CAAC,GAAG,CAAf;AAAA,YAAkBC,CAAC,GAAG,CAAtB;AAAA,YAAyBC,EAAE,GAAG,CAA9B;AAAA,YAAiCC,EAAE,GAAG,CAAtC;AAAA,YACIC,KAAK,GAAG,IAAInB,IAAI,CAACoB,GAAL,CAAS3B,EAAE,CAACoB,IAAD,CAAF,GAAWH,EAAX,IAAiB,CAA1B,CADhB,CAN0B,CAOoB;;AAE9C,aAAK,IAAIW,CAAC,GAAGV,EAAb,EAAiBU,CAAC,IAAIT,EAAtB,EAA0B,EAAES,CAA5B,EAA+B;AAC7B,gBAAMC,EAAE,GAAG7B,EAAE,CAAC4B,CAAD,CAAb;AAAA,gBACME,EAAE,GAAG7B,EAAE,CAAC2B,CAAD,CADb;AAAA,gBAEMG,CAAC,GAAGC,OAAO,CAACzB,IAAI,CAACoB,GAAL,CAASV,EAAE,GAAGY,EAAd,IAAoBH,KAArB,CAAP,GAAqCd,aAAa,CAACgB,CAAD,CAF5D;AAAA,gBAGMK,GAAG,GAAGJ,EAAE,GAAGE,CAHjB;AAKAV,UAAAA,CAAC,IAAIU,CAAL;AACAT,UAAAA,CAAC,IAAIW,GAAL;AACAV,UAAAA,CAAC,IAAIO,EAAE,GAAGC,CAAV;AACAP,UAAAA,EAAE,IAAIM,EAAE,GAAGG,GAAX;AACAR,UAAAA,EAAE,IAAII,EAAE,GAAGI,GAAX;AACD,SApByB,CAsB1B;;;AACA,cAAM,CAACC,CAAD,EAAIC,CAAJ,IAAS7C,GAAG,CAACgC,CAAC,GAAGD,CAAL,EAAQE,CAAC,GAAGF,CAAZ,EAAeG,EAAE,GAAGH,CAApB,EAAuBI,EAAE,GAAGJ,CAA5B,CAAlB;AACAZ,QAAAA,IAAI,CAACO,CAAD,CAAJ,GAAUkB,CAAC,GAAGC,CAAC,GAAGlB,EAAlB;AACAN,QAAAA,SAAS,CAACK,CAAD,CAAT,GAAeT,IAAI,CAACoB,GAAL,CAAS1B,EAAE,CAACe,CAAD,CAAF,GAAQP,IAAI,CAACO,CAAD,CAArB,CAAf;AAEAoB,QAAAA,cAAc,CAACpC,EAAD,EAAKgB,CAAC,GAAG,CAAT,EAAYD,QAAZ,CAAd;AACD;;AAED,UAAID,IAAI,KAAKtB,QAAb,EAAuB;AACrB;AACD;;AAED,YAAM6C,cAAc,GAAGhD,MAAM,CAACsB,SAAD,CAA7B;AACA,UAAIJ,IAAI,CAACoB,GAAL,CAASU,cAAT,IAA2B5C,OAA/B,EAAwC;;AAExC,WAAK,IAAIuB,CAAC,GAAG,CAAR,EAAWsB,GAAX,EAAgBP,CAArB,EAAwBf,CAAC,GAAGZ,CAA5B,EAA+B,EAAEY,CAAjC,EAAmC;AACjCsB,QAAAA,GAAG,GAAG3B,SAAS,CAACK,CAAD,CAAT,IAAgB,IAAIqB,cAApB,CAAN,CADiC,CAEjC;AACA;;AACAzB,QAAAA,aAAa,CAACI,CAAD,CAAb,GAAoBsB,GAAG,IAAI,CAAR,GAAa7C,OAAb,GAAwB,CAACsC,CAAC,GAAG,IAAIO,GAAG,GAAGA,GAAf,IAAsBP,CAAjE;AACD;AACF;;AAED,WAAOQ,MAAM,CAACvC,EAAD,EAAKS,IAAL,EAAWP,EAAX,EAAeC,EAAf,CAAb;AACD;;AAEDL,EAAAA,KAAK,CAACD,SAAN,GAAkB,UAASS,EAAT,EAAa;AAC7B,WAAOkC,SAAS,CAACnC,MAAV,IAAoBR,SAAS,GAAGS,EAAZ,EAAgBR,KAApC,IAA6CD,SAApD;AACD,GAFD;;AAIAC,EAAAA,KAAK,CAACJ,CAAN,GAAU,UAAS+C,EAAT,EAAa;AACrB,WAAOD,SAAS,CAACnC,MAAV,IAAoBX,CAAC,GAAG+C,EAAJ,EAAQ3C,KAA5B,IAAqCJ,CAA5C;AACD,GAFD;;AAIAI,EAAAA,KAAK,CAACF,CAAN,GAAU,UAAS6C,EAAT,EAAa;AACrB,WAAOD,SAAS,CAACnC,MAAV,IAAoBT,CAAC,GAAG6C,EAAJ,EAAQ3C,KAA5B,IAAqCF,CAA5C;AACD,GAFD;;AAIA,SAAOE,KAAP;AACD,C,CAED;;AACA,SAASkC,OAAT,CAAiBtC,CAAjB,EAAoB;AAClB,SAAO,CAACA,CAAC,GAAG,IAAIA,CAAC,GAAGA,CAAJ,GAAQA,CAAjB,IAAsBA,CAAtB,GAA0BA,CAAjC;AACD,C,CAED;;;AACA,SAAS0C,cAAT,CAAwBpC,EAAxB,EAA4BgB,CAA5B,EAA+BD,QAA/B,EAAyC;AACvC,MAAI2B,GAAG,GAAG1C,EAAE,CAACgB,CAAD,CAAZ;AAAA,MACI2B,IAAI,GAAG5B,QAAQ,CAAC,CAAD,CADnB;AAAA,MAEI6B,KAAK,GAAG7B,QAAQ,CAAC,CAAD,CAAR,GAAc,CAF1B;AAIA,MAAI6B,KAAK,IAAI5C,EAAE,CAACK,MAAhB,EAAwB,OALe,CAOvC;AACA;;AACA,SAAOW,CAAC,GAAG2B,IAAJ,IAAa3C,EAAE,CAAC4C,KAAD,CAAF,GAAYF,GAAb,IAAsBA,GAAG,GAAG1C,EAAE,CAAC2C,IAAD,CAAjD,EAA0D;AACxD5B,IAAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,EAAE4B,IAAhB;AACA5B,IAAAA,QAAQ,CAAC,CAAD,CAAR,GAAc6B,KAAd;AACA,MAAEA,KAAF;AACD;AACF,C,CAED;AACA;;;AACA,SAASL,MAAT,CAAgBvC,EAAhB,EAAoBS,IAApB,EAA0BP,EAA1B,EAA8BC,EAA9B,EAAkC;AAChC,QAAMC,CAAC,GAAGJ,EAAE,CAACK,MAAb;AAAA,QAAqBwC,GAAG,GAAG,EAA3B;AACA,MAAI7B,CAAC,GAAG,CAAR;AAAA,MAAW8B,GAAG,GAAG,CAAjB;AAAA,MAAoBC,IAAI,GAAG,EAA3B;AAAA,MAA+BC,CAA/B;;AAEA,SAAOhC,CAAC,GAACZ,CAAT,EAAY,EAAEY,CAAd,EAAiB;AACfgC,IAAAA,CAAC,GAAGhD,EAAE,CAACgB,CAAD,CAAF,GAAQd,EAAZ;;AACA,QAAI6C,IAAI,CAAC,CAAD,CAAJ,KAAYC,CAAhB,EAAmB;AACjB;AACAD,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAW,CAACtC,IAAI,CAACO,CAAD,CAAJ,GAAU+B,IAAI,CAAC,CAAD,CAAf,IAAuB,EAAED,GAApC;AACD,KAHD,MAGO;AACL;AACAA,MAAAA,GAAG,GAAG,CAAN;AACAC,MAAAA,IAAI,CAAC,CAAD,CAAJ,IAAW5C,EAAX;AACA4C,MAAAA,IAAI,GAAG,CAACC,CAAD,EAAIvC,IAAI,CAACO,CAAD,CAAR,CAAP;AACA6B,MAAAA,GAAG,CAACI,IAAJ,CAASF,IAAT;AACD;AACF;;AACDA,EAAAA,IAAI,CAAC,CAAD,CAAJ,IAAW5C,EAAX;AAEA,SAAO0C,GAAP;AACD","sourcesContent":["// Adapted from science.js by Jason Davies\n// License: https://github.com/jasondavies/science.js/blob/master/LICENSE\n// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js\n// Adapted from vega-statistics by Jeffrey Heer\n// License: https://github.com/vega/vega/blob/f058b099decad9db78301405dd0d2e9d8ba3d51a/LICENSE\n// Source: https://github.com/vega/vega/blob/f21cb8792b4e0cbe2b1a3fd44b0f5db370dbaadb/packages/vega-statistics/src/regression/loess.js\nimport { median } from \"./utils/median\";\nimport { ols } from \"./utils/ols\";\nimport { points } from \"./utils/points\";\n\nconst maxiters = 2, epsilon = 1e-12;\n\nexport default function() {\n  let x = d => d[0],\n      y = d => d[1],\n      bandwidth = .3;\n\n  function loess(data) {\n    const [xv, yv, ux, uy] = points(data, x, y, true),\n          n = xv.length,\n          bw = Math.max(2, ~~(bandwidth * n)), // # nearest neighbors\n          yhat = new Float64Array(n),\n          residuals = new Float64Array(n),\n          robustWeights = new Float64Array(n).fill(1);\n\n    for (let iter = -1; ++iter <= maxiters; ) {\n      const interval = [0, bw - 1];\n\n      for (let i = 0; i < n; ++i) {\n        const dx = xv[i],\n              i0 = interval[0],\n              i1 = interval[1],\n              edge = (dx - xv[i0]) > (xv[i1] - dx) ? i0 : i1;\n\n        let W = 0, X = 0, Y = 0, XY = 0, X2 = 0,\n            denom = 1 / Math.abs(xv[edge] - dx || 1); // Avoid singularity\n\n        for (let k = i0; k <= i1; ++k) {\n          const xk = xv[k],\n                yk = yv[k],\n                w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],\n                xkw = xk * w;\n\n          W += w;\n          X += xkw;\n          Y += yk * w;\n          XY += yk * xkw;\n          X2 += xk * xkw;\n        }\n\n        // Linear regression fit\n        const [a, b] = ols(X / W, Y / W, XY / W, X2 / W);\n        yhat[i] = a + b * dx;\n        residuals[i] = Math.abs(yv[i] - yhat[i]);\n\n        updateInterval(xv, i + 1, interval);\n      }\n\n      if (iter === maxiters) {\n        break;\n      }\n\n      const medianResidual = median(residuals);\n      if (Math.abs(medianResidual) < epsilon) break;\n\n      for (let i = 0, arg, w; i < n; ++i){\n        arg = residuals[i] / (6 * medianResidual);\n        // Default to epsilon (rather than zero) for large deviations\n        // Keeping weights tiny but non-zero prevents singularites\n        robustWeights[i] = (arg >= 1) ? epsilon : ((w = 1 - arg * arg) * w);\n      }\n    }\n\n    return output(xv, yhat, ux, uy);\n  }\n\n  loess.bandwidth = function(bw) {\n    return arguments.length ? (bandwidth = bw, loess) : bandwidth;\n  };\n\n  loess.x = function(fn) {\n    return arguments.length ? (x = fn, loess) : x;\n  };\n\n  loess.y = function(fn) {\n    return arguments.length ? (y = fn, loess) : y;\n  };\n\n  return loess;\n}\n\n// Weighting kernel for local regression\nfunction tricube(x) {\n  return (x = 1 - x * x * x) * x * x;\n}\n\n// Advance sliding window interval of nearest neighbors\nfunction updateInterval(xv, i, interval) {\n  let val = xv[i],\n      left = interval[0],\n      right = interval[1] + 1;\n\n  if (right >= xv.length) return;\n\n  // Step right if distance to new right edge is <= distance to old left edge\n  // Step when distance is equal to ensure movement over duplicate x values\n  while (i > left && (xv[right] - val) <= (val - xv[left])) {\n    interval[0] = ++left;\n    interval[1] = right;\n    ++right;\n  }\n}\n\n// Generate smoothed output points\n// Average points with repeated x values\nfunction output(xv, yhat, ux, uy) {\n  const n = xv.length, out = [];\n  let i = 0, cnt = 0, prev = [], v;\n\n  for (; i<n; ++i) {\n    v = xv[i] + ux;\n    if (prev[0] === v) {\n      // Average output values via online update\n      prev[1] += (yhat[i] - prev[1]) / (++cnt);\n    } else {\n      // Add new output point\n      cnt = 0;\n      prev[1] += uy;\n      prev = [v, yhat[i]];\n      out.push(prev);\n    }\n  }\n  prev[1] += uy;\n\n  return out;\n}"]},"metadata":{},"sourceType":"module"}