{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar text_1 = require(\"zrender/lib/contain/text\");\n\nvar ScaleRawExtentInfo = function () {\n  function ScaleRawExtentInfo(scale, model, originalExtent) {\n    this._prepareParams(scale, model, originalExtent);\n  }\n\n  ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, dataExtent) {\n    if (dataExtent[1] < dataExtent[0]) {\n      dataExtent = [NaN, NaN];\n    }\n\n    this._dataMin = dataExtent[0];\n    this._dataMax = dataExtent[1];\n    var isOrdinal = this._isOrdinal = scale.type === 'ordinal';\n    this._needCrossZero = model.getNeedCrossZero && model.getNeedCrossZero();\n    var modelMinRaw = this._modelMinRaw = model.get('min', true);\n\n    if (util_1.isFunction(modelMinRaw)) {\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMinRaw !== 'dataMin') {\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);\n    }\n\n    var modelMaxRaw = this._modelMaxRaw = model.get('max', true);\n\n    if (util_1.isFunction(modelMaxRaw)) {\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMaxRaw !== 'dataMax') {\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);\n    }\n\n    if (isOrdinal) {\n      this._axisDataLen = model.getCategories().length;\n    } else {\n      var boundaryGap = model.get('boundaryGap');\n      var boundaryGapArr = util_1.isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];\n\n      if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., \"20%\". Currently, ' + 'boundaryGap is set to be 0.');\n        }\n\n        this._boundaryGapInner = [0, 0];\n      } else {\n        this._boundaryGapInner = [text_1.parsePercent(boundaryGapArr[0], 1), text_1.parsePercent(boundaryGapArr[1], 1)];\n      }\n    }\n  };\n\n  ScaleRawExtentInfo.prototype.calculate = function () {\n    var isOrdinal = this._isOrdinal;\n    var dataMin = this._dataMin;\n    var dataMax = this._dataMax;\n    var axisDataLen = this._axisDataLen;\n    var boundaryGapInner = this._boundaryGapInner;\n    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;\n    var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;\n    var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum;\n    var minFixed = min != null;\n    var maxFixed = max != null;\n\n    if (min == null) {\n      min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;\n    }\n\n    if (max == null) {\n      max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;\n    }\n\n    (min == null || !isFinite(min)) && (min = NaN);\n    (max == null || !isFinite(max)) && (max = NaN);\n\n    if (min > max) {\n      min = NaN;\n      max = NaN;\n    }\n\n    var isBlank = util_1.eqNaN(min) || util_1.eqNaN(max) || isOrdinal && !axisDataLen;\n\n    if (this._needCrossZero) {\n      if (min > 0 && max > 0 && !minFixed) {\n        min = 0;\n      }\n\n      if (min < 0 && max < 0 && !maxFixed) {\n        max = 0;\n      }\n    }\n\n    var determinedMin = this._determinedMin;\n    var determinedMax = this._determinedMax;\n\n    if (determinedMin != null) {\n      min = determinedMin;\n      minFixed = true;\n    }\n\n    if (determinedMax != null) {\n      max = determinedMax;\n      maxFixed = true;\n    }\n\n    return {\n      min: min,\n      max: max,\n      minFixed: minFixed,\n      maxFixed: maxFixed,\n      isBlank: isBlank\n    };\n  };\n\n  ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      util_1.assert(!this.frozen);\n    }\n\n    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {\n    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];\n\n    if (process.env.NODE_ENV !== 'production') {\n      util_1.assert(!this.frozen && this[attr] == null);\n    }\n\n    this[attr] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.freeze = function () {\n    this.frozen = true;\n  };\n\n  return ScaleRawExtentInfo;\n}();\n\nexports.ScaleRawExtentInfo = ScaleRawExtentInfo;\nvar DETERMINED_MIN_MAX_ATTR = {\n  min: '_determinedMin',\n  max: '_determinedMax'\n};\nvar DATA_MIN_MAX_ATTR = {\n  min: '_dataMin',\n  max: '_dataMax'\n};\n\nfunction ensureScaleRawExtentInfo(scale, model, originalExtent) {\n  var rawExtentInfo = scale.rawExtentInfo;\n\n  if (rawExtentInfo) {\n    return rawExtentInfo;\n  }\n\n  rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent);\n  scale.rawExtentInfo = rawExtentInfo;\n  return rawExtentInfo;\n}\n\nexports.ensureScaleRawExtentInfo = ensureScaleRawExtentInfo;\n\nfunction parseAxisModelMinMax(scale, minMax) {\n  return minMax == null ? null : util_1.eqNaN(minMax) ? NaN : scale.parse(minMax);\n}\n\nexports.parseAxisModelMinMax = parseAxisModelMinMax;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/coord/scaleRawExtentInfo.js"],"names":["exports","__esModule","util_1","require","text_1","ScaleRawExtentInfo","scale","model","originalExtent","_prepareParams","prototype","dataExtent","NaN","_dataMin","_dataMax","isOrdinal","_isOrdinal","type","_needCrossZero","getNeedCrossZero","modelMinRaw","_modelMinRaw","get","isFunction","_modelMinNum","parseAxisModelMinMax","min","max","modelMaxRaw","_modelMaxRaw","_modelMaxNum","_axisDataLen","getCategories","length","boundaryGap","boundaryGapArr","isArray","process","env","NODE_ENV","console","warn","_boundaryGapInner","parsePercent","calculate","dataMin","dataMax","axisDataLen","boundaryGapInner","span","Math","abs","minFixed","maxFixed","isFinite","isBlank","eqNaN","determinedMin","_determinedMin","determinedMax","_determinedMax","modifyDataMinMax","minMaxName","val","assert","frozen","DATA_MIN_MAX_ATTR","setDeterminedMinMax","attr","DETERMINED_MIN_MAX_ATTR","freeze","ensureScaleRawExtentInfo","rawExtentInfo","minMax","parse"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar text_1 = require(\"zrender/lib/contain/text\");\n\nvar ScaleRawExtentInfo = function () {\n  function ScaleRawExtentInfo(scale, model, originalExtent) {\n    this._prepareParams(scale, model, originalExtent);\n  }\n\n  ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, dataExtent) {\n    if (dataExtent[1] < dataExtent[0]) {\n      dataExtent = [NaN, NaN];\n    }\n\n    this._dataMin = dataExtent[0];\n    this._dataMax = dataExtent[1];\n    var isOrdinal = this._isOrdinal = scale.type === 'ordinal';\n    this._needCrossZero = model.getNeedCrossZero && model.getNeedCrossZero();\n    var modelMinRaw = this._modelMinRaw = model.get('min', true);\n\n    if (util_1.isFunction(modelMinRaw)) {\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMinRaw !== 'dataMin') {\n      this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw);\n    }\n\n    var modelMaxRaw = this._modelMaxRaw = model.get('max', true);\n\n    if (util_1.isFunction(modelMaxRaw)) {\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({\n        min: dataExtent[0],\n        max: dataExtent[1]\n      }));\n    } else if (modelMaxRaw !== 'dataMax') {\n      this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw);\n    }\n\n    if (isOrdinal) {\n      this._axisDataLen = model.getCategories().length;\n    } else {\n      var boundaryGap = model.get('boundaryGap');\n      var boundaryGapArr = util_1.isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0];\n\n      if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., \"20%\". Currently, ' + 'boundaryGap is set to be 0.');\n        }\n\n        this._boundaryGapInner = [0, 0];\n      } else {\n        this._boundaryGapInner = [text_1.parsePercent(boundaryGapArr[0], 1), text_1.parsePercent(boundaryGapArr[1], 1)];\n      }\n    }\n  };\n\n  ScaleRawExtentInfo.prototype.calculate = function () {\n    var isOrdinal = this._isOrdinal;\n    var dataMin = this._dataMin;\n    var dataMax = this._dataMax;\n    var axisDataLen = this._axisDataLen;\n    var boundaryGapInner = this._boundaryGapInner;\n    var span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null;\n    var min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum;\n    var max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum;\n    var minFixed = min != null;\n    var maxFixed = max != null;\n\n    if (min == null) {\n      min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span;\n    }\n\n    if (max == null) {\n      max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span;\n    }\n\n    (min == null || !isFinite(min)) && (min = NaN);\n    (max == null || !isFinite(max)) && (max = NaN);\n\n    if (min > max) {\n      min = NaN;\n      max = NaN;\n    }\n\n    var isBlank = util_1.eqNaN(min) || util_1.eqNaN(max) || isOrdinal && !axisDataLen;\n\n    if (this._needCrossZero) {\n      if (min > 0 && max > 0 && !minFixed) {\n        min = 0;\n      }\n\n      if (min < 0 && max < 0 && !maxFixed) {\n        max = 0;\n      }\n    }\n\n    var determinedMin = this._determinedMin;\n    var determinedMax = this._determinedMax;\n\n    if (determinedMin != null) {\n      min = determinedMin;\n      minFixed = true;\n    }\n\n    if (determinedMax != null) {\n      max = determinedMax;\n      maxFixed = true;\n    }\n\n    return {\n      min: min,\n      max: max,\n      minFixed: minFixed,\n      maxFixed: maxFixed,\n      isBlank: isBlank\n    };\n  };\n\n  ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      util_1.assert(!this.frozen);\n    }\n\n    this[DATA_MIN_MAX_ATTR[minMaxName]] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {\n    var attr = DETERMINED_MIN_MAX_ATTR[minMaxName];\n\n    if (process.env.NODE_ENV !== 'production') {\n      util_1.assert(!this.frozen && this[attr] == null);\n    }\n\n    this[attr] = val;\n  };\n\n  ScaleRawExtentInfo.prototype.freeze = function () {\n    this.frozen = true;\n  };\n\n  return ScaleRawExtentInfo;\n}();\n\nexports.ScaleRawExtentInfo = ScaleRawExtentInfo;\nvar DETERMINED_MIN_MAX_ATTR = {\n  min: '_determinedMin',\n  max: '_determinedMax'\n};\nvar DATA_MIN_MAX_ATTR = {\n  min: '_dataMin',\n  max: '_dataMax'\n};\n\nfunction ensureScaleRawExtentInfo(scale, model, originalExtent) {\n  var rawExtentInfo = scale.rawExtentInfo;\n\n  if (rawExtentInfo) {\n    return rawExtentInfo;\n  }\n\n  rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent);\n  scale.rawExtentInfo = rawExtentInfo;\n  return rawExtentInfo;\n}\n\nexports.ensureScaleRawExtentInfo = ensureScaleRawExtentInfo;\n\nfunction parseAxisModelMinMax(scale, minMax) {\n  return minMax == null ? null : util_1.eqNaN(minMax) ? NaN : scale.parse(minMax);\n}\n\nexports.parseAxisModelMinMax = parseAxisModelMinMax;"]},"metadata":{},"sourceType":"script"}