{"ast":null,"code":"import SVD from './dc/svd';\nimport Matrix from './matrix';\nexport function pseudoInverse(matrix, threshold = Number.EPSILON) {\n  matrix = Matrix.checkMatrix(matrix);\n  let svdSolution = new SVD(matrix, {\n    autoTranspose: true\n  });\n  let U = svdSolution.leftSingularVectors;\n  let V = svdSolution.rightSingularVectors;\n  let s = svdSolution.diagonal;\n\n  for (let i = 0; i < s.length; i++) {\n    if (Math.abs(s[i]) > threshold) {\n      s[i] = 1.0 / s[i];\n    } else {\n      s[i] = 0.0;\n    }\n  }\n\n  return V.mmul(Matrix.diag(s).mmul(U.transpose()));\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/ml-matrix/src/pseudoInverse.js"],"names":["SVD","Matrix","pseudoInverse","matrix","threshold","Number","EPSILON","checkMatrix","svdSolution","autoTranspose","U","leftSingularVectors","V","rightSingularVectors","s","diagonal","i","length","Math","abs","mmul","diag","transpose"],"mappings":"AAAA,OAAOA,GAAP,MAAgB,UAAhB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AAEA,OAAO,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,SAAS,GAAGC,MAAM,CAACC,OAAlD,EAA2D;AAChEH,EAAAA,MAAM,GAAGF,MAAM,CAACM,WAAP,CAAmBJ,MAAnB,CAAT;AACA,MAAIK,WAAW,GAAG,IAAIR,GAAJ,CAAQG,MAAR,EAAgB;AAAEM,IAAAA,aAAa,EAAE;AAAjB,GAAhB,CAAlB;AAEA,MAAIC,CAAC,GAAGF,WAAW,CAACG,mBAApB;AACA,MAAIC,CAAC,GAAGJ,WAAW,CAACK,oBAApB;AACA,MAAIC,CAAC,GAAGN,WAAW,CAACO,QAApB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,CAAC,CAACG,MAAtB,EAA8BD,CAAC,EAA/B,EAAmC;AACjC,QAAIE,IAAI,CAACC,GAAL,CAASL,CAAC,CAACE,CAAD,CAAV,IAAiBZ,SAArB,EAAgC;AAC9BU,MAAAA,CAAC,CAACE,CAAD,CAAD,GAAO,MAAMF,CAAC,CAACE,CAAD,CAAd;AACD,KAFD,MAEO;AACLF,MAAAA,CAAC,CAACE,CAAD,CAAD,GAAO,GAAP;AACD;AACF;;AAED,SAAOJ,CAAC,CAACQ,IAAF,CAAOnB,MAAM,CAACoB,IAAP,CAAYP,CAAZ,EAAeM,IAAf,CAAoBV,CAAC,CAACY,SAAF,EAApB,CAAP,CAAP;AACD","sourcesContent":["import SVD from './dc/svd';\nimport Matrix from './matrix';\n\nexport function pseudoInverse(matrix, threshold = Number.EPSILON) {\n  matrix = Matrix.checkMatrix(matrix);\n  let svdSolution = new SVD(matrix, { autoTranspose: true });\n\n  let U = svdSolution.leftSingularVectors;\n  let V = svdSolution.rightSingularVectors;\n  let s = svdSolution.diagonal;\n\n  for (let i = 0; i < s.length; i++) {\n    if (Math.abs(s[i]) > threshold) {\n      s[i] = 1.0 / s[i];\n    } else {\n      s[i] = 0.0;\n    }\n  }\n\n  return V.mmul(Matrix.diag(s).mmul(U.transpose()));\n}\n"]},"metadata":{},"sourceType":"module"}