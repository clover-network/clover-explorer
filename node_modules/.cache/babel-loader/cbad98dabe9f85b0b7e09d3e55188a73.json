{"ast":null,"code":"// wrap tree node\nfunction WrappedTree(w, h, y, c) {\n  if (c === void 0) {\n    c = [];\n  }\n\n  var me = this; // size\n\n  me.w = w || 0;\n  me.h = h || 0; // position\n\n  me.y = y || 0;\n  me.x = 0; // children\n\n  me.c = c || [];\n  me.cs = c.length; // modified\n\n  me.prelim = 0;\n  me.mod = 0;\n  me.shift = 0;\n  me.change = 0; // left/right tree\n\n  me.tl = null;\n  me.tr = null; // extreme left/right tree\n\n  me.el = null;\n  me.er = null; // modified left/right tree\n\n  me.msel = 0;\n  me.mser = 0;\n}\n\nWrappedTree.fromNode = function (root, isHorizontal) {\n  if (!root) return null;\n  var children = [];\n  root.children.forEach(function (child) {\n    children.push(WrappedTree.fromNode(child, isHorizontal));\n  });\n  if (isHorizontal) return new WrappedTree(root.height, root.width, root.x, children);\n  return new WrappedTree(root.width, root.height, root.y, children);\n}; // node utils\n\n\nfunction moveRight(node, move, isHorizontal) {\n  if (isHorizontal) {\n    node.y += move;\n  } else {\n    node.x += move;\n  }\n\n  node.children.forEach(function (child) {\n    moveRight(child, move, isHorizontal);\n  });\n}\n\nfunction getMin(node, isHorizontal) {\n  var res = isHorizontal ? node.y : node.x;\n  node.children.forEach(function (child) {\n    res = Math.min(getMin(child, isHorizontal), res);\n  });\n  return res;\n}\n\nfunction normalize(node, isHorizontal) {\n  var min = getMin(node, isHorizontal);\n  moveRight(node, -min, isHorizontal);\n}\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.y = converted.x;\n  } else {\n    root.x = converted.x;\n  }\n\n  converted.c.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nfunction layer(node, isHorizontal, d) {\n  if (d === void 0) {\n    d = 0;\n  }\n\n  if (isHorizontal) {\n    node.x = d;\n    d += node.width;\n  } else {\n    node.y = d;\n    d += node.height;\n  }\n\n  node.children.forEach(function (child) {\n    layer(child, isHorizontal, d);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var isHorizontal = options.isHorizontal;\n\n  function firstWalk(t) {\n    if (t.cs === 0) {\n      setExtremes(t);\n      return;\n    }\n\n    firstWalk(t.c[0]);\n    var ih = updateIYL(bottom(t.c[0].el), 0, null);\n\n    for (var i = 1; i < t.cs; ++i) {\n      firstWalk(t.c[i]);\n      var min = bottom(t.c[i].er);\n      separate(t, i, ih);\n      ih = updateIYL(min, i, ih);\n    }\n\n    positionRoot(t);\n    setExtremes(t);\n  }\n\n  function setExtremes(t) {\n    if (t.cs === 0) {\n      t.el = t;\n      t.er = t;\n      t.msel = t.mser = 0;\n    } else {\n      t.el = t.c[0].el;\n      t.msel = t.c[0].msel;\n      t.er = t.c[t.cs - 1].er;\n      t.mser = t.c[t.cs - 1].mser;\n    }\n  }\n\n  function separate(t, i, ih) {\n    var sr = t.c[i - 1];\n    var mssr = sr.mod;\n    var cl = t.c[i];\n    var mscl = cl.mod;\n\n    while (sr !== null && cl !== null) {\n      if (bottom(sr) > ih.low) ih = ih.nxt;\n      var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n\n      if (dist > 0) {\n        mscl += dist;\n        moveSubtree(t, i, ih.index, dist);\n      }\n\n      var sy = bottom(sr);\n      var cy = bottom(cl);\n\n      if (sy <= cy) {\n        sr = nextRightContour(sr);\n        if (sr !== null) mssr += sr.mod;\n      }\n\n      if (sy >= cy) {\n        cl = nextLeftContour(cl);\n        if (cl !== null) mscl += cl.mod;\n      }\n    }\n\n    if (!sr && !!cl) {\n      setLeftThread(t, i, cl, mscl);\n    } else if (!!sr && !cl) {\n      setRightThread(t, i, sr, mssr);\n    }\n  }\n\n  function moveSubtree(t, i, si, dist) {\n    t.c[i].mod += dist;\n    t.c[i].msel += dist;\n    t.c[i].mser += dist;\n    distributeExtra(t, i, si, dist);\n  }\n\n  function nextLeftContour(t) {\n    return t.cs === 0 ? t.tl : t.c[0];\n  }\n\n  function nextRightContour(t) {\n    return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n  }\n\n  function bottom(t) {\n    return t.y + t.h;\n  }\n\n  function setLeftThread(t, i, cl, modsumcl) {\n    var li = t.c[0].el;\n    li.tl = cl;\n    var diff = modsumcl - cl.mod - t.c[0].msel;\n    li.mod += diff;\n    li.prelim -= diff;\n    t.c[0].el = t.c[i].el;\n    t.c[0].msel = t.c[i].msel;\n  }\n\n  function setRightThread(t, i, sr, modsumsr) {\n    var ri = t.c[i].er;\n    ri.tr = sr;\n    var diff = modsumsr - sr.mod - t.c[i].mser;\n    ri.mod += diff;\n    ri.prelim -= diff;\n    t.c[i].er = t.c[i - 1].er;\n    t.c[i].mser = t.c[i - 1].mser;\n  }\n\n  function positionRoot(t) {\n    t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\n  }\n\n  function secondWalk(t, modsum) {\n    modsum += t.mod;\n    t.x = t.prelim + modsum;\n    addChildSpacing(t);\n\n    for (var i = 0; i < t.cs; i++) {\n      secondWalk(t.c[i], modsum);\n    }\n  }\n\n  function distributeExtra(t, i, si, dist) {\n    if (si !== i - 1) {\n      var nr = i - si;\n      t.c[si + 1].shift += dist / nr;\n      t.c[i].shift -= dist / nr;\n      t.c[i].change -= dist - dist / nr;\n    }\n  }\n\n  function addChildSpacing(t) {\n    var d = 0;\n    var modsumdelta = 0;\n\n    for (var i = 0; i < t.cs; i++) {\n      d += t.c[i].shift;\n      modsumdelta += d + t.c[i].change;\n      t.c[i].mod += modsumdelta;\n    }\n  }\n\n  function updateIYL(low, index, ih) {\n    while (ih !== null && low >= ih.low) {\n      ih = ih.nxt;\n    }\n\n    return {\n      low: low,\n      index: index,\n      nxt: ih\n    };\n  } // do layout\n\n\n  layer(root, isHorizontal);\n  var wt = WrappedTree.fromNode(root, isHorizontal);\n  firstWalk(wt);\n  secondWalk(wt, 0);\n  convertBack(wt, root, isHorizontal);\n  normalize(root, isHorizontal);\n  return root;\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/hierarchy/lib/layout/non-layered-tidy.js"],"names":["WrappedTree","w","h","y","c","me","x","cs","length","prelim","mod","shift","change","tl","tr","el","er","msel","mser","fromNode","root","isHorizontal","children","forEach","child","push","height","width","moveRight","node","move","getMin","res","Math","min","normalize","convertBack","converted","i","layer","d","module","exports","options","firstWalk","t","setExtremes","ih","updateIYL","bottom","separate","positionRoot","sr","mssr","cl","mscl","low","nxt","dist","moveSubtree","index","sy","cy","nextRightContour","nextLeftContour","setLeftThread","setRightThread","si","distributeExtra","modsumcl","li","diff","modsumsr","ri","secondWalk","modsum","addChildSpacing","nr","modsumdelta","wt"],"mappings":"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","sourcesContent":["// wrap tree node\nfunction WrappedTree(w, h, y, c) {\n  if (c === void 0) {\n    c = [];\n  }\n\n  var me = this; // size\n\n  me.w = w || 0;\n  me.h = h || 0; // position\n\n  me.y = y || 0;\n  me.x = 0; // children\n\n  me.c = c || [];\n  me.cs = c.length; // modified\n\n  me.prelim = 0;\n  me.mod = 0;\n  me.shift = 0;\n  me.change = 0; // left/right tree\n\n  me.tl = null;\n  me.tr = null; // extreme left/right tree\n\n  me.el = null;\n  me.er = null; // modified left/right tree\n\n  me.msel = 0;\n  me.mser = 0;\n}\n\nWrappedTree.fromNode = function (root, isHorizontal) {\n  if (!root) return null;\n  var children = [];\n  root.children.forEach(function (child) {\n    children.push(WrappedTree.fromNode(child, isHorizontal));\n  });\n  if (isHorizontal) return new WrappedTree(root.height, root.width, root.x, children);\n  return new WrappedTree(root.width, root.height, root.y, children);\n}; // node utils\n\n\nfunction moveRight(node, move, isHorizontal) {\n  if (isHorizontal) {\n    node.y += move;\n  } else {\n    node.x += move;\n  }\n\n  node.children.forEach(function (child) {\n    moveRight(child, move, isHorizontal);\n  });\n}\n\nfunction getMin(node, isHorizontal) {\n  var res = isHorizontal ? node.y : node.x;\n  node.children.forEach(function (child) {\n    res = Math.min(getMin(child, isHorizontal), res);\n  });\n  return res;\n}\n\nfunction normalize(node, isHorizontal) {\n  var min = getMin(node, isHorizontal);\n  moveRight(node, -min, isHorizontal);\n}\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.y = converted.x;\n  } else {\n    root.x = converted.x;\n  }\n\n  converted.c.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nfunction layer(node, isHorizontal, d) {\n  if (d === void 0) {\n    d = 0;\n  }\n\n  if (isHorizontal) {\n    node.x = d;\n    d += node.width;\n  } else {\n    node.y = d;\n    d += node.height;\n  }\n\n  node.children.forEach(function (child) {\n    layer(child, isHorizontal, d);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var isHorizontal = options.isHorizontal;\n\n  function firstWalk(t) {\n    if (t.cs === 0) {\n      setExtremes(t);\n      return;\n    }\n\n    firstWalk(t.c[0]);\n    var ih = updateIYL(bottom(t.c[0].el), 0, null);\n\n    for (var i = 1; i < t.cs; ++i) {\n      firstWalk(t.c[i]);\n      var min = bottom(t.c[i].er);\n      separate(t, i, ih);\n      ih = updateIYL(min, i, ih);\n    }\n\n    positionRoot(t);\n    setExtremes(t);\n  }\n\n  function setExtremes(t) {\n    if (t.cs === 0) {\n      t.el = t;\n      t.er = t;\n      t.msel = t.mser = 0;\n    } else {\n      t.el = t.c[0].el;\n      t.msel = t.c[0].msel;\n      t.er = t.c[t.cs - 1].er;\n      t.mser = t.c[t.cs - 1].mser;\n    }\n  }\n\n  function separate(t, i, ih) {\n    var sr = t.c[i - 1];\n    var mssr = sr.mod;\n    var cl = t.c[i];\n    var mscl = cl.mod;\n\n    while (sr !== null && cl !== null) {\n      if (bottom(sr) > ih.low) ih = ih.nxt;\n      var dist = mssr + sr.prelim + sr.w - (mscl + cl.prelim);\n\n      if (dist > 0) {\n        mscl += dist;\n        moveSubtree(t, i, ih.index, dist);\n      }\n\n      var sy = bottom(sr);\n      var cy = bottom(cl);\n\n      if (sy <= cy) {\n        sr = nextRightContour(sr);\n        if (sr !== null) mssr += sr.mod;\n      }\n\n      if (sy >= cy) {\n        cl = nextLeftContour(cl);\n        if (cl !== null) mscl += cl.mod;\n      }\n    }\n\n    if (!sr && !!cl) {\n      setLeftThread(t, i, cl, mscl);\n    } else if (!!sr && !cl) {\n      setRightThread(t, i, sr, mssr);\n    }\n  }\n\n  function moveSubtree(t, i, si, dist) {\n    t.c[i].mod += dist;\n    t.c[i].msel += dist;\n    t.c[i].mser += dist;\n    distributeExtra(t, i, si, dist);\n  }\n\n  function nextLeftContour(t) {\n    return t.cs === 0 ? t.tl : t.c[0];\n  }\n\n  function nextRightContour(t) {\n    return t.cs === 0 ? t.tr : t.c[t.cs - 1];\n  }\n\n  function bottom(t) {\n    return t.y + t.h;\n  }\n\n  function setLeftThread(t, i, cl, modsumcl) {\n    var li = t.c[0].el;\n    li.tl = cl;\n    var diff = modsumcl - cl.mod - t.c[0].msel;\n    li.mod += diff;\n    li.prelim -= diff;\n    t.c[0].el = t.c[i].el;\n    t.c[0].msel = t.c[i].msel;\n  }\n\n  function setRightThread(t, i, sr, modsumsr) {\n    var ri = t.c[i].er;\n    ri.tr = sr;\n    var diff = modsumsr - sr.mod - t.c[i].mser;\n    ri.mod += diff;\n    ri.prelim -= diff;\n    t.c[i].er = t.c[i - 1].er;\n    t.c[i].mser = t.c[i - 1].mser;\n  }\n\n  function positionRoot(t) {\n    t.prelim = (t.c[0].prelim + t.c[0].mod + t.c[t.cs - 1].mod + t.c[t.cs - 1].prelim + t.c[t.cs - 1].w) / 2 - t.w / 2;\n  }\n\n  function secondWalk(t, modsum) {\n    modsum += t.mod;\n    t.x = t.prelim + modsum;\n    addChildSpacing(t);\n\n    for (var i = 0; i < t.cs; i++) {\n      secondWalk(t.c[i], modsum);\n    }\n  }\n\n  function distributeExtra(t, i, si, dist) {\n    if (si !== i - 1) {\n      var nr = i - si;\n      t.c[si + 1].shift += dist / nr;\n      t.c[i].shift -= dist / nr;\n      t.c[i].change -= dist - dist / nr;\n    }\n  }\n\n  function addChildSpacing(t) {\n    var d = 0;\n    var modsumdelta = 0;\n\n    for (var i = 0; i < t.cs; i++) {\n      d += t.c[i].shift;\n      modsumdelta += d + t.c[i].change;\n      t.c[i].mod += modsumdelta;\n    }\n  }\n\n  function updateIYL(low, index, ih) {\n    while (ih !== null && low >= ih.low) {\n      ih = ih.nxt;\n    }\n\n    return {\n      low: low,\n      index: index,\n      nxt: ih\n    };\n  } // do layout\n\n\n  layer(root, isHorizontal);\n  var wt = WrappedTree.fromNode(root, isHorizontal);\n  firstWalk(wt);\n  secondWalk(wt, 0);\n  convertBack(wt, root, isHorizontal);\n  normalize(root, isHorizontal);\n  return root;\n};"]},"metadata":{},"sourceType":"script"}