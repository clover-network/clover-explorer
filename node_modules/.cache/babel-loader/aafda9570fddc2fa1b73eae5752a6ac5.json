{"ast":null,"code":"import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\nexport default class CholeskyDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    if (!value.isSymmetric()) {\n      throw new Error('Matrix is not symmetric');\n    }\n\n    let a = value;\n    let dimension = a.rows;\n    let l = new Matrix(dimension, dimension);\n    let positiveDefinite = true;\n    let i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n      let d = 0;\n\n      for (k = 0; k < j; k++) {\n        let s = 0;\n\n        for (i = 0; i < k; i++) {\n          s += l.get(k, i) * l.get(j, i);\n        }\n\n        s = (a.get(j, k) - s) / l.get(k, k);\n        l.set(j, k, s);\n        d = d + s * s;\n      }\n\n      d = a.get(j, j) - d;\n      positiveDefinite &= d > 0;\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\n\n      for (k = j + 1; k < dimension; k++) {\n        l.set(j, k, 0);\n      }\n    }\n\n    this.L = l;\n    this.positiveDefinite = Boolean(positiveDefinite);\n  }\n\n  isPositiveDefinite() {\n    return this.positiveDefinite;\n  }\n\n  solve(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n    let l = this.L;\n    let dimension = l.rows;\n\n    if (value.rows !== dimension) {\n      throw new Error('Matrix dimensions do not match');\n    }\n\n    if (this.isPositiveDefinite() === false) {\n      throw new Error('Matrix is not positive definite');\n    }\n\n    let count = value.columns;\n    let B = value.clone();\n    let i, j, k;\n\n    for (k = 0; k < dimension; k++) {\n      for (j = 0; j < count; j++) {\n        for (i = 0; i < k; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\n        }\n\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    for (k = dimension - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        for (i = k + 1; i < dimension; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\n        }\n\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    return B;\n  }\n\n  get lowerTriangularMatrix() {\n    return this.L;\n  }\n\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/ml-matrix/src/dc/cholesky.js"],"names":["Matrix","WrapperMatrix2D","CholeskyDecomposition","constructor","value","checkMatrix","isSymmetric","Error","a","dimension","rows","l","positiveDefinite","i","j","k","d","s","get","set","Math","sqrt","max","L","Boolean","isPositiveDefinite","solve","count","columns","B","clone","lowerTriangularMatrix"],"mappings":"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","sourcesContent":["import Matrix from '../matrix';\nimport WrapperMatrix2D from '../wrap/WrapperMatrix2D';\n\nexport default class CholeskyDecomposition {\n  constructor(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n    if (!value.isSymmetric()) {\n      throw new Error('Matrix is not symmetric');\n    }\n\n    let a = value;\n    let dimension = a.rows;\n    let l = new Matrix(dimension, dimension);\n    let positiveDefinite = true;\n    let i, j, k;\n\n    for (j = 0; j < dimension; j++) {\n      let d = 0;\n      for (k = 0; k < j; k++) {\n        let s = 0;\n        for (i = 0; i < k; i++) {\n          s += l.get(k, i) * l.get(j, i);\n        }\n        s = (a.get(j, k) - s) / l.get(k, k);\n        l.set(j, k, s);\n        d = d + s * s;\n      }\n\n      d = a.get(j, j) - d;\n\n      positiveDefinite &= d > 0;\n      l.set(j, j, Math.sqrt(Math.max(d, 0)));\n      for (k = j + 1; k < dimension; k++) {\n        l.set(j, k, 0);\n      }\n    }\n\n    this.L = l;\n    this.positiveDefinite = Boolean(positiveDefinite);\n  }\n\n  isPositiveDefinite() {\n    return this.positiveDefinite;\n  }\n\n  solve(value) {\n    value = WrapperMatrix2D.checkMatrix(value);\n\n    let l = this.L;\n    let dimension = l.rows;\n\n    if (value.rows !== dimension) {\n      throw new Error('Matrix dimensions do not match');\n    }\n    if (this.isPositiveDefinite() === false) {\n      throw new Error('Matrix is not positive definite');\n    }\n\n    let count = value.columns;\n    let B = value.clone();\n    let i, j, k;\n\n    for (k = 0; k < dimension; k++) {\n      for (j = 0; j < count; j++) {\n        for (i = 0; i < k; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    for (k = dimension - 1; k >= 0; k--) {\n      for (j = 0; j < count; j++) {\n        for (i = k + 1; i < dimension; i++) {\n          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));\n        }\n        B.set(k, j, B.get(k, j) / l.get(k, k));\n      }\n    }\n\n    return B;\n  }\n\n  get lowerTriangularMatrix() {\n    return this.L;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}