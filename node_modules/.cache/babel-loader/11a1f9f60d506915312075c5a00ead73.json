{"ast":null,"code":"import { squareDist, pointLineSquareDist, itemIntersectByLine, getPointsCenter, fractionToLine, isPointsOverlap, pointRectSquareDist, Line, isPointInPolygon } from '../../util/math';\nvar defaultOps = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 100,\n  pixelGroupSize: 2,\n  edgeR0: 10,\n  edgeR1: 10,\n  nodeR0: 5,\n  nodeR1: 10,\n  morphBuffer: 5,\n  threshold: 0.001,\n  skip: 16,\n  nodeInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  negativeNodeInfluenceFactor: -0.5\n};\n/**\n * Marching square algorithm for traching the contour of a pixel group\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\n * @param potentialArea\n * @param threshold\n */\n\nfunction MarchingSquares(contour, potentialArea, threshold) {\n  var marched = false;\n\n  var getVal = function getVal(x, y) {\n    return potentialArea.cells[x + y * potentialArea.width];\n  };\n\n  var getState = function getState(x, y) {\n    var squareVal = 0;\n\n    if (getVal(x - 1, y - 1) >= threshold) {\n      squareVal += 1;\n    }\n\n    if (getVal(x, y - 1) > threshold) {\n      squareVal += 2;\n    }\n\n    if (getVal(x - 1, y) > threshold) {\n      squareVal += 4;\n    }\n\n    if (getVal(x, y) > threshold) {\n      squareVal += 8;\n    }\n\n    return squareVal;\n  };\n\n  var doMarch = function doMarch(xPos, yPos) {\n    var x = xPos;\n    var y = yPos;\n    var prevX;\n    var prevY;\n\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      prevX = x;\n      prevY = y;\n\n      if (contour.findIndex(function (item) {\n        return item.x === x && item.y === y;\n      }) > -1) {\n        if (contour[0].x !== x || contour[0].y !== y) {// encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.push({\n          x: x,\n          y: y\n        });\n      }\n\n      var state = getState(x, y); // assign the move direction according to state of the square\n\n      switch (state) {\n        case -1:\n          console.warn('Marched out of bounds');\n          return true;\n\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          x++; // go right\n\n          break;\n\n        case 12:\n        case 14:\n        case 4:\n          x--; // go left\n\n          break;\n\n        case 6:\n          // go left if come from up else go right\n          if (prevX === 0) {\n            if (prevY === -1) {\n              x -= 1;\n            } else {\n              x += 1;\n            }\n          }\n\n          break;\n\n        case 1:\n        case 13:\n        case 5:\n          y--; // go up\n\n          break;\n\n        case 9:\n          // go up if come from right else go down\n          if (prevX === 1) {\n            if (prevY === 0) {\n              y -= 1;\n            } else {\n              y += 1;\n            }\n          }\n\n          break;\n\n        case 10:\n        case 8:\n        case 11:\n          y++; // go down\n\n          break;\n\n        default:\n          console.warn(\"Marching squares invalid state: \" + state);\n          return true;\n      }\n    }\n  };\n\n  this.march = function () {\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\n          marched = doMarch(x, y);\n        }\n      }\n    }\n\n    return marched;\n  };\n}\n/**\n * Space partition & assign value to each cell\n * @param points\n */\n\n\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\n  return {\n    cells: gridCells,\n    width: scaleWidth,\n    height: scaleHeight\n  };\n};\n/**\n * Find the optimal already visited member to item;\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\n * @param item\n * @param visited\n */\n\n\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\n  var closestNeighbour = null;\n  var minCost = Number.POSITIVE_INFINITY;\n  visited.forEach(function (neighbourItem) {\n    var itemP = {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n    var neighbourItemP = {\n      x: neighbourItem.getModel().x,\n      y: neighbourItem.getModel().y\n    };\n    var dist = squareDist(itemP, neighbourItemP);\n    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\n      if (fractionToLine(_item, directLine) > 0) {\n        return count + 1;\n      }\n\n      return count;\n    }, 0);\n\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\n      closestNeighbour = neighbourItem;\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\n    }\n  });\n  return closestNeighbour;\n};\n/**\n * 返回和线相交的item中，离边的起点最近的item\n * @param items\n * @param line\n */\n\n\nvar getIntersectItem = function getIntersectItem(items, line) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var closestItem = null;\n  items.forEach(function (item) {\n    var distance = fractionToLine(item, line); // find closest intersection\n\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  });\n  return closestItem;\n};\n/**\n * Modify the directLine and Route virtual edges around obstacles\n */\n\n\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  var checkedLines = [];\n  var linesToCheck = [];\n  linesToCheck.push(directLine);\n  var hasIntersection = true;\n  var iterations = 0;\n\n  var pointExists = function pointExists(point, lines) {\n    var flag = false;\n    lines.forEach(function (line) {\n      if (flag) return;\n\n      if (isPointsOverlap(point, {\n        x: line.x1,\n        y: line.y1\n      }) || isPointsOverlap(point, {\n        x: line.x2,\n        y: line.y2\n      })) {\n        flag = true;\n      }\n    });\n    return flag;\n  };\n\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\n      var item = _nonMembers_1[_i];\n      var bbox = item.getBBox();\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\n\n      if (isPointInPolygon(itemContour, point.x, point.y)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // outer loop end when no more intersections or out of iterations\n\n\n  while (hasIntersection && iterations < maxRoutingIterations) {\n    hasIntersection = false;\n\n    var _loop_1 = function _loop_1() {\n      var line = linesToCheck.pop();\n      var closestItem = getIntersectItem(nonMembers, line);\n\n      if (closestItem) {\n        var _a = itemIntersectByLine(closestItem, line),\n            intersections_1 = _a[0],\n            countIntersections = _a[1]; // if line passes through item\n\n\n        if (countIntersections === 2) {\n          var testReroute = function testReroute(isFirst) {\n            var tempMorphBuffer = morphBuffer;\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst); // test the virtualNode already exists\n\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\n\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\n              // try a smaller buffer\n              tempMorphBuffer /= 1.5;\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            } // 第二次route时不要求pointInside\n\n\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\n              // add 2 rerouted lines to check\n              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\n              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\n              hasIntersection = true;\n            }\n          };\n\n          testReroute(true);\n\n          if (!hasIntersection) {\n            // if we didn't find a valid point around the first corner, try the second\n            testReroute(false);\n          }\n        }\n      } // no intersection found, mark this line as completed\n\n\n      if (!hasIntersection) {\n        checkedLines.push(line);\n      }\n\n      iterations += 1;\n    }; // inner loop end when out of lines or found an intersection\n\n\n    while (!hasIntersection && linesToCheck.length) {\n      _loop_1();\n    }\n  } // 加入剩余的线\n\n\n  while (linesToCheck.length) {\n    checkedLines.push(linesToCheck.pop());\n  }\n\n  return checkedLines;\n};\n/**\n *  Connect item with visited members using direct line or virtual edges\n */\n\n\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\n\n  if (optimalNeighbor === null) {\n    return [];\n  } //  merge the consecutive lines\n\n\n  var mergeLines = function mergeLines(checkedLines) {\n    var finalRoute = [];\n\n    while (checkedLines.length > 0) {\n      var line1 = checkedLines.pop();\n\n      if (checkedLines.length === 0) {\n        finalRoute.push(line1);\n        break;\n      }\n\n      var line2 = checkedLines.pop();\n      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n      var closestItem = getIntersectItem(nonMembers, mergeLine); // merge most recent line and previous line\n\n      if (!closestItem) {\n        checkedLines.push(mergeLine);\n      } else {\n        finalRoute.push(line1);\n        checkedLines.push(line2);\n      }\n    }\n\n    return finalRoute;\n  };\n\n  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  var finalRoute = mergeLines(checkedLines);\n  return finalRoute;\n}\n/**\n * Calculate the countor that includes the  selected items and exclues the non-selected items\n * @param graph\n * @param members\n * @param nonMembers\n * @param options\n */\n\n\nexport var genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\n  // eslint-disable-next-line no-redeclare\n  var options = Object.assign(defaultOps, ops);\n  var centroid = getPointsCenter(members.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  })); // 按照到中心距离远近排序\n\n  members = members.sort(function (a, b) {\n    return squareDist({\n      x: a.getModel().x,\n      y: a.getModel().y\n    }, centroid) - squareDist({\n      x: b.getModel().x,\n      y: b.getModel().y\n    }, centroid);\n  });\n  var visited = [];\n  var virtualEdges = [];\n  members.forEach(function (item) {\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\n    lines.forEach(function (l) {\n      virtualEdges.push(l);\n    });\n    visited.push(item);\n  }); // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\n  // edges && edges.forEach(e => {\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\n  // });\n\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize); // Use march squares to generate contour\n\n  var contour = [];\n  var hull = [];\n\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\n    contour = [];\n    hull = [];\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\n    var marchedPath = contour.map(function (point) {\n      return {\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\n      };\n    }); // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\n\n    if (marchedPath) {\n      var size = marchedPath.length;\n\n      if (options.skip > 1) {\n        size = Math.floor(marchedPath.length / options.skip); // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n\n        while (size < 3 && options.skip > 1) {\n          options.skip -= 1;\n          size = Math.floor(marchedPath.length / options.skip);\n        }\n      } // copy hull values\n\n\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\n        hull.push({\n          x: marchedPath[i].x,\n          y: marchedPath[i].y\n        });\n      }\n    }\n\n    var isContourValid = function isContourValid() {\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n        var item = members_1[_i];\n        var hullPoints = hull.map(function (point) {\n          return [point.x, point.y];\n        });\n        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\n      } // 不强制要求所有nonMembers都没有包含在内\n      // for (const item of nonMembers) {\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\n      // }\n\n\n      return true;\n    };\n\n    if (hull && isContourValid()) {\n      return hull;\n    } // update parameters for next iteraction\n\n\n    options.threshold *= 0.9;\n\n    if (iterations <= options.maxMarchingIterations * 0.5) {\n      options.memberInfluenceFactor *= 1.2;\n      options.edgeInfluenceFactor *= 1.2;\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      options.nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n\n  return hull;\n};\n/**\n * unionboundingbox\n * @param members\n * @param edges\n */\n\nfunction getActiveRregion(members, edges, offset) {\n  var activeRegion = {\n    minX: Number.POSITIVE_INFINITY,\n    minY: Number.POSITIVE_INFINITY,\n    maxX: Number.NEGATIVE_INFINITY,\n    maxY: Number.NEGATIVE_INFINITY,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  };\n  var bboxes = [];\n  members.forEach(function (item) {\n    bboxes.push(item.getBBox());\n  });\n  edges.forEach(function (l) {\n    bboxes.push(l.getBBox());\n  });\n\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\n    var bbox = bboxes_1[_i];\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\n  }\n\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\n  activeRegion.x = activeRegion.minX;\n  activeRegion.y = activeRegion.minY;\n  return activeRegion;\n}\n\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\n  function pos2GridIx(x, offset) {\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\n    return gridIx < 0 ? 0 : gridIx;\n  }\n\n  function gridIx2Pos(x, offset) {\n    return x * options.pixelGroupSize + offset;\n  } // using inverse a for numerical stability\n\n\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\n\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\n    return [startX, startY, endX, endY];\n  };\n\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\n    var bbox = item.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.nodeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // calculate item influence for each cell\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var distanceSq = pointRectSquareDist({\n          x: tempX,\n          y: tempY\n        }, {\n          x: bbox.minX,\n          y: bbox.minY,\n          width: bbox.width,\n          height: bbox.height\n        });\n\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\n        }\n      }\n    }\n  };\n\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\n    var bbox = line.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.edgeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var minDistanceSq = pointLineSquareDist({\n          x: tempX,\n          y: tempY\n        }, line); // only influence if less than r1\n\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\n        }\n      }\n    }\n  };\n\n  if (options.nodeInfluenceFactor) {\n    members.forEach(function (item) {\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\n    });\n  }\n\n  if (options.edgeInfluenceFactor) {\n    edges.forEach(function (edge) {\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\n    });\n  }\n\n  if (options.negativeNodeInfluenceFactor) {\n    nonMembers.forEach(function (item) {\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\n    });\n  }\n}\n\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\n  var bbox = item.getBBox();\n  var topIntersect = intersections[0],\n      leftIntersect = intersections[1],\n      bottomIntersect = intersections[2],\n      rightIntersect = intersections[3];\n  var cornerPos = {\n    topLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.minY - buffer\n    },\n    topRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.minY - buffer\n    },\n    bottomLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.maxY + buffer\n    },\n    bottomRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.maxY + buffer\n    }\n  };\n  var totalArea = bbox.height * bbox.width;\n\n  function calcHalfArea(intersect1, intersect2) {\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\n  } // 根据线和boundingbox相交的情况，确定control point的位置\n\n\n  if (leftIntersect) {\n    // 相交区域有三角形\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight; // 相交区域分成上下两个梯形，比较面积\n\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\n\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    }\n\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n\n  if (rightIntersect) {\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  } // 相交区域分成左右两个梯形\n\n\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\n\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n  }\n\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/shape/hull/bubbleset.js"],"names":["squareDist","pointLineSquareDist","itemIntersectByLine","getPointsCenter","fractionToLine","isPointsOverlap","pointRectSquareDist","Line","isPointInPolygon","defaultOps","maxRoutingIterations","maxMarchingIterations","pixelGroupSize","edgeR0","edgeR1","nodeR0","nodeR1","morphBuffer","threshold","skip","nodeInfluenceFactor","edgeInfluenceFactor","negativeNodeInfluenceFactor","MarchingSquares","contour","potentialArea","marched","getVal","x","y","cells","width","getState","squareVal","doMarch","xPos","yPos","prevX","prevY","i","height","findIndex","item","push","state","console","warn","march","initGridCells","scaleWidth","Math","ceil","scaleHeight","gridCells","Float32Array","max","fill","pickBestNeighbor","visited","nonMembers","closestNeighbour","minCost","Number","POSITIVE_INFINITY","forEach","neighbourItem","itemP","getModel","neighbourItemP","dist","directLine","numberObstacles","reduce","count","_item","pow","getIntersectItem","items","line","minDistance","closestItem","distance","computeRoute","checkedLines","linesToCheck","hasIntersection","iterations","pointExists","point","lines","flag","x1","y1","x2","y2","isPointInNonMembers","_nonMembers","_i","_nonMembers_1","length","bbox","getBBox","itemContour","_loop_1","pop","_a","intersections_1","countIntersections","testReroute","isFirst","tempMorphBuffer","virtualNode","rerouteLine","exist","pointInside","getRoute","optimalNeighbor","mergeLines","finalRoute","line1","line2","mergeLine","genBubbleSet","members","ops","options","Object","assign","centroid","map","sort","a","b","virtualEdges","l","activeRegion","getActiveRregion","hull","fillPotentialArea","marchedPath","round","minX","minY","size","floor","j","isContourValid","members_1","hullPoints","centerX","centerY","memberInfluenceFactor","nonMemberInfluenceFactor","edges","offset","maxX","NEGATIVE_INFINITY","maxY","bboxes","bboxes_1","pos2GridIx","gridIx","gridIx2Pos","nodeInfA","edgeInfA","getAffectedRegion","thresholdR","startX","min","startY","endX","endY","addItemInfluence","influenceFactor","tempX","tempY","distanceSq","dr","sqrt","addEdgeInfluence","minDistanceSq","mdr","edge","buffer","intersections","wrapNormal","topIntersect","leftIntersect","bottomIntersect","rightIntersect","cornerPos","topLeft","topRight","bottomLeft","bottomRight","totalArea","calcHalfArea","intersect1","intersect2","topArea","leftArea"],"mappings":"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","sourcesContent":["import { squareDist, pointLineSquareDist, itemIntersectByLine, getPointsCenter, fractionToLine, isPointsOverlap, pointRectSquareDist, Line, isPointInPolygon } from '../../util/math';\nvar defaultOps = {\n  maxRoutingIterations: 100,\n  maxMarchingIterations: 100,\n  pixelGroupSize: 2,\n  edgeR0: 10,\n  edgeR1: 10,\n  nodeR0: 5,\n  nodeR1: 10,\n  morphBuffer: 5,\n  threshold: 0.001,\n  skip: 16,\n  nodeInfluenceFactor: 1,\n  edgeInfluenceFactor: 1,\n  negativeNodeInfluenceFactor: -0.5\n};\n/**\n * Marching square algorithm for traching the contour of a pixel group\n * https://www.emanueleferonato.com/2013/03/01/using-marching-squares-algorithm-to-trace-the-contour-of-an-image/\n * @param potentialArea\n * @param threshold\n */\n\nfunction MarchingSquares(contour, potentialArea, threshold) {\n  var marched = false;\n\n  var getVal = function getVal(x, y) {\n    return potentialArea.cells[x + y * potentialArea.width];\n  };\n\n  var getState = function getState(x, y) {\n    var squareVal = 0;\n\n    if (getVal(x - 1, y - 1) >= threshold) {\n      squareVal += 1;\n    }\n\n    if (getVal(x, y - 1) > threshold) {\n      squareVal += 2;\n    }\n\n    if (getVal(x - 1, y) > threshold) {\n      squareVal += 4;\n    }\n\n    if (getVal(x, y) > threshold) {\n      squareVal += 8;\n    }\n\n    return squareVal;\n  };\n\n  var doMarch = function doMarch(xPos, yPos) {\n    var x = xPos;\n    var y = yPos;\n    var prevX;\n    var prevY;\n\n    for (var i = 0; i < potentialArea.width * potentialArea.height; i++) {\n      prevX = x;\n      prevY = y;\n\n      if (contour.findIndex(function (item) {\n        return item.x === x && item.y === y;\n      }) > -1) {\n        if (contour[0].x !== x || contour[0].y !== y) {// encountered a loop but haven't returned to start: change direction using conditionals and continue back to start\n        } else {\n          return true;\n        }\n      } else {\n        contour.push({\n          x: x,\n          y: y\n        });\n      }\n\n      var state = getState(x, y); // assign the move direction according to state of the square\n\n      switch (state) {\n        case -1:\n          console.warn('Marched out of bounds');\n          return true;\n\n        case 0:\n        case 3:\n        case 2:\n        case 7:\n          x++; // go right\n\n          break;\n\n        case 12:\n        case 14:\n        case 4:\n          x--; // go left\n\n          break;\n\n        case 6:\n          // go left if come from up else go right\n          if (prevX === 0) {\n            if (prevY === -1) {\n              x -= 1;\n            } else {\n              x += 1;\n            }\n          }\n\n          break;\n\n        case 1:\n        case 13:\n        case 5:\n          y--; // go up\n\n          break;\n\n        case 9:\n          // go up if come from right else go down\n          if (prevX === 1) {\n            if (prevY === 0) {\n              y -= 1;\n            } else {\n              y += 1;\n            }\n          }\n\n          break;\n\n        case 10:\n        case 8:\n        case 11:\n          y++; // go down\n\n          break;\n\n        default:\n          console.warn(\"Marching squares invalid state: \" + state);\n          return true;\n      }\n    }\n  };\n\n  this.march = function () {\n    for (var x = 0; x < potentialArea.width && !marched; x += 1) {\n      for (var y = 0; y < potentialArea.height && !marched; y += 1) {\n        if (getVal(x, y) > threshold && getState(x, y) !== 15) {\n          marched = doMarch(x, y);\n        }\n      }\n    }\n\n    return marched;\n  };\n}\n/**\n * Space partition & assign value to each cell\n * @param points\n */\n\n\nvar initGridCells = function initGridCells(width, height, pixelGroupSize) {\n  var scaleWidth = Math.ceil(width / pixelGroupSize);\n  var scaleHeight = Math.ceil(height / pixelGroupSize);\n  var gridCells = new Float32Array(Math.max(0, scaleWidth * scaleHeight)).fill(0);\n  return {\n    cells: gridCells,\n    width: scaleWidth,\n    height: scaleHeight\n  };\n};\n/**\n * Find the optimal already visited member to item;\n   Optimal: minimize cost(j) = distance(i,j) ∗ countObstacles(i,j)\n * @param item\n * @param visited\n */\n\n\nvar pickBestNeighbor = function pickBestNeighbor(item, visited, nonMembers) {\n  var closestNeighbour = null;\n  var minCost = Number.POSITIVE_INFINITY;\n  visited.forEach(function (neighbourItem) {\n    var itemP = {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n    var neighbourItemP = {\n      x: neighbourItem.getModel().x,\n      y: neighbourItem.getModel().y\n    };\n    var dist = squareDist(itemP, neighbourItemP);\n    var directLine = new Line(itemP.x, itemP.y, neighbourItemP.x, neighbourItemP.y);\n    var numberObstacles = nonMembers.reduce(function (count, _item) {\n      if (fractionToLine(_item, directLine) > 0) {\n        return count + 1;\n      }\n\n      return count;\n    }, 0);\n\n    if (dist * Math.pow(numberObstacles + 1, 2) < minCost) {\n      closestNeighbour = neighbourItem;\n      minCost = dist * Math.pow(numberObstacles + 1, 2);\n    }\n  });\n  return closestNeighbour;\n};\n/**\n * 返回和线相交的item中，离边的起点最近的item\n * @param items\n * @param line\n */\n\n\nvar getIntersectItem = function getIntersectItem(items, line) {\n  var minDistance = Number.POSITIVE_INFINITY;\n  var closestItem = null;\n  items.forEach(function (item) {\n    var distance = fractionToLine(item, line); // find closest intersection\n\n    if (distance >= 0 && distance < minDistance) {\n      closestItem = item;\n      minDistance = distance;\n    }\n  });\n  return closestItem;\n};\n/**\n * Modify the directLine and Route virtual edges around obstacles\n */\n\n\nvar computeRoute = function computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer) {\n  var checkedLines = [];\n  var linesToCheck = [];\n  linesToCheck.push(directLine);\n  var hasIntersection = true;\n  var iterations = 0;\n\n  var pointExists = function pointExists(point, lines) {\n    var flag = false;\n    lines.forEach(function (line) {\n      if (flag) return;\n\n      if (isPointsOverlap(point, {\n        x: line.x1,\n        y: line.y1\n      }) || isPointsOverlap(point, {\n        x: line.x2,\n        y: line.y2\n      })) {\n        flag = true;\n      }\n    });\n    return flag;\n  };\n\n  var isPointInNonMembers = function isPointInNonMembers(point, _nonMembers) {\n    for (var _i = 0, _nonMembers_1 = _nonMembers; _i < _nonMembers_1.length; _i++) {\n      var item = _nonMembers_1[_i];\n      var bbox = item.getBBox();\n      var itemContour = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x, bbox.y + bbox.height], [bbox.x + bbox.width, bbox.y + bbox.height]];\n\n      if (isPointInPolygon(itemContour, point.x, point.y)) {\n        return true;\n      }\n    }\n\n    return false;\n  }; // outer loop end when no more intersections or out of iterations\n\n\n  while (hasIntersection && iterations < maxRoutingIterations) {\n    hasIntersection = false;\n\n    var _loop_1 = function _loop_1() {\n      var line = linesToCheck.pop();\n      var closestItem = getIntersectItem(nonMembers, line);\n\n      if (closestItem) {\n        var _a = itemIntersectByLine(closestItem, line),\n            intersections_1 = _a[0],\n            countIntersections = _a[1]; // if line passes through item\n\n\n        if (countIntersections === 2) {\n          var testReroute = function testReroute(isFirst) {\n            var tempMorphBuffer = morphBuffer;\n            var virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst); // test the virtualNode already exists\n\n            var exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n            var pointInside = isPointInNonMembers(virtualNode, nonMembers);\n\n            while (!exist && pointInside && tempMorphBuffer >= 1) {\n              // try a smaller buffer\n              tempMorphBuffer /= 1.5;\n              virtualNode = rerouteLine(closestItem, tempMorphBuffer, intersections_1, isFirst);\n              exist = pointExists(virtualNode, linesToCheck) || pointExists(virtualNode, checkedLines);\n              pointInside = isPointInNonMembers(virtualNode, nonMembers);\n            } // 第二次route时不要求pointInside\n\n\n            if (virtualNode && !exist && (!isFirst || !pointInside)) {\n              // add 2 rerouted lines to check\n              linesToCheck.push(new Line(line.x1, line.y1, virtualNode.x, virtualNode.y));\n              linesToCheck.push(new Line(virtualNode.x, virtualNode.y, line.x2, line.y2));\n              hasIntersection = true;\n            }\n          };\n\n          testReroute(true);\n\n          if (!hasIntersection) {\n            // if we didn't find a valid point around the first corner, try the second\n            testReroute(false);\n          }\n        }\n      } // no intersection found, mark this line as completed\n\n\n      if (!hasIntersection) {\n        checkedLines.push(line);\n      }\n\n      iterations += 1;\n    }; // inner loop end when out of lines or found an intersection\n\n\n    while (!hasIntersection && linesToCheck.length) {\n      _loop_1();\n    }\n  } // 加入剩余的线\n\n\n  while (linesToCheck.length) {\n    checkedLines.push(linesToCheck.pop());\n  }\n\n  return checkedLines;\n};\n/**\n *  Connect item with visited members using direct line or virtual edges\n */\n\n\nfunction getRoute(item, nonMembers, visited, maxRoutingIterations, morphBuffer) {\n  var optimalNeighbor = pickBestNeighbor(item, visited, nonMembers);\n\n  if (optimalNeighbor === null) {\n    return [];\n  } //  merge the consecutive lines\n\n\n  var mergeLines = function mergeLines(checkedLines) {\n    var finalRoute = [];\n\n    while (checkedLines.length > 0) {\n      var line1 = checkedLines.pop();\n\n      if (checkedLines.length === 0) {\n        finalRoute.push(line1);\n        break;\n      }\n\n      var line2 = checkedLines.pop();\n      var mergeLine = new Line(line1.x1, line1.y1, line2.x2, line2.y2);\n      var closestItem = getIntersectItem(nonMembers, mergeLine); // merge most recent line and previous line\n\n      if (!closestItem) {\n        checkedLines.push(mergeLine);\n      } else {\n        finalRoute.push(line1);\n        checkedLines.push(line2);\n      }\n    }\n\n    return finalRoute;\n  };\n\n  var directLine = new Line(item.getModel().x, item.getModel().y, optimalNeighbor.getModel().x, optimalNeighbor.getModel().y);\n  var checkedLines = computeRoute(directLine, nonMembers, maxRoutingIterations, morphBuffer);\n  var finalRoute = mergeLines(checkedLines);\n  return finalRoute;\n}\n/**\n * Calculate the countor that includes the  selected items and exclues the non-selected items\n * @param graph\n * @param members\n * @param nonMembers\n * @param options\n */\n\n\nexport var genBubbleSet = function genBubbleSet(members, nonMembers, ops) {\n  // eslint-disable-next-line no-redeclare\n  var options = Object.assign(defaultOps, ops);\n  var centroid = getPointsCenter(members.map(function (item) {\n    return {\n      x: item.getModel().x,\n      y: item.getModel().y\n    };\n  })); // 按照到中心距离远近排序\n\n  members = members.sort(function (a, b) {\n    return squareDist({\n      x: a.getModel().x,\n      y: a.getModel().y\n    }, centroid) - squareDist({\n      x: b.getModel().x,\n      y: b.getModel().y\n    }, centroid);\n  });\n  var visited = [];\n  var virtualEdges = [];\n  members.forEach(function (item) {\n    var lines = getRoute(item, nonMembers, visited, options.maxRoutingIterations, options.morphBuffer);\n    lines.forEach(function (l) {\n      virtualEdges.push(l);\n    });\n    visited.push(item);\n  }); // 由于edge也可以作为member和nonMember传入，暂时不考虑把edges作为参数传入genBubbleSet\n  // edges && edges.forEach(e => {\n  //   virtualEdges.push(new Line(e.getSource().getModel().x, e.getSource().getModel().y, e.getTarget().getModel().x, e.getTarget().getModel().y));\n  // });\n\n  var activeRegion = getActiveRregion(members, virtualEdges, options.nodeR0);\n  var potentialArea = initGridCells(activeRegion.width, activeRegion.height, options.pixelGroupSize); // Use march squares to generate contour\n\n  var contour = [];\n  var hull = [];\n\n  for (var iterations = 0; iterations < options.maxMarchingIterations; iterations++) {\n    fillPotentialArea(members, nonMembers, virtualEdges, activeRegion, potentialArea, options);\n    contour = [];\n    hull = [];\n    if (!new MarchingSquares(contour, potentialArea, options.threshold).march()) continue;\n    var marchedPath = contour.map(function (point) {\n      return {\n        x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX),\n        y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY)\n      };\n    }); // const marchedPath = marchingSquares(potentialArea, options.threshold).map(point => ({ x: Math.round(point.x * options.pixelGroupSize + activeRegion.minX), y: Math.round(point.y * options.pixelGroupSize + activeRegion.minY) }))\n\n    if (marchedPath) {\n      var size = marchedPath.length;\n\n      if (options.skip > 1) {\n        size = Math.floor(marchedPath.length / options.skip); // if we reduced too much (fewer than three points in reduced surface) reduce skip and try again\n\n        while (size < 3 && options.skip > 1) {\n          options.skip -= 1;\n          size = Math.floor(marchedPath.length / options.skip);\n        }\n      } // copy hull values\n\n\n      for (var i = 0, j = 0; j < size; j += 1, i += options.skip) {\n        hull.push({\n          x: marchedPath[i].x,\n          y: marchedPath[i].y\n        });\n      }\n    }\n\n    var isContourValid = function isContourValid() {\n      for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {\n        var item = members_1[_i];\n        var hullPoints = hull.map(function (point) {\n          return [point.x, point.y];\n        });\n        if (!isPointInPolygon(hullPoints, item.getBBox().centerX, item.getBBox().centerY)) return false;\n      } // 不强制要求所有nonMembers都没有包含在内\n      // for (const item of nonMembers) {\n      //   if (isPointInPolygon({ x: item.getBBox().centerX, y: item.getBBox().centerY }, contour)) return false\n      // }\n\n\n      return true;\n    };\n\n    if (hull && isContourValid()) {\n      return hull;\n    } // update parameters for next iteraction\n\n\n    options.threshold *= 0.9;\n\n    if (iterations <= options.maxMarchingIterations * 0.5) {\n      options.memberInfluenceFactor *= 1.2;\n      options.edgeInfluenceFactor *= 1.2;\n    } else if (options.nonMemberInfluenceFactor !== 0 && nonMembers.length > 0) {\n      // after half the iterations, start increasing positive energy and lowering the threshold\n      options.nonMemberInfluenceFactor *= 0.8;\n    } else {\n      break;\n    }\n  }\n\n  return hull;\n};\n/**\n * unionboundingbox\n * @param members\n * @param edges\n */\n\nfunction getActiveRregion(members, edges, offset) {\n  var activeRegion = {\n    minX: Number.POSITIVE_INFINITY,\n    minY: Number.POSITIVE_INFINITY,\n    maxX: Number.NEGATIVE_INFINITY,\n    maxY: Number.NEGATIVE_INFINITY,\n    width: 0,\n    height: 0,\n    x: 0,\n    y: 0\n  };\n  var bboxes = [];\n  members.forEach(function (item) {\n    bboxes.push(item.getBBox());\n  });\n  edges.forEach(function (l) {\n    bboxes.push(l.getBBox());\n  });\n\n  for (var _i = 0, bboxes_1 = bboxes; _i < bboxes_1.length; _i++) {\n    var bbox = bboxes_1[_i];\n    activeRegion.minX = (bbox.minX < activeRegion.minX ? bbox.minX : activeRegion.minX) - offset;\n    activeRegion.minY = (bbox.minY < activeRegion.minY ? bbox.minY : activeRegion.minY) - offset;\n    activeRegion.maxX = (bbox.maxX > activeRegion.maxX ? bbox.maxX : activeRegion.maxX) + offset;\n    activeRegion.maxY = (bbox.maxY > activeRegion.maxY ? bbox.maxY : activeRegion.maxY) + offset;\n  }\n\n  activeRegion.width = activeRegion.maxX - activeRegion.minX;\n  activeRegion.height = activeRegion.maxY - activeRegion.minY;\n  activeRegion.x = activeRegion.minX;\n  activeRegion.y = activeRegion.minY;\n  return activeRegion;\n}\n\nfunction fillPotentialArea(members, nonMembers, edges, activeRegion, potentialArea, options) {\n  function pos2GridIx(x, offset) {\n    var gridIx = Math.floor((x - offset) / options.pixelGroupSize);\n    return gridIx < 0 ? 0 : gridIx;\n  }\n\n  function gridIx2Pos(x, offset) {\n    return x * options.pixelGroupSize + offset;\n  } // using inverse a for numerical stability\n\n\n  var nodeInfA = (options.nodeR0 - options.nodeR1) * (options.nodeR0 - options.nodeR1);\n  var edgeInfA = (options.edgeR0 - options.edgeR1) * (options.edgeR0 - options.edgeR1);\n\n  var getAffectedRegion = function getAffectedRegion(bbox, thresholdR) {\n    var startX = Math.min(pos2GridIx(bbox.minX, thresholdR + activeRegion.minX), potentialArea.width);\n    var startY = Math.min(pos2GridIx(bbox.minY, thresholdR + activeRegion.minY), potentialArea.height);\n    var endX = Math.min(pos2GridIx(bbox.maxX, -thresholdR + activeRegion.minX), potentialArea.width);\n    var endY = Math.min(pos2GridIx(bbox.maxY, -thresholdR + activeRegion.minY), potentialArea.height);\n    return [startX, startY, endX, endY];\n  };\n\n  var addItemInfluence = function addItemInfluence(item, influenceFactor) {\n    var bbox = item.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.nodeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // calculate item influence for each cell\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var distanceSq = pointRectSquareDist({\n          x: tempX,\n          y: tempY\n        }, {\n          x: bbox.minX,\n          y: bbox.minY,\n          width: bbox.width,\n          height: bbox.height\n        });\n\n        if (distanceSq < Math.pow(options.nodeR1, 2)) {\n          var dr = Math.sqrt(distanceSq) - options.nodeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * dr * dr;\n        }\n      }\n    }\n  };\n\n  var addEdgeInfluence = function addEdgeInfluence(line, influenceFactor) {\n    var bbox = line.getBBox();\n\n    var _a = getAffectedRegion(bbox, options.edgeR1),\n        startX = _a[0],\n        startY = _a[1],\n        endX = _a[2],\n        endY = _a[3]; // for every point in active part of potentialArea, calculate distance to nearest point on line and add influence\n\n\n    for (var y = startY; y < endY; y += 1) {\n      for (var x = startX; x < endX; x += 1) {\n        if (influenceFactor < 0 && potentialArea.cells[x + y * potentialArea.width] <= 0) {\n          continue;\n        }\n\n        var tempX = gridIx2Pos(x, activeRegion.minX);\n        var tempY = gridIx2Pos(y, activeRegion.minY);\n        var minDistanceSq = pointLineSquareDist({\n          x: tempX,\n          y: tempY\n        }, line); // only influence if less than r1\n\n        if (minDistanceSq < Math.pow(options.edgeR1, 2)) {\n          var mdr = Math.sqrt(minDistanceSq) - options.edgeR1;\n          potentialArea.cells[x + y * potentialArea.width] += influenceFactor * mdr * mdr;\n        }\n      }\n    }\n  };\n\n  if (options.nodeInfluenceFactor) {\n    members.forEach(function (item) {\n      addItemInfluence(item, options.nodeInfluenceFactor / nodeInfA);\n    });\n  }\n\n  if (options.edgeInfluenceFactor) {\n    edges.forEach(function (edge) {\n      addEdgeInfluence(edge, options.edgeInfluenceFactor / edgeInfA);\n    });\n  }\n\n  if (options.negativeNodeInfluenceFactor) {\n    nonMembers.forEach(function (item) {\n      addItemInfluence(item, options.negativeNodeInfluenceFactor / nodeInfA);\n    });\n  }\n}\n\nfunction rerouteLine(item, buffer, intersections, wrapNormal) {\n  var bbox = item.getBBox();\n  var topIntersect = intersections[0],\n      leftIntersect = intersections[1],\n      bottomIntersect = intersections[2],\n      rightIntersect = intersections[3];\n  var cornerPos = {\n    topLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.minY - buffer\n    },\n    topRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.minY - buffer\n    },\n    bottomLeft: {\n      x: bbox.minX - buffer,\n      y: bbox.maxY + buffer\n    },\n    bottomRight: {\n      x: bbox.maxX + buffer,\n      y: bbox.maxY + buffer\n    }\n  };\n  var totalArea = bbox.height * bbox.width;\n\n  function calcHalfArea(intersect1, intersect2) {\n    return bbox.width * ((intersect1.y - bbox.minY + (intersect2.y - bbox.minY)) * 0.5);\n  } // 根据线和boundingbox相交的情况，确定control point的位置\n\n\n  if (leftIntersect) {\n    // 相交区域有三角形\n    if (topIntersect) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight; // 相交区域分成上下两个梯形，比较面积\n\n    var topArea = calcHalfArea(leftIntersect, rightIntersect);\n\n    if (topArea < totalArea * 0.5) {\n      if (leftIntersect.y > rightIntersect.y) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n      return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    }\n\n    if (leftIntersect.y < rightIntersect.y) return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n    return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  }\n\n  if (rightIntersect) {\n    if (topIntersect) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n    if (bottomIntersect) return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n  } // 相交区域分成左右两个梯形\n\n\n  var leftArea = calcHalfArea(topIntersect, bottomIntersect);\n\n  if (leftArea < totalArea * 0.5) {\n    if (topIntersect.x > bottomIntersect.x) return wrapNormal ? cornerPos.topLeft : cornerPos.bottomRight;\n    return wrapNormal ? cornerPos.bottomLeft : cornerPos.topRight;\n  }\n\n  if (topIntersect.x < bottomIntersect.x) return wrapNormal ? cornerPos.topRight : cornerPos.bottomLeft;\n  return wrapNormal ? cornerPos.bottomRight : cornerPos.topLeft;\n}"]},"metadata":{},"sourceType":"module"}