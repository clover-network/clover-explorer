{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Ordinal_1 = require(\"../scale/Ordinal\");\n\nvar Interval_1 = require(\"../scale/Interval\");\n\nvar Scale_1 = require(\"../scale/Scale\");\n\nvar barGrid_1 = require(\"../layout/barGrid\");\n\nvar BoundingRect_1 = require(\"zrender/lib/core/BoundingRect\");\n\nvar Time_1 = require(\"../scale/Time\");\n\nvar Log_1 = require(\"../scale/Log\");\n\nvar dataStackHelper_1 = require(\"../data/helper/dataStackHelper\");\n\nvar scaleRawExtentInfo_1 = require(\"./scaleRawExtentInfo\");\n\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var rawExtentResult = scaleRawExtentInfo_1.ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate();\n  scale.setBlank(rawExtentResult.isBlank);\n  var min = rawExtentResult.min;\n  var max = rawExtentResult.max;\n  var ecModel = model.ecModel;\n\n  if (ecModel && scaleType === 'time') {\n    var barSeriesModels = barGrid_1.prepareLayoutBarSeries('bar', ecModel);\n    var isBaseAxisAndHasBarSeries_1 = false;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;\n    });\n\n    if (isBaseAxisAndHasBarSeries_1) {\n      var barWidthAndOffset = barGrid_1.makeColumnLayout(barSeriesModels);\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n\n  return {\n    extent: [min, max],\n    fixMin: rawExtentResult.minFixed,\n    fixMax: rawExtentResult.maxFixed\n  };\n}\n\nexports.getScaleExtent = getScaleExtent;\n\nfunction adjustScaleForOverflow(min, max, model, barWidthAndOffset) {\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0];\n  var barsOnCurrentAxis = barGrid_1.retrieveColumnLayout(barWidthAndOffset, model.axis);\n\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow;\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extentInfo = getScaleExtent(scale, model);\n  var extent = extentInfo.extent;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale instanceof Log_1[\"default\"]) {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: extentInfo.fixMin,\n    fixMax: extentInfo.fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  });\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n\nexports.niceScaleExtent = niceScaleExtent;\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      case 'category':\n        return new Ordinal_1[\"default\"]({\n          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new Time_1[\"default\"]({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        return new (Scale_1[\"default\"].getClass(axisType) || Interval_1[\"default\"])();\n    }\n  }\n}\n\nexports.createScaleByModel = createScaleByModel;\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n\nexports.ifAxisCrossZero = ifAxisCrossZero;\n\nfunction makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n  if (axis.scale.type === 'time') {\n    return function (tpl) {\n      return function (tick, idx) {\n        return axis.scale.getFormattedLabel(tick, idx, tpl);\n      };\n    }(labelFormatter);\n  } else if (typeof labelFormatter === 'string') {\n    return function (tpl) {\n      return function (tick) {\n        var label = axis.scale.getLabel(tick);\n        var text = tpl.replace('{value}', label != null ? label : '');\n        return text;\n      };\n    }(labelFormatter);\n  } else if (typeof labelFormatter === 'function') {\n    return function (cb) {\n      return function (tick, idx) {\n        if (categoryTickStart != null) {\n          idx = tick.value - categoryTickStart;\n        }\n\n        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {\n          level: tick.level\n        } : null);\n      };\n    }(labelFormatter);\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\n\nexports.makeLabelFormatter = makeLabelFormatter;\n\nfunction getAxisRawValue(axis, tick) {\n  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;\n}\n\nexports.getAxisRawValue = getAxisRawValue;\n\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n\n  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n    return;\n  }\n\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent();\n\n  if (scale instanceof Ordinal_1[\"default\"]) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1;\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n\n  for (var i = 0; i < tickCount; i += step) {\n    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n      value: categoryScaleExtent[0] + i\n    };\n    var label = labelFormatter(tick, i);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n\n  return rect;\n}\n\nexports.estimateLabelUnionRect = estimateLabelUnionRect;\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var beforeWidth = textRect.width;\n  var beforeHeight = textRect.height;\n  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n  var rotatedRect = new BoundingRect_1[\"default\"](textRect.x, textRect.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n\nexports.getOptionCategoryInterval = getOptionCategoryInterval;\n\nfunction shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\n\nexports.shouldShowAllLabels = shouldShowAllLabels;\n\nfunction getDataDimensionsOnAxis(data, axisDim) {\n  var dataDimMap = {};\n  zrUtil.each(data.mapDimensionsAll(axisDim), function (dataDim) {\n    dataDimMap[dataStackHelper_1.getStackedDimension(data, dataDim)] = true;\n  });\n  return zrUtil.keys(dataDimMap);\n}\n\nexports.getDataDimensionsOnAxis = getDataDimensionsOnAxis;\n\nfunction unionAxisExtentFromData(dataExtent, data, axisDim) {\n  if (data) {\n    zrUtil.each(getDataDimensionsOnAxis(data, axisDim), function (dim) {\n      var seriesExtent = data.getApproximateExtent(dim);\n      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n    });\n  }\n}\n\nexports.unionAxisExtentFromData = unionAxisExtentFromData;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/coord/axisHelper.js"],"names":["exports","__esModule","zrUtil","require","Ordinal_1","Interval_1","Scale_1","barGrid_1","BoundingRect_1","Time_1","Log_1","dataStackHelper_1","scaleRawExtentInfo_1","getScaleExtent","scale","model","scaleType","type","rawExtentResult","ensureScaleRawExtentInfo","getExtent","calculate","setBlank","isBlank","min","max","ecModel","barSeriesModels","prepareLayoutBarSeries","isBaseAxisAndHasBarSeries_1","each","seriesModel","getBaseAxis","axis","barWidthAndOffset","makeColumnLayout","adjustedScale","adjustScaleForOverflow","extent","fixMin","minFixed","fixMax","maxFixed","axisExtent","axisLength","barsOnCurrentAxis","retrieveColumnLayout","undefined","minOverflow","Infinity","item","Math","offset","maxOverflow","width","abs","totalOverFlow","oldRange","oldRangePercentOfNew","overflowBuffer","niceScaleExtent","extentInfo","splitNumber","get","base","setExtent","niceExtent","minInterval","maxInterval","interval","setInterval","createScaleByModel","axisType","ordinalMeta","getOrdinalMeta","getCategories","locale","getLocaleModel","useUTC","getClass","ifAxisCrossZero","dataExtent","makeLabelFormatter","labelFormatter","getLabelModel","categoryTickStart","tpl","tick","idx","getFormattedLabel","label","getLabel","text","replace","cb","value","getAxisRawValue","level","estimateLabelUnionRect","axisModel","realNumberScaleTicks","tickCount","categoryScaleExtent","count","getTicks","length","axisLabelModel","rect","step","ceil","i","unrotatedSingleRect","getTextRect","singleRect","rotateTextRect","union","textRect","rotate","rotateRadians","PI","beforeWidth","beforeHeight","height","afterWidth","cos","sin","afterHeight","rotatedRect","x","y","getOptionCategoryInterval","shouldShowAllLabels","getDataDimensionsOnAxis","data","axisDim","dataDimMap","mapDimensionsAll","dataDim","getStackedDimension","keys","unionAxisExtentFromData","dim","seriesExtent","getApproximateExtent"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Ordinal_1 = require(\"../scale/Ordinal\");\n\nvar Interval_1 = require(\"../scale/Interval\");\n\nvar Scale_1 = require(\"../scale/Scale\");\n\nvar barGrid_1 = require(\"../layout/barGrid\");\n\nvar BoundingRect_1 = require(\"zrender/lib/core/BoundingRect\");\n\nvar Time_1 = require(\"../scale/Time\");\n\nvar Log_1 = require(\"../scale/Log\");\n\nvar dataStackHelper_1 = require(\"../data/helper/dataStackHelper\");\n\nvar scaleRawExtentInfo_1 = require(\"./scaleRawExtentInfo\");\n\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var rawExtentResult = scaleRawExtentInfo_1.ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate();\n  scale.setBlank(rawExtentResult.isBlank);\n  var min = rawExtentResult.min;\n  var max = rawExtentResult.max;\n  var ecModel = model.ecModel;\n\n  if (ecModel && scaleType === 'time') {\n    var barSeriesModels = barGrid_1.prepareLayoutBarSeries('bar', ecModel);\n    var isBaseAxisAndHasBarSeries_1 = false;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis;\n    });\n\n    if (isBaseAxisAndHasBarSeries_1) {\n      var barWidthAndOffset = barGrid_1.makeColumnLayout(barSeriesModels);\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n\n  return {\n    extent: [min, max],\n    fixMin: rawExtentResult.minFixed,\n    fixMax: rawExtentResult.maxFixed\n  };\n}\n\nexports.getScaleExtent = getScaleExtent;\n\nfunction adjustScaleForOverflow(min, max, model, barWidthAndOffset) {\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0];\n  var barsOnCurrentAxis = barGrid_1.retrieveColumnLayout(barWidthAndOffset, model.axis);\n\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow;\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extentInfo = getScaleExtent(scale, model);\n  var extent = extentInfo.extent;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale instanceof Log_1[\"default\"]) {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: extentInfo.fixMin,\n    fixMax: extentInfo.fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  });\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n\nexports.niceScaleExtent = niceScaleExtent;\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      case 'category':\n        return new Ordinal_1[\"default\"]({\n          ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),\n          extent: [Infinity, -Infinity]\n        });\n\n      case 'time':\n        return new Time_1[\"default\"]({\n          locale: model.ecModel.getLocaleModel(),\n          useUTC: model.ecModel.get('useUTC')\n        });\n\n      default:\n        return new (Scale_1[\"default\"].getClass(axisType) || Interval_1[\"default\"])();\n    }\n  }\n}\n\nexports.createScaleByModel = createScaleByModel;\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n\nexports.ifAxisCrossZero = ifAxisCrossZero;\n\nfunction makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n  if (axis.scale.type === 'time') {\n    return function (tpl) {\n      return function (tick, idx) {\n        return axis.scale.getFormattedLabel(tick, idx, tpl);\n      };\n    }(labelFormatter);\n  } else if (typeof labelFormatter === 'string') {\n    return function (tpl) {\n      return function (tick) {\n        var label = axis.scale.getLabel(tick);\n        var text = tpl.replace('{value}', label != null ? label : '');\n        return text;\n      };\n    }(labelFormatter);\n  } else if (typeof labelFormatter === 'function') {\n    return function (cb) {\n      return function (tick, idx) {\n        if (categoryTickStart != null) {\n          idx = tick.value - categoryTickStart;\n        }\n\n        return cb(getAxisRawValue(axis, tick), idx, tick.level != null ? {\n          level: tick.level\n        } : null);\n      };\n    }(labelFormatter);\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\n\nexports.makeLabelFormatter = makeLabelFormatter;\n\nfunction getAxisRawValue(axis, tick) {\n  return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value;\n}\n\nexports.getAxisRawValue = getAxisRawValue;\n\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n\n  if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {\n    return;\n  }\n\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent();\n\n  if (scale instanceof Ordinal_1[\"default\"]) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1;\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n\n  for (var i = 0; i < tickCount; i += step) {\n    var tick = realNumberScaleTicks ? realNumberScaleTicks[i] : {\n      value: categoryScaleExtent[0] + i\n    };\n    var label = labelFormatter(tick, i);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n\n  return rect;\n}\n\nexports.estimateLabelUnionRect = estimateLabelUnionRect;\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var beforeWidth = textRect.width;\n  var beforeHeight = textRect.height;\n  var afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians));\n  var afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians));\n  var rotatedRect = new BoundingRect_1[\"default\"](textRect.x, textRect.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n\nexports.getOptionCategoryInterval = getOptionCategoryInterval;\n\nfunction shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\n\nexports.shouldShowAllLabels = shouldShowAllLabels;\n\nfunction getDataDimensionsOnAxis(data, axisDim) {\n  var dataDimMap = {};\n  zrUtil.each(data.mapDimensionsAll(axisDim), function (dataDim) {\n    dataDimMap[dataStackHelper_1.getStackedDimension(data, dataDim)] = true;\n  });\n  return zrUtil.keys(dataDimMap);\n}\n\nexports.getDataDimensionsOnAxis = getDataDimensionsOnAxis;\n\nfunction unionAxisExtentFromData(dataExtent, data, axisDim) {\n  if (data) {\n    zrUtil.each(getDataDimensionsOnAxis(data, axisDim), function (dim) {\n      var seriesExtent = data.getApproximateExtent(dim);\n      seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);\n      seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);\n    });\n  }\n}\n\nexports.unionAxisExtentFromData = unionAxisExtentFromData;"]},"metadata":{},"sourceType":"script"}