{"ast":null,"code":"var MAX_MIX_LEVEL = 5; // 最大比对层级\n\nvar toString = {}.toString; // 类型检测\n\nvar isType = function (value, type) {\n  return toString.call(value) === '[object ' + type + ']';\n};\n\nvar isArray = function (value) {\n  return isType(value, 'Array');\n};\n\nvar isObjectLike = function (value) {\n  /**\n   * isObjectLike({}) => true\n   * isObjectLike([1, 2, 3]) => true\n   * isObjectLike(Function) => false\n   */\n  return typeof value === 'object' && value !== null;\n};\n\nvar isPlainObject = function (value) {\n  /**\n   * isObjectLike(new Foo) => false\n   * isObjectLike([1, 2, 3]) => false\n   * isObjectLike({ x: 0, y: 0 }) => true\n   */\n  if (!isObjectLike(value) || !isType(value, 'Object')) {\n    return false;\n  }\n\n  var proto = value;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(value) === proto;\n};\n/***\n * @param {any} dist\n * @param {any} src\n * @param {number} level 当前层级\n * @param {number} maxLevel 最大层级\n */\n\n\nvar deep = function (dist, src, level, maxLevel) {\n  level = level || 0;\n  maxLevel = maxLevel || MAX_MIX_LEVEL;\n\n  for (var key in src) {\n    if (Object.prototype.hasOwnProperty.call(src, key)) {\n      var value = src[key];\n\n      if (!value) {\n        // null 、 undefined 等情况直接赋值\n        dist[key] = value;\n      } else {\n        if (isPlainObject(value)) {\n          if (!isPlainObject(dist[key])) {\n            dist[key] = {};\n          }\n\n          if (level < maxLevel) {\n            deep(dist[key], value, level + 1, maxLevel);\n          } else {\n            // 层级过深直接赋值，性能问题\n            dist[key] = src[key];\n          }\n        } else if (isArray(value)) {\n          dist[key] = [];\n          dist[key] = dist[key].concat(value);\n        } else {\n          dist[key] = value;\n        }\n      }\n    }\n  }\n};\n/**\n * deepAssign 功能类似 deepMix\n * 不同点在于 deepAssign 会将 null undefined 等类型直接覆盖给 source\n * 详细参考： __tests__/unit/utils/deep-assign-spec.ts\n */\n\n\nexport var deepAssign = function (rst) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  for (var i = 0; i < args.length; i += 1) {\n    deep(rst, args[i]);\n  }\n\n  return rst;\n};","map":{"version":3,"sources":["../../src/utils/deep-assign.ts"],"names":[],"mappings":"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","sourcesContent":["const MAX_MIX_LEVEL = 5; // 最大比对层级\n\nconst toString = {}.toString;\n\n// 类型检测\nconst isType = (value: any, type: string): boolean => toString.call(value) === '[object ' + type + ']';\n\nconst isArray = (value: any): value is Array<any> => {\n  return isType(value, 'Array');\n};\n\nconst isObjectLike = (value: any): value is object => {\n  /**\n   * isObjectLike({}) => true\n   * isObjectLike([1, 2, 3]) => true\n   * isObjectLike(Function) => false\n   */\n  return typeof value === 'object' && value !== null;\n};\n\nconst isPlainObject = (value: any): value is object => {\n  /**\n   * isObjectLike(new Foo) => false\n   * isObjectLike([1, 2, 3]) => false\n   * isObjectLike({ x: 0, y: 0 }) => true\n   */\n  if (!isObjectLike(value) || !isType(value, 'Object')) {\n    return false;\n  }\n  let proto = value;\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n  return Object.getPrototypeOf(value) === proto;\n};\n\n/***\n * @param {any} dist\n * @param {any} src\n * @param {number} level 当前层级\n * @param {number} maxLevel 最大层级\n */\nconst deep = (dist, src, level?, maxLevel?) => {\n  level = level || 0;\n  maxLevel = maxLevel || MAX_MIX_LEVEL;\n  for (const key in src) {\n    if (Object.prototype.hasOwnProperty.call(src, key)) {\n      const value = src[key];\n      if (!value) {\n        // null 、 undefined 等情况直接赋值\n        dist[key] = value;\n      } else {\n        if (isPlainObject(value)) {\n          if (!isPlainObject(dist[key])) {\n            dist[key] = {};\n          }\n          if (level < maxLevel) {\n            deep(dist[key], value, level + 1, maxLevel);\n          } else {\n            // 层级过深直接赋值，性能问题\n            dist[key] = src[key];\n          }\n        } else if (isArray(value)) {\n          dist[key] = [];\n          dist[key] = dist[key].concat(value);\n        } else {\n          dist[key] = value;\n        }\n      }\n    }\n  }\n};\n\n/**\n * deepAssign 功能类似 deepMix\n * 不同点在于 deepAssign 会将 null undefined 等类型直接覆盖给 source\n * 详细参考： __tests__/unit/utils/deep-assign-spec.ts\n */\nexport const deepAssign = (rst: any, ...args: any[]) => {\n  for (let i = 0; i < args.length; i += 1) {\n    deep(rst, args[i]);\n  }\n  return rst;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}