{"ast":null,"code":"var dijkstra = function dijkstra(graph, source, directed, weightPropertyName) {\n  var nodes = graph.getNodes();\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.getID();\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodId = minNode.get('id');\n    marks[minNodId] = true;\n    if (D[minNodId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = minNode.getOutEdges();else relatedEdges = minNode.getEdges();\n    relatedEdges.forEach(function (e) {\n      var edgeTarget = e.getTarget().getID();\n      var edgeSource = e.getSource().getID();\n      var w = edgeTarget === minNodId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && e.getModel()[weightPropertyName] ? e.getModel()[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.get('id')] + weight) {\n        D[w] = D[minNode.get('id')] + weight;\n        prevs[w] = minNode.get('id');\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  var path = {};\n\n  for (var target in D) {\n    path[target] = [target];\n    var prev = prevs[target];\n\n    while (prev !== undefined) {\n      path[target].unshift(prev);\n      prev = prevs[prev];\n    }\n  }\n\n  return {\n    length: D,\n    path: path\n  };\n};\n\nfunction minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].get('id');\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n}\n\nexport default dijkstra;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/algorithm/dijkstra.js"],"names":["dijkstra","graph","source","directed","weightPropertyName","nodes","getNodes","nodeIds","marks","D","prevs","forEach","node","i","id","getID","push","Infinity","nodeNum","length","_loop_1","minNode","minVertex","minNodId","get","relatedEdges","getOutEdges","getEdges","e","edgeTarget","getTarget","edgeSource","getSource","w","weight","getModel","path","target","prev","undefined","unshift","minDis","nodeId"],"mappings":"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","sourcesContent":["var dijkstra = function dijkstra(graph, source, directed, weightPropertyName) {\n  var nodes = graph.getNodes();\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.getID();\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodId = minNode.get('id');\n    marks[minNodId] = true;\n    if (D[minNodId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = minNode.getOutEdges();else relatedEdges = minNode.getEdges();\n    relatedEdges.forEach(function (e) {\n      var edgeTarget = e.getTarget().getID();\n      var edgeSource = e.getSource().getID();\n      var w = edgeTarget === minNodId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && e.getModel()[weightPropertyName] ? e.getModel()[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.get('id')] + weight) {\n        D[w] = D[minNode.get('id')] + weight;\n        prevs[w] = minNode.get('id');\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  var path = {};\n\n  for (var target in D) {\n    path[target] = [target];\n    var prev = prevs[target];\n\n    while (prev !== undefined) {\n      path[target].unshift(prev);\n      prev = prevs[prev];\n    }\n  }\n\n  return {\n    length: D,\n    path: path\n  };\n};\n\nfunction minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].get('id');\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n}\n\nexport default dijkstra;"]},"metadata":{},"sourceType":"module"}