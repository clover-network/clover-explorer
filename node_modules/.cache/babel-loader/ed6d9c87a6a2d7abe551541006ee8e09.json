{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport dagre from 'dagre';\nimport isArray from '@antv/util/lib/is-array';\nimport { BaseLayout } from './layout';\nimport { isNumber } from '@antv/util';\n/**\n * 层次布局\n */\n\nvar DagreLayout =\n/** @class */\nfunction (_super) {\n  __extends(DagreLayout, _super);\n\n  function DagreLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n\n    _this.rankdir = 'TB';\n    /** 节点水平间距(px) */\n\n    _this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    _this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以放置同层 combo 重叠 */\n\n    _this.sortByCombo = false;\n    return _this;\n  }\n\n  DagreLayout.prototype.getDefaultCfg = function () {\n    return {\n      rankdir: 'TB',\n      align: undefined,\n      nodeSize: undefined,\n      nodesepFunc: undefined,\n      ranksepFunc: undefined,\n      nodesep: 50,\n      ranksep: 50,\n      controlPoints: false\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  DagreLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes,\n        nodeSize = self.nodeSize,\n        rankdir = self.rankdir;\n    if (!nodes) return;\n    var edges = self.edges || [];\n    var g = new dagre.graphlib.Graph();\n    var nodeSizeFunc;\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        if (d.size) {\n          if (isArray(d.size)) {\n            return d.size;\n          }\n\n          return [d.size, d.size];\n        }\n\n        return [40, 40];\n      };\n    } else if (isArray(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return nodeSize;\n      };\n    } else {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return [nodeSize, nodeSize];\n      };\n    }\n\n    var horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    var vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n\n    if (rankdir === 'LR' || rankdir === 'RL') {\n      horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n      vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    }\n\n    g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n    g.setGraph(self);\n    nodes.forEach(function (node) {\n      var size = nodeSizeFunc(node);\n      var verti = vertisep(node);\n      var hori = horisep(node);\n      var width = size[0] + 2 * hori;\n      var height = size[1] + 2 * verti;\n      g.setNode(node.id, {\n        width: width,\n        height: height\n      });\n    });\n    edges.forEach(function (edge) {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      g.setEdge(edge.source, edge.target, {\n        weight: edge.weight || 1\n      });\n    });\n    dagre.layout(g);\n    var coord;\n    g.nodes().forEach(function (node) {\n      coord = g.node(node);\n      var i = nodes.findIndex(function (it) {\n        return it.id === node;\n      });\n      nodes[i].x = coord.x;\n      nodes[i].y = coord.y;\n    });\n    g.edges().forEach(function (edge) {\n      coord = g.edge(edge);\n      var i = edges.findIndex(function (it) {\n        return it.source === edge.v && it.target === edge.w;\n      });\n\n      if (self.controlPoints && edges[i].type !== 'loop' && edges[i].shape !== 'loop') {\n        edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n      }\n    });\n\n    if (self.sortByCombo) {\n      self.sortLevel('comboId');\n    }\n  };\n\n  DagreLayout.prototype.sortLevel = function (propertyName) {\n    var self = this;\n    var nodes = self.nodes;\n    var levels = {};\n    nodes.forEach(function (node) {\n      if (!levels[node.y]) levels[node.y] = {\n        y: node.y,\n        nodes: []\n      };\n      levels[node.y].nodes.push(node);\n    });\n    Object.keys(levels).forEach(function (key) {\n      var levelNodes = levels[key].nodes;\n      var nodesNum = levelNodes.length;\n      var comboCenters = {};\n      levelNodes.forEach(function (lnode) {\n        var lnodeCombo = lnode.comboId;\n        if (!comboCenters[lnodeCombo]) comboCenters[lnodeCombo] = {\n          x: 0,\n          y: 0,\n          count: 0\n        };\n        comboCenters[lnodeCombo].x += lnode.x;\n        comboCenters[lnodeCombo].y += lnode.y;\n        comboCenters[lnodeCombo].count++;\n      });\n      Object.keys(comboCenters).forEach(function (ckey) {\n        comboCenters[ckey].x /= comboCenters[ckey].count;\n        comboCenters[ckey].y /= comboCenters[ckey].count;\n      });\n      if (nodesNum === 1) return;\n      var sortedByX = levelNodes.sort(function (a, b) {\n        return a.x - b.x;\n      });\n      var minX = sortedByX[0].x;\n      var maxX = sortedByX[nodesNum - 1].x;\n      var gap = (maxX - minX) / (nodesNum - 1);\n      var sortedByCombo = levelNodes.sort(function (a, b) {\n        var aValue = a[propertyName] || 'undefined';\n        var bValue = b[propertyName] || 'undefined';\n\n        if (aValue < bValue) {\n          return -1;\n        }\n\n        if (aValue > bValue) {\n          return 1;\n        }\n\n        return 0;\n      });\n      sortedByCombo.forEach(function (node, i) {\n        node.x = minX + i * gap;\n      });\n    });\n  };\n\n  return DagreLayout;\n}(BaseLayout);\n\nexport default DagreLayout;\n\nfunction getFunc(func, value, defaultValue) {\n  var resultFunc;\n\n  if (func) {\n    resultFunc = func;\n  } else if (isNumber(value)) {\n    resultFunc = function resultFunc() {\n      return value;\n    };\n  } else {\n    resultFunc = function resultFunc() {\n      return defaultValue;\n    };\n  }\n\n  return resultFunc;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/dagre.js"],"names":["__extends","dagre","isArray","BaseLayout","isNumber","DagreLayout","_super","_this","apply","arguments","rankdir","nodesep","ranksep","controlPoints","sortByCombo","prototype","getDefaultCfg","align","undefined","nodeSize","nodesepFunc","ranksepFunc","execute","self","nodes","edges","g","graphlib","Graph","nodeSizeFunc","d","size","horisep","getFunc","vertisep","setDefaultEdgeLabel","setGraph","forEach","node","verti","hori","width","height","setNode","id","edge","setEdge","source","target","weight","layout","coord","i","findIndex","it","x","y","v","w","type","shape","points","slice","length","sortLevel","propertyName","levels","push","Object","keys","key","levelNodes","nodesNum","comboCenters","lnode","lnodeCombo","comboId","count","ckey","sortedByX","sort","a","b","minX","maxX","gap","sortedByCombo","aValue","bValue","func","value","defaultValue","resultFunc"],"mappings":"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","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport dagre from 'dagre';\nimport isArray from '@antv/util/lib/is-array';\nimport { BaseLayout } from './layout';\nimport { isNumber } from '@antv/util';\n/**\n * 层次布局\n */\n\nvar DagreLayout =\n/** @class */\nfunction (_super) {\n  __extends(DagreLayout, _super);\n\n  function DagreLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n\n    _this.rankdir = 'TB';\n    /** 节点水平间距(px) */\n\n    _this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    _this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以放置同层 combo 重叠 */\n\n    _this.sortByCombo = false;\n    return _this;\n  }\n\n  DagreLayout.prototype.getDefaultCfg = function () {\n    return {\n      rankdir: 'TB',\n      align: undefined,\n      nodeSize: undefined,\n      nodesepFunc: undefined,\n      ranksepFunc: undefined,\n      nodesep: 50,\n      ranksep: 50,\n      controlPoints: false\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  DagreLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes,\n        nodeSize = self.nodeSize,\n        rankdir = self.rankdir;\n    if (!nodes) return;\n    var edges = self.edges || [];\n    var g = new dagre.graphlib.Graph();\n    var nodeSizeFunc;\n\n    if (!nodeSize) {\n      nodeSizeFunc = function nodeSizeFunc(d) {\n        if (d.size) {\n          if (isArray(d.size)) {\n            return d.size;\n          }\n\n          return [d.size, d.size];\n        }\n\n        return [40, 40];\n      };\n    } else if (isArray(nodeSize)) {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return nodeSize;\n      };\n    } else {\n      nodeSizeFunc = function nodeSizeFunc() {\n        return [nodeSize, nodeSize];\n      };\n    }\n\n    var horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    var vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n\n    if (rankdir === 'LR' || rankdir === 'RL') {\n      horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n      vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n    }\n\n    g.setDefaultEdgeLabel(function () {\n      return {};\n    });\n    g.setGraph(self);\n    nodes.forEach(function (node) {\n      var size = nodeSizeFunc(node);\n      var verti = vertisep(node);\n      var hori = horisep(node);\n      var width = size[0] + 2 * hori;\n      var height = size[1] + 2 * verti;\n      g.setNode(node.id, {\n        width: width,\n        height: height\n      });\n    });\n    edges.forEach(function (edge) {\n      // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n      g.setEdge(edge.source, edge.target, {\n        weight: edge.weight || 1\n      });\n    });\n    dagre.layout(g);\n    var coord;\n    g.nodes().forEach(function (node) {\n      coord = g.node(node);\n      var i = nodes.findIndex(function (it) {\n        return it.id === node;\n      });\n      nodes[i].x = coord.x;\n      nodes[i].y = coord.y;\n    });\n    g.edges().forEach(function (edge) {\n      coord = g.edge(edge);\n      var i = edges.findIndex(function (it) {\n        return it.source === edge.v && it.target === edge.w;\n      });\n\n      if (self.controlPoints && edges[i].type !== 'loop' && edges[i].shape !== 'loop') {\n        edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n      }\n    });\n\n    if (self.sortByCombo) {\n      self.sortLevel('comboId');\n    }\n  };\n\n  DagreLayout.prototype.sortLevel = function (propertyName) {\n    var self = this;\n    var nodes = self.nodes;\n    var levels = {};\n    nodes.forEach(function (node) {\n      if (!levels[node.y]) levels[node.y] = {\n        y: node.y,\n        nodes: []\n      };\n      levels[node.y].nodes.push(node);\n    });\n    Object.keys(levels).forEach(function (key) {\n      var levelNodes = levels[key].nodes;\n      var nodesNum = levelNodes.length;\n      var comboCenters = {};\n      levelNodes.forEach(function (lnode) {\n        var lnodeCombo = lnode.comboId;\n        if (!comboCenters[lnodeCombo]) comboCenters[lnodeCombo] = {\n          x: 0,\n          y: 0,\n          count: 0\n        };\n        comboCenters[lnodeCombo].x += lnode.x;\n        comboCenters[lnodeCombo].y += lnode.y;\n        comboCenters[lnodeCombo].count++;\n      });\n      Object.keys(comboCenters).forEach(function (ckey) {\n        comboCenters[ckey].x /= comboCenters[ckey].count;\n        comboCenters[ckey].y /= comboCenters[ckey].count;\n      });\n      if (nodesNum === 1) return;\n      var sortedByX = levelNodes.sort(function (a, b) {\n        return a.x - b.x;\n      });\n      var minX = sortedByX[0].x;\n      var maxX = sortedByX[nodesNum - 1].x;\n      var gap = (maxX - minX) / (nodesNum - 1);\n      var sortedByCombo = levelNodes.sort(function (a, b) {\n        var aValue = a[propertyName] || 'undefined';\n        var bValue = b[propertyName] || 'undefined';\n\n        if (aValue < bValue) {\n          return -1;\n        }\n\n        if (aValue > bValue) {\n          return 1;\n        }\n\n        return 0;\n      });\n      sortedByCombo.forEach(function (node, i) {\n        node.x = minX + i * gap;\n      });\n    });\n  };\n\n  return DagreLayout;\n}(BaseLayout);\n\nexport default DagreLayout;\n\nfunction getFunc(func, value, defaultValue) {\n  var resultFunc;\n\n  if (func) {\n    resultFunc = func;\n  } else if (isNumber(value)) {\n    resultFunc = function resultFunc() {\n      return value;\n    };\n  } else {\n    resultFunc = function resultFunc() {\n      return defaultValue;\n    };\n  }\n\n  return resultFunc;\n}"]},"metadata":{},"sourceType":"module"}