{"ast":null,"code":"/**\n * @fileOverview 自定义边\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\n * @author dxq613@gmail.com\n */\nimport { __assign } from \"tslib\";\nimport { deepMix, mix, each, isNil } from '@antv/util';\nimport { getLabelPosition, getLoopCfgs } from '../util/graphic';\nimport { distance, getCircleCenterByPoints } from '../util/math';\nimport { getControlPoint, getSpline } from '../util/path';\nimport Global from '../global';\nimport Shape from './shape';\nimport { shapeBase, CLS_LABEL_BG_SUFFIX } from './shapeBase';\nimport isArray from '@antv/util/lib/is-array';\nimport isNumber from '@antv/util/lib/is-number';\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\n\nfunction revertAlign(labelPosition) {\n  var textAlign = labelPosition;\n\n  if (labelPosition === 'start') {\n    textAlign = 'end';\n  } else if (labelPosition === 'end') {\n    textAlign = 'start';\n  }\n\n  return textAlign;\n}\n\nvar singleEdge = {\n  itemType: 'edge',\n\n  /**\n   * 文本的位置\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本的 x 偏移\n   * @type {Number}\n   */\n  refX: 0,\n\n  /**\n   * 文本的 y 偏移\n   * @type {Number}\n   */\n  refY: 0,\n\n  /**\n   * 文本是否跟着线自动旋转，默认 false\n   * @type {Boolean}\n   */\n  labelAutoRotate: false,\n  // 自定义边时的配置\n  options: {\n    size: Global.defaultEdge.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: Global.defaultEdge.style.stroke,\n      lineAppendWidth: Global.defaultEdge.style.lineAppendWidth\n    },\n    labelCfg: {\n      style: {\n        fill: Global.edgeLabel.style.fill,\n        fontSize: Global.edgeLabel.style.fontSize\n      }\n    },\n    stateStyles: __assign({}, Global.edgeStateStyles)\n  },\n\n  /**\n   * 获取边的 path\n   * @internal 供扩展的边覆盖\n   * @param  {Array} points 构成边的点的集合\n   * @return {Array} 构成 path 的数组\n   */\n  getPath: function getPath(points) {\n    var path = [];\n    each(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = mix({}, defaultStyle, strokeStyle, cfg.style);\n    var size = cfg.size || Global.defaultEdge.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var path = this.getPath(points);\n    var styles = mix({}, Global.defaultEdge.style, {\n      stroke: Global.defaultEdge.color,\n      lineWidth: size,\n      path: path\n    }, style);\n    return styles;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    var strokeStyle = {\n      stroke: cfg.color\n    };\n    var shape = group.find(function (element) {\n      return element.get('className') === 'edge-shape';\n    }) || item.getKeyShape();\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var previousStyle = mix({}, strokeStyle, shape.attr(), cfg.style);\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var routeCfg = {\n      radius: previousStyle.radius\n    };\n\n    if (!controlPoints) {\n      routeCfg = {\n        source: source,\n        target: target,\n        offset: previousStyle.offset,\n        radius: previousStyle.radius\n      };\n    }\n\n    var path = this.getPath(points, routeCfg);\n    var style = mix(strokeStyle, shape.attr(), {\n      lineWidth: size,\n      path: path\n    }, cfg.style);\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\n\n    var style = {};\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      style.text = cfg.label;\n      return style;\n    }\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);\n    style.x = offsetStyle.x;\n    style.y = offsetStyle.y;\n    style.rotate = offsetStyle.rotate;\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = backgroundStyle.padding;\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var labelPosition = labelCfg.position || this.labelPosition;\n\n    var style = __assign(__assign({}, backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight,\n      x: bbox.minX - padding[2],\n      y: bbox.minY - padding[0],\n      rotate: 0\n    });\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      return style;\n    }\n\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX - backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    var rad = offsetStyle.angle;\n\n    if (rad > 1 / 2 * Math.PI && rad < 3 * 1 / 2 * Math.PI) {\n      offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX + backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    }\n\n    if (autoRotate) {\n      style.x = offsetStyle.x;\n      style.y = offsetStyle.y;\n    }\n\n    style.rotate = offsetStyle.rotate;\n    return style;\n  },\n  // 获取文本对齐方式\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\n    var textAlign = 'center';\n\n    if (!angle) {\n      return labelPosition;\n    }\n\n    angle = angle % (Math.PI * 2); // 取模\n\n    if (labelPosition !== 'center') {\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\n        textAlign = labelPosition;\n      } else {\n        textAlign = revertAlign(labelPosition);\n      }\n    }\n\n    return textAlign;\n  },\n\n  /**\n   * @internal 获取边的控制点\n   * @param  {Object} cfg 边的配置项\n   * @return {Array} 控制点的数组\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * @internal 处理需要重计算点和边的情况\n   * @param {Object} cfg 边的配置项\n   * @return {Object} 边的配置项\n   */\n  getPathPoints: function getPathPoints(cfg) {\n    return cfg;\n  },\n\n  /**\n   * 绘制边\n   * @override\n   * @param  {Object} cfg   边的配置项\n   * @param  {G.Group} group 边的容器\n   * @return {IShape} 图形\n   */\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    var shape = group.addShape('path', {\n      className: CLS_SHAPE,\n      name: CLS_SHAPE,\n      attrs: shapeStyle\n    });\n    return shape;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({\n      fontFamily: typeof window !== 'undefined' ? window.getComputedStyle(document.body, null).getPropertyValue(\"font-family\") || 'Arial, sans-serif' : 'Arial, sans-serif'\n    }, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      name: 'text-shape'\n    });\n\n    if (rotate) {\n      label.rotateAtStart(rotate);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label);\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    delete style.rotate;\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    if (rotate) rect.rotateAtStart(rotate);\n    return rect;\n  }\n};\n\nvar singleEdgeDef = __assign(__assign({}, shapeBase), singleEdge);\n\nShape.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\n\nShape.registerEdge('line', {\n  // 控制点不生效\n  getControlPoints: function getControlPoints() {\n    return undefined;\n  }\n}, 'single-edge'); // 直线\n\nShape.registerEdge('spline', {\n  getPath: function getPath(points) {\n    var path = getSpline(points);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('arc', {\n  curveOffset: 20,\n  clockwise: 1,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var midPoint = {\n      x: (startPoint.x + endPoint.x) / 2,\n      y: (startPoint.y + endPoint.y) / 2\n    };\n    var center;\n    var arcPoint; // 根据给定点计算圆弧\n\n    if (cfg.controlPoints !== undefined) {\n      arcPoint = cfg.controlPoints[0];\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\n\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\n      } else {\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\n\n\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\n        return [];\n      }\n    } else {\n      // 根据直线连线中点的的偏移计算圆弧\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\n      if (cfg.curveOffset === undefined) {\n        cfg.curveOffset = this.curveOffset;\n      }\n\n      if (isArray(cfg.curveOffset)) {\n        cfg.curveOffset = cfg.curveOffset[0];\n      }\n\n      if (cfg.curveOffset < 0) {\n        this.clockwise = 0;\n      } else {\n        this.clockwise = 1;\n      }\n\n      var vec = {\n        x: endPoint.x - startPoint.x,\n        y: endPoint.y - startPoint.y\n      };\n      var edgeAngle = Math.atan2(vec.y, vec.x);\n      arcPoint = {\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\n      };\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);\n    }\n\n    var radius = distance(startPoint, center);\n    var controlPoints = [{\n      x: radius,\n      y: radius\n    }];\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\n\n    if (points.length === 2) {\n      path.push(['L', points[1].x, points[1].y]);\n    } else {\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\n    }\n\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('quadratic', {\n  curvePosition: 0.5,\n  curveOffset: -20,\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (!controlPoints || !controlPoints.length) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n      if (isArray(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\n      if (isArray(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\n      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\n      controlPoints = [innerPoint];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('cubic', {\n  curvePosition: [1 / 2, 1 / 2],\n  curveOffset: [-20, 20],\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\n      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\n      controlPoints = [innerPoint1, innerPoint2];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    return path;\n  }\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-vertical', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: startPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[0] + startPoint.y\n    };\n    var innerPoint2 = {\n      x: endPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[1] + startPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-horizontal', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[0] + startPoint.x,\n      y: startPoint.y\n    };\n    var innerPoint2 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[1] + startPoint.x,\n      y: endPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic');\nShape.registerEdge('loop', {\n  getPathPoints: function getPathPoints(cfg) {\n    return getLoopCfgs(cfg);\n  },\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n  afterDraw: function afterDraw(cfg) {\n    cfg.controlPoints = undefined;\n  },\n  afterUpdate: function afterUpdate(cfg) {\n    cfg.controlPoints = undefined;\n  }\n}, 'cubic');","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/shape/edge.js"],"names":["__assign","deepMix","mix","each","isNil","getLabelPosition","getLoopCfgs","distance","getCircleCenterByPoints","getControlPoint","getSpline","Global","Shape","shapeBase","CLS_LABEL_BG_SUFFIX","isArray","isNumber","CLS_SHAPE","revertAlign","labelPosition","textAlign","singleEdge","itemType","refX","refY","labelAutoRotate","options","size","defaultEdge","style","x","y","stroke","lineAppendWidth","labelCfg","fill","edgeLabel","fontSize","stateStyles","edgeStateStyles","getPath","points","path","point","index","push","getShapeStyle","cfg","defaultStyle","strokeStyle","color","getPathPoints","startPoint","endPoint","controlPoints","getControlPoints","concat","styles","lineWidth","updateShapeStyle","item","group","getContainer","shape","find","element","get","getKeyShape","previousStyle","attr","source","sourceNode","target","targetNode","routeCfg","radius","offset","getLabelStyleByPosition","position","pathShape","pointPercent","offsetX","offsetY","text","label","autoRotate","offsetStyle","rotate","_getTextAlign","angle","getLabelBgStyleByPosition","bbox","getBBox","backgroundStyle","background","padding","backgroundWidth","width","backgroundHeight","height","minX","minY","rad","Math","PI","drawShape","shapeStyle","addShape","className","name","attrs","drawLabel","defaultLabelCfg","fontFamily","window","getComputedStyle","document","body","getPropertyValue","labelStyle","getLabelStyle","rotateAtStart","rect","drawLabelBg","labelBgClassname","set","toFront","singleEdgeDef","registerEdge","undefined","curveOffset","clockwise","midPoint","center","arcPoint","vec","edgeAngle","atan2","cos","sin","length","curvePosition","innerPoint","innerPoint1","innerPoint2","afterDraw","afterUpdate"],"mappings":"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","sourcesContent":["/**\n * @fileOverview 自定义边\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\n * @author dxq613@gmail.com\n */\nimport { __assign } from \"tslib\";\nimport { deepMix, mix, each, isNil } from '@antv/util';\nimport { getLabelPosition, getLoopCfgs } from '../util/graphic';\nimport { distance, getCircleCenterByPoints } from '../util/math';\nimport { getControlPoint, getSpline } from '../util/path';\nimport Global from '../global';\nimport Shape from './shape';\nimport { shapeBase, CLS_LABEL_BG_SUFFIX } from './shapeBase';\nimport isArray from '@antv/util/lib/is-array';\nimport isNumber from '@antv/util/lib/is-number';\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\n\nfunction revertAlign(labelPosition) {\n  var textAlign = labelPosition;\n\n  if (labelPosition === 'start') {\n    textAlign = 'end';\n  } else if (labelPosition === 'end') {\n    textAlign = 'start';\n  }\n\n  return textAlign;\n}\n\nvar singleEdge = {\n  itemType: 'edge',\n\n  /**\n   * 文本的位置\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本的 x 偏移\n   * @type {Number}\n   */\n  refX: 0,\n\n  /**\n   * 文本的 y 偏移\n   * @type {Number}\n   */\n  refY: 0,\n\n  /**\n   * 文本是否跟着线自动旋转，默认 false\n   * @type {Boolean}\n   */\n  labelAutoRotate: false,\n  // 自定义边时的配置\n  options: {\n    size: Global.defaultEdge.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: Global.defaultEdge.style.stroke,\n      lineAppendWidth: Global.defaultEdge.style.lineAppendWidth\n    },\n    labelCfg: {\n      style: {\n        fill: Global.edgeLabel.style.fill,\n        fontSize: Global.edgeLabel.style.fontSize\n      }\n    },\n    stateStyles: __assign({}, Global.edgeStateStyles)\n  },\n\n  /**\n   * 获取边的 path\n   * @internal 供扩展的边覆盖\n   * @param  {Array} points 构成边的点的集合\n   * @return {Array} 构成 path 的数组\n   */\n  getPath: function getPath(points) {\n    var path = [];\n    each(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = mix({}, defaultStyle, strokeStyle, cfg.style);\n    var size = cfg.size || Global.defaultEdge.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var path = this.getPath(points);\n    var styles = mix({}, Global.defaultEdge.style, {\n      stroke: Global.defaultEdge.color,\n      lineWidth: size,\n      path: path\n    }, style);\n    return styles;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item) {\n    var group = item.getContainer();\n    var strokeStyle = {\n      stroke: cfg.color\n    };\n    var shape = group.find(function (element) {\n      return element.get('className') === 'edge-shape';\n    }) || item.getKeyShape();\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var previousStyle = mix({}, strokeStyle, shape.attr(), cfg.style);\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var routeCfg = {\n      radius: previousStyle.radius\n    };\n\n    if (!controlPoints) {\n      routeCfg = {\n        source: source,\n        target: target,\n        offset: previousStyle.offset,\n        radius: previousStyle.radius\n      };\n    }\n\n    var path = this.getPath(points, routeCfg);\n    var style = mix(strokeStyle, shape.attr(), {\n      lineWidth: size,\n      path: path\n    }, cfg.style);\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\n\n    var style = {};\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      style.text = cfg.label;\n      return style;\n    }\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);\n    style.x = offsetStyle.x;\n    style.y = offsetStyle.y;\n    style.rotate = offsetStyle.rotate;\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = backgroundStyle.padding;\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var labelPosition = labelCfg.position || this.labelPosition;\n\n    var style = __assign(__assign({}, backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight,\n      x: bbox.minX - padding[2],\n      y: bbox.minY - padding[0],\n      rotate: 0\n    });\n\n    var autoRotate = isNil(labelCfg.autoRotate) ? this.labelAutoRotate : labelCfg.autoRotate;\n    var pathShape = group && group.find(function (element) {\n      return element.get('className') === CLS_SHAPE;\n    }); // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      return style;\n    }\n\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX - backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    var rad = offsetStyle.angle;\n\n    if (rad > 1 / 2 * Math.PI && rad < 3 * 1 / 2 * Math.PI) {\n      offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX + backgroundWidth / 2, offsetY + backgroundHeight / 2, autoRotate);\n    }\n\n    if (autoRotate) {\n      style.x = offsetStyle.x;\n      style.y = offsetStyle.y;\n    }\n\n    style.rotate = offsetStyle.rotate;\n    return style;\n  },\n  // 获取文本对齐方式\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\n    var textAlign = 'center';\n\n    if (!angle) {\n      return labelPosition;\n    }\n\n    angle = angle % (Math.PI * 2); // 取模\n\n    if (labelPosition !== 'center') {\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\n        textAlign = labelPosition;\n      } else {\n        textAlign = revertAlign(labelPosition);\n      }\n    }\n\n    return textAlign;\n  },\n\n  /**\n   * @internal 获取边的控制点\n   * @param  {Object} cfg 边的配置项\n   * @return {Array} 控制点的数组\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * @internal 处理需要重计算点和边的情况\n   * @param {Object} cfg 边的配置项\n   * @return {Object} 边的配置项\n   */\n  getPathPoints: function getPathPoints(cfg) {\n    return cfg;\n  },\n\n  /**\n   * 绘制边\n   * @override\n   * @param  {Object} cfg   边的配置项\n   * @param  {G.Group} group 边的容器\n   * @return {IShape} 图形\n   */\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    var shape = group.addShape('path', {\n      className: CLS_SHAPE,\n      name: CLS_SHAPE,\n      attrs: shapeStyle\n    });\n    return shape;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({\n      fontFamily: typeof window !== 'undefined' ? window.getComputedStyle(document.body, null).getPropertyValue(\"font-family\") || 'Arial, sans-serif' : 'Arial, sans-serif'\n    }, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      name: 'text-shape'\n    });\n\n    if (rotate) {\n      label.rotateAtStart(rotate);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label);\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    delete style.rotate;\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    if (rotate) rect.rotateAtStart(rotate);\n    return rect;\n  }\n};\n\nvar singleEdgeDef = __assign(__assign({}, shapeBase), singleEdge);\n\nShape.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\n\nShape.registerEdge('line', {\n  // 控制点不生效\n  getControlPoints: function getControlPoints() {\n    return undefined;\n  }\n}, 'single-edge'); // 直线\n\nShape.registerEdge('spline', {\n  getPath: function getPath(points) {\n    var path = getSpline(points);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('arc', {\n  curveOffset: 20,\n  clockwise: 1,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var midPoint = {\n      x: (startPoint.x + endPoint.x) / 2,\n      y: (startPoint.y + endPoint.y) / 2\n    };\n    var center;\n    var arcPoint; // 根据给定点计算圆弧\n\n    if (cfg.controlPoints !== undefined) {\n      arcPoint = cfg.controlPoints[0];\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\n\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\n      } else {\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\n\n\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\n        return [];\n      }\n    } else {\n      // 根据直线连线中点的的偏移计算圆弧\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\n      if (cfg.curveOffset === undefined) {\n        cfg.curveOffset = this.curveOffset;\n      }\n\n      if (isArray(cfg.curveOffset)) {\n        cfg.curveOffset = cfg.curveOffset[0];\n      }\n\n      if (cfg.curveOffset < 0) {\n        this.clockwise = 0;\n      } else {\n        this.clockwise = 1;\n      }\n\n      var vec = {\n        x: endPoint.x - startPoint.x,\n        y: endPoint.y - startPoint.y\n      };\n      var edgeAngle = Math.atan2(vec.y, vec.x);\n      arcPoint = {\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\n      };\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);\n    }\n\n    var radius = distance(startPoint, center);\n    var controlPoints = [{\n      x: radius,\n      y: radius\n    }];\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\n\n    if (points.length === 2) {\n      path.push(['L', points[1].x, points[1].y]);\n    } else {\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\n    }\n\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('quadratic', {\n  curvePosition: 0.5,\n  curveOffset: -20,\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (!controlPoints || !controlPoints.length) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n      if (isArray(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\n      if (isArray(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\n      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\n      controlPoints = [innerPoint];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('cubic', {\n  curvePosition: [1 / 2, 1 / 2],\n  curveOffset: [-20, 20],\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\n      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\n      controlPoints = [innerPoint1, innerPoint2];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    return path;\n  }\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-vertical', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: startPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[0] + startPoint.y\n    };\n    var innerPoint2 = {\n      x: endPoint.x,\n      y: (endPoint.y - startPoint.y) * this.curvePosition[1] + startPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-horizontal', {\n  curvePosition: [1 / 2, 1 / 2],\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition !== undefined) this.curvePosition = cfg.curvePosition;\n    if (isNumber(this.curvePosition)) this.curvePosition = [this.curvePosition, 1 - this.curvePosition];\n    var innerPoint1 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[0] + startPoint.x,\n      y: startPoint.y\n    };\n    var innerPoint2 = {\n      x: (endPoint.x - startPoint.x) * this.curvePosition[1] + startPoint.x,\n      y: endPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic');\nShape.registerEdge('loop', {\n  getPathPoints: function getPathPoints(cfg) {\n    return getLoopCfgs(cfg);\n  },\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n  afterDraw: function afterDraw(cfg) {\n    cfg.controlPoints = undefined;\n  },\n  afterUpdate: function afterUpdate(cfg) {\n    cfg.controlPoints = undefined;\n  }\n}, 'cubic');"]},"metadata":{},"sourceType":"module"}