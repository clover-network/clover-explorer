{"ast":null,"code":"/**\n * 将数据序列转换成 sankey layout 需要的数据结构\n * 1. 过滤掉处理来源去向相同的节点\n * 2. 避免形成环\n * @param data\n * @param sourceField\n * @param targetField\n * @param weightField\n */\nexport function transformDataToSankey(data, sourceField, targetField, weightField) {\n  if (!Array.isArray(data)) {\n    return {\n      nodes: [],\n      links: []\n    };\n  }\n\n  var nodes = [];\n  var links = []; // TODO 逍为\n  // 1. 使用 Map 进行一些性能优化（目前 includes，indexOf 会大量进行数组遍历）\n  // 2. link 去重\n  // 数组变换成 sankey layout 的数据结构\n\n  data.forEach(function (datum) {\n    var source = datum[sourceField];\n    var target = datum[targetField];\n    var weight = datum[weightField]; // source node\n\n    if (!nodes.includes(source)) {\n      nodes.push(source);\n    } // target node\n\n\n    if (!nodes.includes(target)) {\n      nodes.push(target);\n    } // links\n\n\n    links.push({\n      source: nodes.indexOf(source),\n      target: nodes.indexOf(target),\n      value: weight\n    });\n  });\n  return {\n    nodes: nodes.map(function (name) {\n      return {\n        name: name\n      };\n    }),\n    links: links\n  };\n}","map":{"version":3,"sources":["../../../../src/plots/sankey/util/data.ts"],"names":[],"mappings":"AAGA;;;;;;;;AAQG;AACH,OAAM,SAAU,qBAAV,CACJ,IADI,EAEJ,WAFI,EAGJ,WAHI,EAIJ,WAJI,EAIe;AAEnB,MAAI,CAAC,KAAK,CAAC,OAAN,CAAc,IAAd,CAAL,EAA0B;AACxB,WAAO;AACL,MAAA,KAAK,EAAE,EADF;AAEL,MAAA,KAAK,EAAE;AAFF,KAAP;AAID;;AAED,MAAM,KAAK,GAAG,EAAd;AACA,MAAM,KAAK,GAAG,EAAd,CAVmB,CAYnB;AACA;AACA;AAEA;;AACA,EAAA,IAAI,CAAC,OAAL,CAAa,UAAC,KAAD,EAAa;AACxB,QAAM,MAAM,GAAG,KAAK,CAAC,WAAD,CAApB;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,WAAD,CAApB;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,WAAD,CAApB,CAHwB,CAKxB;;AACA,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,MAAf,CAAL,EAA6B;AAC3B,MAAA,KAAK,CAAC,IAAN,CAAW,MAAX;AACD,KARuB,CAUxB;;;AACA,QAAI,CAAC,KAAK,CAAC,QAAN,CAAe,MAAf,CAAL,EAA6B;AAC3B,MAAA,KAAK,CAAC,IAAN,CAAW,MAAX;AACD,KAbuB,CAexB;;;AACA,IAAA,KAAK,CAAC,IAAN,CAAW;AACT,MAAA,MAAM,EAAE,KAAK,CAAC,OAAN,CAAc,MAAd,CADC;AAET,MAAA,MAAM,EAAE,KAAK,CAAC,OAAN,CAAc,MAAd,CAFC;AAGT,MAAA,KAAK,EAAE;AAHE,KAAX;AAKD,GArBD;AAuBA,SAAO;AACL,IAAA,KAAK,EAAE,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD,EAAK;AAAK,aAAC;AAAE,QAAA,IAAI,EAAP;AAAC,OAAD;AAAU,KAA9B,CADF;AAEL,IAAA,KAAK,EAAA;AAFA,GAAP;AAID","sourcesContent":["import { Data, Datum } from '../../../types';\nimport { SankeyLayoutInputData } from '../../../utils/transform/sankey';\n\n/**\n * 将数据序列转换成 sankey layout 需要的数据结构\n * 1. 过滤掉处理来源去向相同的节点\n * 2. 避免形成环\n * @param data\n * @param sourceField\n * @param targetField\n * @param weightField\n */\nexport function transformDataToSankey(\n  data: Data,\n  sourceField: string,\n  targetField: string,\n  weightField: string\n): SankeyLayoutInputData {\n  if (!Array.isArray(data)) {\n    return {\n      nodes: [],\n      links: [],\n    };\n  }\n\n  const nodes = [];\n  const links = [];\n\n  // TODO 逍为\n  // 1. 使用 Map 进行一些性能优化（目前 includes，indexOf 会大量进行数组遍历）\n  // 2. link 去重\n\n  // 数组变换成 sankey layout 的数据结构\n  data.forEach((datum: Datum) => {\n    const source = datum[sourceField];\n    const target = datum[targetField];\n    const weight = datum[weightField];\n\n    // source node\n    if (!nodes.includes(source)) {\n      nodes.push(source);\n    }\n\n    // target node\n    if (!nodes.includes(target)) {\n      nodes.push(target);\n    }\n\n    // links\n    links.push({\n      source: nodes.indexOf(source),\n      target: nodes.indexOf(target),\n      value: weight,\n    });\n  });\n\n  return {\n    nodes: nodes.map((name) => ({ name })),\n    links,\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}