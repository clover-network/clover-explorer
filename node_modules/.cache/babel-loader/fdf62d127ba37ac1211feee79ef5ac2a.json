{"ast":null,"code":"/**\n * @fileOverview grid layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { __extends } from \"tslib\";\nimport isString from '@antv/util/lib/is-string';\nimport { BaseLayout } from './layout';\nimport { isArray, isNumber } from '@antv/util';\nimport { getDegree } from '../util/math';\nimport { isNaN } from '../util/base';\n/**\n * 网格布局\n */\n\nvar GridLayout =\n/** @class */\nfunction (_super) {\n  __extends(GridLayout, _super);\n\n  function GridLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局起始点 */\n\n\n    _this.begin = [0, 0];\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = true;\n    /** extra spacing around nodes when preventOverlap: true */\n\n    _this.preventOverlapPadding = 10;\n    /** uses all available space on false, uses minimal space on true */\n\n    _this.condense = false;\n    /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\n\n    _this.sortBy = 'degree';\n    _this.nodeSize = 30;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    _this.width = 300;\n    _this.height = 300;\n    _this.row = 0;\n    _this.col = 0;\n    _this.cellWidth = 0;\n    _this.cellHeight = 0;\n    _this.cellUsed = {};\n    _this.id2manPos = {};\n    return _this;\n  }\n\n  GridLayout.prototype.getDefaultCfg = function () {\n    return {\n      begin: [0, 0],\n      preventOverlap: true,\n      preventOverlapPadding: 10,\n      condense: false,\n      rows: undefined,\n      cols: undefined,\n      position: undefined,\n      sortBy: 'degree',\n      nodeSize: 30\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  GridLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var n = nodes.length;\n    var center = self.center;\n\n    if (n === 0) {\n      return;\n    }\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var edges = self.edges;\n    var layoutNodes = [];\n    nodes.forEach(function (node) {\n      layoutNodes.push(node);\n    });\n    var nodeIdxMap = {};\n    layoutNodes.forEach(function (node, i) {\n      nodeIdxMap[node.id] = i;\n    });\n\n    if (self.sortBy === 'degree' || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = 'degree';\n\n      if (isNaN(nodes[0].degree)) {\n        var values_1 = getDegree(layoutNodes.length, nodeIdxMap, edges);\n        layoutNodes.forEach(function (node, i) {\n          node.degree = values_1[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort(function (n1, n2) {\n      return n2[self.sortBy] - n1[self.sortBy];\n    });\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    var oRows = self.rows;\n    var oCols = self.cols != null ? self.cols : self.columns;\n    self.cells = n; // if rows or columns were set in self, use those values\n\n    if (oRows != null && oCols != null) {\n      self.rows = oRows;\n      self.cols = oCols;\n    } else if (oRows != null && oCols == null) {\n      self.rows = oRows;\n      self.cols = Math.ceil(self.cells / self.rows);\n    } else if (oRows == null && oCols != null) {\n      self.cols = oCols;\n      self.rows = Math.ceil(self.cells / self.cols);\n    } else {\n      // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\n      // width/height * splits^2 = cells where splits is number of times to split width\n      self.splits = Math.sqrt(self.cells * self.height / self.width);\n      self.rows = Math.round(self.splits);\n      self.cols = Math.round(self.width / self.height * self.splits);\n    }\n\n    if (self.cols * self.rows > self.cells) {\n      // otherwise use the automatic values and adjust accordingly\n      // if rounding was up, see if we can reduce rows or columns\n      var sm = self.small();\n      var lg = self.large(); // reducing the small side takes away the most cells, so try it first\n\n      if ((sm - 1) * lg >= self.cells) {\n        self.small(sm - 1);\n      } else if ((lg - 1) * sm >= self.cells) {\n        self.large(lg - 1);\n      }\n    } else {\n      // if rounding was too low, add rows or columns\n      while (self.cols * self.rows < self.cells) {\n        var sm = self.small();\n        var lg = self.large(); // try to add to larger side first (adds less in multiplication)\n\n        if ((lg + 1) * sm >= self.cells) {\n          self.large(lg + 1);\n        } else {\n          self.small(sm + 1);\n        }\n      }\n    }\n\n    self.cellWidth = self.width / self.cols;\n    self.cellHeight = self.height / self.rows;\n\n    if (self.condense) {\n      self.cellWidth = 0;\n      self.cellHeight = 0;\n    }\n\n    if (self.preventOverlap) {\n      layoutNodes.forEach(function (node) {\n        if (!node.x || !node.y) {\n          // for bb\n          node.x = 0;\n          node.y = 0;\n        }\n\n        var nodew;\n        var nodeh;\n\n        if (isArray(node.size)) {\n          nodew = node.size[0];\n          nodeh = node.size[1];\n        } else if (isNumber(node.size)) {\n          nodew = node.size;\n          nodeh = node.size;\n        }\n\n        if (nodew === undefined || nodeh === undefined) {\n          if (isArray(self.nodeSize)) {\n            nodew = self.nodeSize[0];\n            nodeh = self.nodeSize[1];\n          } else if (isNumber(self.nodeSize)) {\n            nodew = self.nodeSize;\n            nodeh = self.nodeSize;\n          } else {\n            nodew = 30;\n            nodeh = 30;\n          }\n        }\n\n        var p = self.preventOverlapPadding;\n        var w = nodew + p;\n        var h = nodeh + p;\n        self.cellWidth = Math.max(self.cellWidth, w);\n        self.cellHeight = Math.max(self.cellHeight, h);\n      });\n    }\n\n    self.cellUsed = {}; // e.g. 'c-0-2' => true\n    // to keep track of current cell position\n\n    self.row = 0;\n    self.col = 0; // get a cache of all the manual positions\n\n    self.id2manPos = {};\n\n    for (var i = 0; i < layoutNodes.length; i++) {\n      var node = layoutNodes[i];\n      var rcPos = void 0;\n\n      if (self.position) {\n        rcPos = self.position(node);\n      }\n\n      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n        // must have at least row or col def'd\n        var pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if (pos.col === undefined) {\n          // find unused col\n          pos.col = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.col++;\n          }\n        } else if (pos.row === undefined) {\n          // find unused row\n          pos.row = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.row++;\n          }\n        }\n\n        self.id2manPos[node.id] = pos;\n        self.use(pos.row, pos.col);\n      }\n\n      self.getPos(node);\n    }\n  };\n\n  GridLayout.prototype.small = function (val) {\n    var self = this;\n    var res;\n    var rows = self.rows || 5;\n    var cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.min(rows, cols);\n    } else {\n      var min = Math.min(rows, cols);\n\n      if (min === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  };\n\n  GridLayout.prototype.large = function (val) {\n    var self = this;\n    var res;\n    var rows = self.rows || 5;\n    var cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.max(rows, cols);\n    } else {\n      var max = Math.max(rows, cols);\n\n      if (max === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  };\n\n  GridLayout.prototype.used = function (row, col) {\n    var self = this;\n    return self.cellUsed[\"c-\" + row + \"-\" + col] || false;\n  };\n\n  GridLayout.prototype.use = function (row, col) {\n    var self = this;\n    self.cellUsed[\"c-\" + row + \"-\" + col] = true;\n  };\n\n  GridLayout.prototype.moveToNextCell = function () {\n    var self = this;\n    var cols = self.cols || 5;\n    self.col++;\n\n    if (self.col >= cols) {\n      self.col = 0;\n      self.row++;\n    }\n  };\n\n  GridLayout.prototype.getPos = function (node) {\n    var self = this;\n    var begin = self.begin;\n    var cellWidth = self.cellWidth;\n    var cellHeight = self.cellHeight;\n    var x;\n    var y; // see if we have a manual position set\n\n    var rcPos = self.id2manPos[node.id];\n\n    if (rcPos) {\n      x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\n      y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\n    } else {\n      // otherwise set automatically\n      while (self.used(self.row, self.col)) {\n        self.moveToNextCell();\n      }\n\n      x = self.col * cellWidth + cellWidth / 2 + begin[0];\n      y = self.row * cellHeight + cellHeight / 2 + begin[1];\n      self.use(self.row, self.col);\n      self.moveToNextCell();\n    }\n\n    node.x = x;\n    node.y = y;\n  };\n\n  return GridLayout;\n}(BaseLayout);\n\nexport default GridLayout;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/grid.js"],"names":["__extends","isString","BaseLayout","isArray","isNumber","getDegree","isNaN","GridLayout","_super","_this","apply","arguments","begin","preventOverlap","preventOverlapPadding","condense","sortBy","nodeSize","nodes","edges","center","width","height","row","col","cellWidth","cellHeight","cellUsed","id2manPos","prototype","getDefaultCfg","rows","undefined","cols","position","execute","self","n","length","x","y","layoutNodes","forEach","node","push","nodeIdxMap","i","id","degree","values_1","sort","n1","n2","window","innerWidth","innerHeight","oRows","oCols","columns","cells","Math","ceil","splits","sqrt","round","sm","small","lg","large","nodew","nodeh","size","p","w","h","max","rcPos","pos","used","use","getPos","val","res","min","moveToNextCell"],"mappings":"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","sourcesContent":["/**\n * @fileOverview grid layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { __extends } from \"tslib\";\nimport isString from '@antv/util/lib/is-string';\nimport { BaseLayout } from './layout';\nimport { isArray, isNumber } from '@antv/util';\nimport { getDegree } from '../util/math';\nimport { isNaN } from '../util/base';\n/**\n * 网格布局\n */\n\nvar GridLayout =\n/** @class */\nfunction (_super) {\n  __extends(GridLayout, _super);\n\n  function GridLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局起始点 */\n\n\n    _this.begin = [0, 0];\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = true;\n    /** extra spacing around nodes when preventOverlap: true */\n\n    _this.preventOverlapPadding = 10;\n    /** uses all available space on false, uses minimal space on true */\n\n    _this.condense = false;\n    /** a sorting function to order the nodes; e.g. function(a, b){ return a.datapublic ('weight') - b.data('weight') } */\n\n    _this.sortBy = 'degree';\n    _this.nodeSize = 30;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    _this.width = 300;\n    _this.height = 300;\n    _this.row = 0;\n    _this.col = 0;\n    _this.cellWidth = 0;\n    _this.cellHeight = 0;\n    _this.cellUsed = {};\n    _this.id2manPos = {};\n    return _this;\n  }\n\n  GridLayout.prototype.getDefaultCfg = function () {\n    return {\n      begin: [0, 0],\n      preventOverlap: true,\n      preventOverlapPadding: 10,\n      condense: false,\n      rows: undefined,\n      cols: undefined,\n      position: undefined,\n      sortBy: 'degree',\n      nodeSize: 30\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  GridLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var n = nodes.length;\n    var center = self.center;\n\n    if (n === 0) {\n      return;\n    }\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var edges = self.edges;\n    var layoutNodes = [];\n    nodes.forEach(function (node) {\n      layoutNodes.push(node);\n    });\n    var nodeIdxMap = {};\n    layoutNodes.forEach(function (node, i) {\n      nodeIdxMap[node.id] = i;\n    });\n\n    if (self.sortBy === 'degree' || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = 'degree';\n\n      if (isNaN(nodes[0].degree)) {\n        var values_1 = getDegree(layoutNodes.length, nodeIdxMap, edges);\n        layoutNodes.forEach(function (node, i) {\n          node.degree = values_1[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort(function (n1, n2) {\n      return n2[self.sortBy] - n1[self.sortBy];\n    });\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    var oRows = self.rows;\n    var oCols = self.cols != null ? self.cols : self.columns;\n    self.cells = n; // if rows or columns were set in self, use those values\n\n    if (oRows != null && oCols != null) {\n      self.rows = oRows;\n      self.cols = oCols;\n    } else if (oRows != null && oCols == null) {\n      self.rows = oRows;\n      self.cols = Math.ceil(self.cells / self.rows);\n    } else if (oRows == null && oCols != null) {\n      self.cols = oCols;\n      self.rows = Math.ceil(self.cells / self.cols);\n    } else {\n      // otherwise use the automatic values and adjust accordingly\t      // otherwise use the automatic values and adjust accordingly\n      // width/height * splits^2 = cells where splits is number of times to split width\n      self.splits = Math.sqrt(self.cells * self.height / self.width);\n      self.rows = Math.round(self.splits);\n      self.cols = Math.round(self.width / self.height * self.splits);\n    }\n\n    if (self.cols * self.rows > self.cells) {\n      // otherwise use the automatic values and adjust accordingly\n      // if rounding was up, see if we can reduce rows or columns\n      var sm = self.small();\n      var lg = self.large(); // reducing the small side takes away the most cells, so try it first\n\n      if ((sm - 1) * lg >= self.cells) {\n        self.small(sm - 1);\n      } else if ((lg - 1) * sm >= self.cells) {\n        self.large(lg - 1);\n      }\n    } else {\n      // if rounding was too low, add rows or columns\n      while (self.cols * self.rows < self.cells) {\n        var sm = self.small();\n        var lg = self.large(); // try to add to larger side first (adds less in multiplication)\n\n        if ((lg + 1) * sm >= self.cells) {\n          self.large(lg + 1);\n        } else {\n          self.small(sm + 1);\n        }\n      }\n    }\n\n    self.cellWidth = self.width / self.cols;\n    self.cellHeight = self.height / self.rows;\n\n    if (self.condense) {\n      self.cellWidth = 0;\n      self.cellHeight = 0;\n    }\n\n    if (self.preventOverlap) {\n      layoutNodes.forEach(function (node) {\n        if (!node.x || !node.y) {\n          // for bb\n          node.x = 0;\n          node.y = 0;\n        }\n\n        var nodew;\n        var nodeh;\n\n        if (isArray(node.size)) {\n          nodew = node.size[0];\n          nodeh = node.size[1];\n        } else if (isNumber(node.size)) {\n          nodew = node.size;\n          nodeh = node.size;\n        }\n\n        if (nodew === undefined || nodeh === undefined) {\n          if (isArray(self.nodeSize)) {\n            nodew = self.nodeSize[0];\n            nodeh = self.nodeSize[1];\n          } else if (isNumber(self.nodeSize)) {\n            nodew = self.nodeSize;\n            nodeh = self.nodeSize;\n          } else {\n            nodew = 30;\n            nodeh = 30;\n          }\n        }\n\n        var p = self.preventOverlapPadding;\n        var w = nodew + p;\n        var h = nodeh + p;\n        self.cellWidth = Math.max(self.cellWidth, w);\n        self.cellHeight = Math.max(self.cellHeight, h);\n      });\n    }\n\n    self.cellUsed = {}; // e.g. 'c-0-2' => true\n    // to keep track of current cell position\n\n    self.row = 0;\n    self.col = 0; // get a cache of all the manual positions\n\n    self.id2manPos = {};\n\n    for (var i = 0; i < layoutNodes.length; i++) {\n      var node = layoutNodes[i];\n      var rcPos = void 0;\n\n      if (self.position) {\n        rcPos = self.position(node);\n      }\n\n      if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {\n        // must have at least row or col def'd\n        var pos = {\n          row: rcPos.row,\n          col: rcPos.col\n        };\n\n        if (pos.col === undefined) {\n          // find unused col\n          pos.col = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.col++;\n          }\n        } else if (pos.row === undefined) {\n          // find unused row\n          pos.row = 0;\n\n          while (self.used(pos.row, pos.col)) {\n            pos.row++;\n          }\n        }\n\n        self.id2manPos[node.id] = pos;\n        self.use(pos.row, pos.col);\n      }\n\n      self.getPos(node);\n    }\n  };\n\n  GridLayout.prototype.small = function (val) {\n    var self = this;\n    var res;\n    var rows = self.rows || 5;\n    var cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.min(rows, cols);\n    } else {\n      var min = Math.min(rows, cols);\n\n      if (min === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  };\n\n  GridLayout.prototype.large = function (val) {\n    var self = this;\n    var res;\n    var rows = self.rows || 5;\n    var cols = self.cols || 5;\n\n    if (val == null) {\n      res = Math.max(rows, cols);\n    } else {\n      var max = Math.max(rows, cols);\n\n      if (max === self.rows) {\n        self.rows = val;\n      } else {\n        self.cols = val;\n      }\n    }\n\n    return res;\n  };\n\n  GridLayout.prototype.used = function (row, col) {\n    var self = this;\n    return self.cellUsed[\"c-\" + row + \"-\" + col] || false;\n  };\n\n  GridLayout.prototype.use = function (row, col) {\n    var self = this;\n    self.cellUsed[\"c-\" + row + \"-\" + col] = true;\n  };\n\n  GridLayout.prototype.moveToNextCell = function () {\n    var self = this;\n    var cols = self.cols || 5;\n    self.col++;\n\n    if (self.col >= cols) {\n      self.col = 0;\n      self.row++;\n    }\n  };\n\n  GridLayout.prototype.getPos = function (node) {\n    var self = this;\n    var begin = self.begin;\n    var cellWidth = self.cellWidth;\n    var cellHeight = self.cellHeight;\n    var x;\n    var y; // see if we have a manual position set\n\n    var rcPos = self.id2manPos[node.id];\n\n    if (rcPos) {\n      x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];\n      y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];\n    } else {\n      // otherwise set automatically\n      while (self.used(self.row, self.col)) {\n        self.moveToNextCell();\n      }\n\n      x = self.col * cellWidth + cellWidth / 2 + begin[0];\n      y = self.row * cellHeight + cellHeight / 2 + begin[1];\n      self.use(self.row, self.col);\n      self.moveToNextCell();\n    }\n\n    node.x = x;\n    node.y = y;\n  };\n\n  return GridLayout;\n}(BaseLayout);\n\nexport default GridLayout;"]},"metadata":{},"sourceType":"module"}