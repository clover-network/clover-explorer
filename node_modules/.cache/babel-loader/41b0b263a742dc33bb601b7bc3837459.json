{"ast":null,"code":"/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nexport function detectConnectedComponents(nodes) {\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.get('id')] = true;\n    var neighbors = node.getNeighbors();\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor.get('id')]) {\n        getComponent(neighbor);\n      }\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.get('id')]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n}\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\n\nexport function detectStrongConnectComponents(nodes) {\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.get('id')] = index;\n    lowLink[node.get('id')] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.get('id')] = true; // 考虑每个邻接点\n\n    var neighbors = node.getNeighbors('target').filter(function (n) {\n      return nodes.indexOf(n) > -1;\n    });\n\n    for (var i = 0; i < neighbors.length; i++) {\n      var targetNode = neighbors[i];\n\n      if (!indices[targetNode.get('id')] && indices[targetNode.get('id')] !== 0) {\n        getComponent(targetNode); // tree edge\n\n        lowLink[node.get('id')] = Math.min(lowLink[node.get('id')], lowLink[targetNode.get('id')]);\n      } else if (inStack[targetNode.get('id')]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.get('id')] = Math.min(lowLink[node.get('id')], indices[targetNode.get('id')]);\n      }\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.get('id')] === indices[node.get('id')]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.get('id')] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.get('id')] && indices[node.get('id')] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n}\nexport default function getConnectedComponents(graph, directed) {\n  var isDirected = directed === undefined ? graph.get('directed') : directed;\n  var nodes = graph.getNodes();\n  if (isDirected) return detectStrongConnectComponents(nodes);\n  return detectConnectedComponents(nodes);\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/algorithm/connected-component.js"],"names":["detectConnectedComponents","nodes","allComponents","visited","nodeStack","getComponent","node","push","get","neighbors","getNeighbors","i","length","neighbor","component","pop","detectStrongConnectComponents","inStack","indices","lowLink","index","filter","n","indexOf","targetNode","Math","min","tmpNode","_i","nodes_1","getConnectedComponents","graph","directed","isDirected","undefined","getNodes"],"mappings":"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","sourcesContent":["/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nexport function detectConnectedComponents(nodes) {\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.get('id')] = true;\n    var neighbors = node.getNeighbors();\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor.get('id')]) {\n        getComponent(neighbor);\n      }\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.get('id')]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n}\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\n\nexport function detectStrongConnectComponents(nodes) {\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.get('id')] = index;\n    lowLink[node.get('id')] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.get('id')] = true; // 考虑每个邻接点\n\n    var neighbors = node.getNeighbors('target').filter(function (n) {\n      return nodes.indexOf(n) > -1;\n    });\n\n    for (var i = 0; i < neighbors.length; i++) {\n      var targetNode = neighbors[i];\n\n      if (!indices[targetNode.get('id')] && indices[targetNode.get('id')] !== 0) {\n        getComponent(targetNode); // tree edge\n\n        lowLink[node.get('id')] = Math.min(lowLink[node.get('id')], lowLink[targetNode.get('id')]);\n      } else if (inStack[targetNode.get('id')]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.get('id')] = Math.min(lowLink[node.get('id')], indices[targetNode.get('id')]);\n      }\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.get('id')] === indices[node.get('id')]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.get('id')] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.get('id')] && indices[node.get('id')] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n}\nexport default function getConnectedComponents(graph, directed) {\n  var isDirected = directed === undefined ? graph.get('directed') : directed;\n  var nodes = graph.getNodes();\n  if (isDirected) return detectStrongConnectComponents(nodes);\n  return detectConnectedComponents(nodes);\n}"]},"metadata":{},"sourceType":"module"}