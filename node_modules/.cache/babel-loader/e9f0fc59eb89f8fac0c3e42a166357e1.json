{"ast":null,"code":"import dfs from './dfs';\nimport getConnectedComponents, { detectStrongConnectComponents } from './connected-component';\n\nvar detectDirectedCycle = function detectDirectedCycle(graph) {\n  var cycle = null;\n  var dfsParentMap = {}; // 所有没有被访问的节点集合\n\n  var unvisitedSet = {}; // 正在被访问的节点集合\n\n  var visitingSet = {}; // 所有已经被访问过的节点集合\n\n  var visitedSet = {}; // 初始化 unvisitedSet\n\n  graph.getNodes().forEach(function (node) {\n    unvisitedSet[node.getID()] = node;\n  });\n  var callbacks = {\n    enter: function enter(_a) {\n      var currentNode = _a.current,\n          previousNode = _a.previous;\n\n      if (visitingSet[currentNode.getID()]) {\n        // 如果当前节点正在访问中，则说明检测到环路了\n        cycle = {};\n        var currentCycleNode = currentNode;\n        var previousCycleNode = previousNode;\n\n        while (previousCycleNode.getID() !== currentNode.getID()) {\n          cycle[currentCycleNode.getID()] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode.getID()];\n        }\n\n        cycle[currentCycleNode.getID()] = previousCycleNode;\n      } else {\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\n        visitingSet[currentNode.getID()] = currentNode;\n        delete unvisitedSet[currentNode.getID()]; // 更新 DSF parents 列表\n\n        dfsParentMap[currentNode.getID()] = previousNode;\n      }\n    },\n    leave: function leave(_a) {\n      var currentNode = _a.current; // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\n\n      visitedSet[currentNode.getID()] = currentNode;\n      delete visitingSet[currentNode.getID()];\n    },\n    allowTraversal: function allowTraversal(_a) {\n      var nextNode = _a.next; // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\n\n      if (cycle) {\n        return false;\n      } // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\n\n\n      return !visitedSet[nextNode.getID()];\n    }\n  }; // 开始遍历节点\n\n  while (Object.keys(unvisitedSet).length) {\n    // 从第一个节点开始进行 DFS 遍历\n    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n    dfs(graph, firsetUnVisitedKey, callbacks);\n  }\n\n  return cycle;\n};\n/**\n * 检测无向图中的所有Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回一组base cycles\n */\n\n\nexport var detectAllUndirectedCycle = function detectAllUndirectedCycle(graph, nodeIds, include) {\n  var _a, _b, _c;\n\n  if (include === void 0) {\n    include = true;\n  }\n\n  var allCycles = [];\n  var components = getConnectedComponents(graph, false); // loop through all connected components\n\n  for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\n    var component = components_1[_i];\n    if (!component.length) continue;\n    var root = component[0];\n    var rootId = root.get('id');\n    var stack = [root];\n    var parent_1 = (_a = {}, _a[rootId] = root, _a);\n    var used = (_b = {}, _b[rootId] = new Set(), _b); // walk a spanning tree to find cycles\n\n    while (stack.length > 0) {\n      var curNode = stack.pop();\n      var curNodeId = curNode.get('id');\n      var neighbors = curNode.getNeighbors();\n\n      for (var i = 0; i < neighbors.length; i += 1) {\n        var neighbor = neighbors[i];\n        var neighborId = neighbor.get('id');\n\n        if (neighborId === curNodeId) {\n          // 自环\n          allCycles.push((_c = {}, _c[neighbor.getID()] = curNode, _c));\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent_1[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          var cycleValid = true;\n          var cyclePath = [neighbor, curNode];\n          var p = parent_1[curNodeId];\n\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent_1[p.getID()]) break;else p = parent_1[p.getID()];\n          }\n\n          cyclePath.push(p);\n\n          if (nodeIds && include) {\n            // 如果有指定包含的节点\n            cycleValid = false;\n\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.get('id')) > -1;\n            }) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // 如果有指定不包含的节点\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.get('id')) > -1;\n            }) > -1) {\n              cycleValid = false;\n            }\n          } // 把 node list 形式转换为 cycle 的格式\n\n\n          if (cycleValid) {\n            var cycle = {};\n\n            for (var index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].getID()] = cyclePath[index];\n            }\n\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].getID()] = cyclePath[0];\n            }\n\n            allCycles.push(cycle);\n          }\n\n          used[neighborId].add(curNode);\n        }\n      }\n    }\n  }\n\n  return allCycles;\n};\n/**\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回所有的“simple cycles”\n */\n\nexport var detectAllDirectedCycle = function detectAllDirectedCycle(graph, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n\n  var path = []; // stack of nodes in current path\n\n  var blocked = new Set();\n  var B = []; // remember portions of the graph that yield no elementary circuit\n\n  var allCycles = [];\n  var idx2Node = {};\n  var node2Idx = {}; // 辅助函数： unblock all blocked nodes\n\n  var unblock = function unblock(thisNode) {\n    var stack = [thisNode];\n\n    while (stack.length > 0) {\n      var node = stack.pop();\n\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.get('id')].forEach(function (n) {\n          stack.push(n);\n        });\n        B[node.get('id')].clear();\n      }\n    }\n  };\n\n  var circuit = function circuit(node, start, adjList) {\n    var closed = false; // whether a path is closed\n\n    if (nodeIds && include === false && nodeIds.indexOf(node.get('id')) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n    var neighbors = adjList[node.getID()];\n\n    for (var i = 0; i < neighbors.length; i += 1) {\n      var neighbor = idx2Node[neighbors[i]];\n\n      if (neighbor === start) {\n        var cycle = {};\n\n        for (var index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].getID()] = path[index];\n        }\n\n        if (path.length) {\n          cycle[path[path.length - 1].getID()] = path[0];\n        }\n\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n\n    if (closed) {\n      unblock(node);\n    } else {\n      for (var i = 0; i < neighbors.length; i += 1) {\n        var neighbor = idx2Node[neighbors[i]];\n\n        if (!B[neighbor.get('id')].has(node)) {\n          B[neighbor.get('id')].add(node);\n        }\n      }\n    }\n\n    path.pop();\n    return closed;\n  };\n\n  var nodes = graph.getNodes(); // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\n\n  for (var i = 0; i < nodes.length; i += 1) {\n    var node = nodes[i];\n    var nodeId = node.getID();\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  } // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\n\n\n  if (nodeIds && include) {\n    for (var i = 0; i < nodeIds.length; i++) {\n      var nodeId = nodeIds[i];\n      node2Idx[nodes[i].getID()] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = graph.findById(nodeId);\n      idx2Node[node2Idx[nodes[i].getID()]] = nodes[i];\n    }\n  } // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\n\n\n  var getMinComponentAdj = function getMinComponentAdj(components) {\n    var _a;\n\n    var minCompIdx;\n    var minIdx = Infinity; // Find least component and the lowest node\n\n    for (var i = 0; i < components.length; i += 1) {\n      var comp = components[i];\n\n      for (var j = 0; j < comp.length; j++) {\n        var nodeIdx_1 = node2Idx[comp[j].getID()];\n\n        if (nodeIdx_1 < minIdx) {\n          minIdx = nodeIdx_1;\n          minCompIdx = i;\n        }\n      }\n    }\n\n    var component = components[minCompIdx];\n    var adjList = [];\n\n    for (var i = 0; i < component.length; i += 1) {\n      var node = component[i];\n      adjList[node.getID()] = [];\n\n      for (var _i = 0, _b = node.getNeighbors('target').filter(function (n) {\n        return component.indexOf(n) > -1;\n      }); _i < _b.length; _i++) {\n        var neighbor = _b[_i]; // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\n\n        if (neighbor === node && !(include === false && nodeIds.indexOf(node.getId()) > -1)) {\n          allCycles.push((_a = {}, _a[node.getID()] = node, _a));\n        } else {\n          adjList[node.getID()].push(node2Idx[neighbor.getID()]);\n        }\n      }\n    }\n\n    return {\n      component: component,\n      adjList: adjList,\n      minIdx: minIdx\n    };\n  };\n\n  var nodeIdx = 0;\n\n  while (nodeIdx < nodes.length) {\n    var subgraphNodes = nodes.filter(function (n) {\n      return node2Idx[n.getID()] >= nodeIdx;\n    });\n    var sccs = detectStrongConnectComponents(subgraphNodes).filter(function (component) {\n      return component.length > 1;\n    });\n    if (sccs.length === 0) break;\n    var scc = getMinComponentAdj(sccs);\n    var minIdx = scc.minIdx,\n        adjList = scc.adjList,\n        component = scc.component;\n\n    if (component.length > 1) {\n      component.forEach(function (node) {\n        B[node.get('id')] = new Set();\n      });\n      var startNode = idx2Node[minIdx]; // startNode 不在指定要包含的节点中，提前结束搜索\n\n      if (nodeIds && include && nodeIds.indexOf(startNode.get('id')) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n\n  return allCycles;\n};\n/**\n * 查找图中所有满足要求的圈\n * @param graph\n * @param directed 是否为有向图\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\n */\n\nexport var detectAllCycles = function detectAllCycles(graph, directed, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n\n  if (directed === undefined) {\n    directed = graph.get('directed');\n  }\n\n  if (directed) return detectAllDirectedCycle(graph, nodeIds, include);\n  return detectAllUndirectedCycle(graph, nodeIds, include);\n};\nexport default detectDirectedCycle;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/algorithm/detect-cycle.js"],"names":["dfs","getConnectedComponents","detectStrongConnectComponents","detectDirectedCycle","graph","cycle","dfsParentMap","unvisitedSet","visitingSet","visitedSet","getNodes","forEach","node","getID","callbacks","enter","_a","currentNode","current","previousNode","previous","currentCycleNode","previousCycleNode","leave","allowTraversal","nextNode","next","Object","keys","length","firsetUnVisitedKey","detectAllUndirectedCycle","nodeIds","include","_b","_c","allCycles","components","_i","components_1","component","root","rootId","get","stack","parent_1","used","Set","curNode","pop","curNodeId","neighbors","getNeighbors","i","neighbor","neighborId","push","has","cycleValid","cyclePath","p","size","findIndex","indexOf","index","add","detectAllDirectedCycle","path","blocked","B","idx2Node","node2Idx","unblock","thisNode","delete","n","clear","circuit","start","adjList","closed","nodes","nodeId","findById","getMinComponentAdj","minCompIdx","minIdx","Infinity","comp","j","nodeIdx_1","filter","getId","nodeIdx","subgraphNodes","sccs","scc","startNode","detectAllCycles","directed","undefined"],"mappings":"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","sourcesContent":["import dfs from './dfs';\nimport getConnectedComponents, { detectStrongConnectComponents } from './connected-component';\n\nvar detectDirectedCycle = function detectDirectedCycle(graph) {\n  var cycle = null;\n  var dfsParentMap = {}; // 所有没有被访问的节点集合\n\n  var unvisitedSet = {}; // 正在被访问的节点集合\n\n  var visitingSet = {}; // 所有已经被访问过的节点集合\n\n  var visitedSet = {}; // 初始化 unvisitedSet\n\n  graph.getNodes().forEach(function (node) {\n    unvisitedSet[node.getID()] = node;\n  });\n  var callbacks = {\n    enter: function enter(_a) {\n      var currentNode = _a.current,\n          previousNode = _a.previous;\n\n      if (visitingSet[currentNode.getID()]) {\n        // 如果当前节点正在访问中，则说明检测到环路了\n        cycle = {};\n        var currentCycleNode = currentNode;\n        var previousCycleNode = previousNode;\n\n        while (previousCycleNode.getID() !== currentNode.getID()) {\n          cycle[currentCycleNode.getID()] = previousCycleNode;\n          currentCycleNode = previousCycleNode;\n          previousCycleNode = dfsParentMap[previousCycleNode.getID()];\n        }\n\n        cycle[currentCycleNode.getID()] = previousCycleNode;\n      } else {\n        // 如果不存在正在访问集合中，则将其放入正在访问集合，并从未访问集合中删除\n        visitingSet[currentNode.getID()] = currentNode;\n        delete unvisitedSet[currentNode.getID()]; // 更新 DSF parents 列表\n\n        dfsParentMap[currentNode.getID()] = previousNode;\n      }\n    },\n    leave: function leave(_a) {\n      var currentNode = _a.current; // 如果所有的节点的子节点都已经访问过了，则从正在访问集合中删除掉，并将其移入到已访问集合中，\n      // 同时也意味着当前节点的所有邻居节点都被访问过了\n\n      visitedSet[currentNode.getID()] = currentNode;\n      delete visitingSet[currentNode.getID()];\n    },\n    allowTraversal: function allowTraversal(_a) {\n      var nextNode = _a.next; // 如果检测到环路则需要终止所有进一步的遍历，否则会导致无限循环遍历\n\n      if (cycle) {\n        return false;\n      } // 仅允许遍历没有访问的节点，visitedSet 中的都已经访问过了\n\n\n      return !visitedSet[nextNode.getID()];\n    }\n  }; // 开始遍历节点\n\n  while (Object.keys(unvisitedSet).length) {\n    // 从第一个节点开始进行 DFS 遍历\n    var firsetUnVisitedKey = Object.keys(unvisitedSet)[0];\n    dfs(graph, firsetUnVisitedKey, callbacks);\n  }\n\n  return cycle;\n};\n/**\n * 检测无向图中的所有Base cycles\n * refer: https://www.codeproject.com/Articles/1158232/Enumerating-All-Cycles-in-an-Undirected-Graph\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回一组base cycles\n */\n\n\nexport var detectAllUndirectedCycle = function detectAllUndirectedCycle(graph, nodeIds, include) {\n  var _a, _b, _c;\n\n  if (include === void 0) {\n    include = true;\n  }\n\n  var allCycles = [];\n  var components = getConnectedComponents(graph, false); // loop through all connected components\n\n  for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {\n    var component = components_1[_i];\n    if (!component.length) continue;\n    var root = component[0];\n    var rootId = root.get('id');\n    var stack = [root];\n    var parent_1 = (_a = {}, _a[rootId] = root, _a);\n    var used = (_b = {}, _b[rootId] = new Set(), _b); // walk a spanning tree to find cycles\n\n    while (stack.length > 0) {\n      var curNode = stack.pop();\n      var curNodeId = curNode.get('id');\n      var neighbors = curNode.getNeighbors();\n\n      for (var i = 0; i < neighbors.length; i += 1) {\n        var neighbor = neighbors[i];\n        var neighborId = neighbor.get('id');\n\n        if (neighborId === curNodeId) {\n          // 自环\n          allCycles.push((_c = {}, _c[neighbor.getID()] = curNode, _c));\n        } else if (!(neighborId in used)) {\n          // visit a new node\n          parent_1[neighborId] = curNode;\n          stack.push(neighbor);\n          used[neighborId] = new Set([curNode]);\n        } else if (!used[curNodeId].has(neighbor)) {\n          // a cycle found\n          var cycleValid = true;\n          var cyclePath = [neighbor, curNode];\n          var p = parent_1[curNodeId];\n\n          while (used[neighborId].size && !used[neighborId].has(p)) {\n            cyclePath.push(p);\n            if (p === parent_1[p.getID()]) break;else p = parent_1[p.getID()];\n          }\n\n          cyclePath.push(p);\n\n          if (nodeIds && include) {\n            // 如果有指定包含的节点\n            cycleValid = false;\n\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.get('id')) > -1;\n            }) > -1) {\n              cycleValid = true;\n            }\n          } else if (nodeIds && !include) {\n            // 如果有指定不包含的节点\n            if (cyclePath.findIndex(function (node) {\n              return nodeIds.indexOf(node.get('id')) > -1;\n            }) > -1) {\n              cycleValid = false;\n            }\n          } // 把 node list 形式转换为 cycle 的格式\n\n\n          if (cycleValid) {\n            var cycle = {};\n\n            for (var index = 1; index < cyclePath.length; index += 1) {\n              cycle[cyclePath[index - 1].getID()] = cyclePath[index];\n            }\n\n            if (cyclePath.length) {\n              cycle[cyclePath[cyclePath.length - 1].getID()] = cyclePath[0];\n            }\n\n            allCycles.push(cycle);\n          }\n\n          used[neighborId].add(curNode);\n        }\n      }\n    }\n  }\n\n  return allCycles;\n};\n/**\n * Johnson's algorithm, 时间复杂度 O((V + E)(C + 1))$ and space bounded by O(V + E)\n * refer: https://www.cs.tufts.edu/comp/150GA/homeworks/hw1/Johnson%2075.PDF\n * refer: https://networkx.github.io/documentation/stable/_modules/networkx/algorithms/cycles.html#simple_cycles\n * @param graph\n * @param nodeIds 节点 ID 的数组\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: INode}] 返回所有的“simple cycles”\n */\n\nexport var detectAllDirectedCycle = function detectAllDirectedCycle(graph, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n\n  var path = []; // stack of nodes in current path\n\n  var blocked = new Set();\n  var B = []; // remember portions of the graph that yield no elementary circuit\n\n  var allCycles = [];\n  var idx2Node = {};\n  var node2Idx = {}; // 辅助函数： unblock all blocked nodes\n\n  var unblock = function unblock(thisNode) {\n    var stack = [thisNode];\n\n    while (stack.length > 0) {\n      var node = stack.pop();\n\n      if (blocked.has(node)) {\n        blocked.delete(node);\n        B[node.get('id')].forEach(function (n) {\n          stack.push(n);\n        });\n        B[node.get('id')].clear();\n      }\n    }\n  };\n\n  var circuit = function circuit(node, start, adjList) {\n    var closed = false; // whether a path is closed\n\n    if (nodeIds && include === false && nodeIds.indexOf(node.get('id')) > -1) return closed;\n    path.push(node);\n    blocked.add(node);\n    var neighbors = adjList[node.getID()];\n\n    for (var i = 0; i < neighbors.length; i += 1) {\n      var neighbor = idx2Node[neighbors[i]];\n\n      if (neighbor === start) {\n        var cycle = {};\n\n        for (var index = 1; index < path.length; index += 1) {\n          cycle[path[index - 1].getID()] = path[index];\n        }\n\n        if (path.length) {\n          cycle[path[path.length - 1].getID()] = path[0];\n        }\n\n        allCycles.push(cycle);\n        closed = true;\n      } else if (!blocked.has(neighbor)) {\n        if (circuit(neighbor, start, adjList)) {\n          closed = true;\n        }\n      }\n    }\n\n    if (closed) {\n      unblock(node);\n    } else {\n      for (var i = 0; i < neighbors.length; i += 1) {\n        var neighbor = idx2Node[neighbors[i]];\n\n        if (!B[neighbor.get('id')].has(node)) {\n          B[neighbor.get('id')].add(node);\n        }\n      }\n    }\n\n    path.pop();\n    return closed;\n  };\n\n  var nodes = graph.getNodes(); // Johnson's algorithm 要求给节点赋顺序，先按节点在数组中的顺序\n\n  for (var i = 0; i < nodes.length; i += 1) {\n    var node = nodes[i];\n    var nodeId = node.getID();\n    node2Idx[nodeId] = i;\n    idx2Node[i] = node;\n  } // 如果有指定包含的节点，则把指定节点排序在前，以便提早结束搜索\n\n\n  if (nodeIds && include) {\n    for (var i = 0; i < nodeIds.length; i++) {\n      var nodeId = nodeIds[i];\n      node2Idx[nodes[i].getID()] = node2Idx[nodeId];\n      node2Idx[nodeId] = 0;\n      idx2Node[0] = graph.findById(nodeId);\n      idx2Node[node2Idx[nodes[i].getID()]] = nodes[i];\n    }\n  } // 返回 节点顺序 >= nodeOrder 的强连通分量的adjList\n\n\n  var getMinComponentAdj = function getMinComponentAdj(components) {\n    var _a;\n\n    var minCompIdx;\n    var minIdx = Infinity; // Find least component and the lowest node\n\n    for (var i = 0; i < components.length; i += 1) {\n      var comp = components[i];\n\n      for (var j = 0; j < comp.length; j++) {\n        var nodeIdx_1 = node2Idx[comp[j].getID()];\n\n        if (nodeIdx_1 < minIdx) {\n          minIdx = nodeIdx_1;\n          minCompIdx = i;\n        }\n      }\n    }\n\n    var component = components[minCompIdx];\n    var adjList = [];\n\n    for (var i = 0; i < component.length; i += 1) {\n      var node = component[i];\n      adjList[node.getID()] = [];\n\n      for (var _i = 0, _b = node.getNeighbors('target').filter(function (n) {\n        return component.indexOf(n) > -1;\n      }); _i < _b.length; _i++) {\n        var neighbor = _b[_i]; // 对自环情况 (点连向自身) 特殊处理：记录自环，但不加入adjList\n\n        if (neighbor === node && !(include === false && nodeIds.indexOf(node.getId()) > -1)) {\n          allCycles.push((_a = {}, _a[node.getID()] = node, _a));\n        } else {\n          adjList[node.getID()].push(node2Idx[neighbor.getID()]);\n        }\n      }\n    }\n\n    return {\n      component: component,\n      adjList: adjList,\n      minIdx: minIdx\n    };\n  };\n\n  var nodeIdx = 0;\n\n  while (nodeIdx < nodes.length) {\n    var subgraphNodes = nodes.filter(function (n) {\n      return node2Idx[n.getID()] >= nodeIdx;\n    });\n    var sccs = detectStrongConnectComponents(subgraphNodes).filter(function (component) {\n      return component.length > 1;\n    });\n    if (sccs.length === 0) break;\n    var scc = getMinComponentAdj(sccs);\n    var minIdx = scc.minIdx,\n        adjList = scc.adjList,\n        component = scc.component;\n\n    if (component.length > 1) {\n      component.forEach(function (node) {\n        B[node.get('id')] = new Set();\n      });\n      var startNode = idx2Node[minIdx]; // startNode 不在指定要包含的节点中，提前结束搜索\n\n      if (nodeIds && include && nodeIds.indexOf(startNode.get('id')) === -1) return allCycles;\n      circuit(startNode, startNode, adjList);\n      nodeIdx = minIdx + 1;\n    } else {\n      break;\n    }\n  }\n\n  return allCycles;\n};\n/**\n * 查找图中所有满足要求的圈\n * @param graph\n * @param directed 是否为有向图\n * @param nodeIds 节点 ID 的数组，若不指定，则返回图中所有的圈\n * @param include 包含或排除指定的节点\n * @return [{[key: string]: Node}] 包含所有环的数组，每个环用一个Object表示，其中key为节点id，value为该节点在环中指向的下一个节点\n */\n\nexport var detectAllCycles = function detectAllCycles(graph, directed, nodeIds, include) {\n  if (include === void 0) {\n    include = true;\n  }\n\n  if (directed === undefined) {\n    directed = graph.get('directed');\n  }\n\n  if (directed) return detectAllDirectedCycle(graph, nodeIds, include);\n  return detectAllUndirectedCycle(graph, nodeIds, include);\n};\nexport default detectDirectedCycle;"]},"metadata":{},"sourceType":"module"}