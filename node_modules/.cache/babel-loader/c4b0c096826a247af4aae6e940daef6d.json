{"ast":null,"code":"import { determination } from \"./utils/determination\";\nimport { ols } from \"./utils/ols\";\nimport { visitPoints } from \"./utils/points\";\nexport default function () {\n  let x = d => d[0],\n      y = d => d[1],\n      domain;\n\n  function linear(data) {\n    let n = 0,\n        X = 0,\n        // sum of x\n    Y = 0,\n        // sum of y\n    XY = 0,\n        // sum of x * y\n    X2 = 0,\n        // sum of x * x\n    xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n    visitPoints(data, x, y, (dx, dy) => {\n      ++n;\n      X += (dx - X) / n;\n      Y += (dy - Y) / n;\n      XY += (dx * dy - XY) / n;\n      X2 += (dx * dx - X2) / n;\n\n      if (!domain) {\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n\n    const [intercept, slope] = ols(X, Y, XY, X2),\n          fn = x => slope * x + intercept,\n          out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];\n\n    out.a = slope;\n    out.b = intercept;\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, Y, fn);\n    return out;\n  }\n\n  linear.domain = function (arr) {\n    return arguments.length ? (domain = arr, linear) : domain;\n  };\n\n  linear.x = function (fn) {\n    return arguments.length ? (x = fn, linear) : x;\n  };\n\n  linear.y = function (fn) {\n    return arguments.length ? (y = fn, linear) : y;\n  };\n\n  return linear;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/d3-regression/src/linear.js"],"names":["determination","ols","visitPoints","x","d","y","domain","linear","data","n","X","Y","XY","X2","xmin","Infinity","xmax","dx","dy","intercept","slope","fn","out","a","b","predict","rSquared","arr","arguments","length"],"mappings":"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","sourcesContent":["import { determination } from \"./utils/determination\";\nimport { ols } from \"./utils/ols\";\nimport { visitPoints } from \"./utils/points\";\n\nexport default function(){\n  let x = d => d[0],\n      y = d => d[1],\n      domain;\n\n  function linear(data){\n    let n = 0,\n        X = 0, // sum of x\n        Y = 0, // sum of y\n        XY = 0, // sum of x * y\n        X2 = 0, // sum of x * x\n        xmin = domain ? +domain[0] : Infinity,\n        xmax = domain ? +domain[1] : -Infinity;\n\n    visitPoints(data, x, y, (dx, dy) => {\n      ++n;\n      X += (dx - X) / n;\n      Y += (dy - Y) / n;\n      XY += (dx * dy - XY) / n;\n      X2 += (dx * dx - X2) / n;\n      \n      if (!domain){\n        if (dx < xmin) xmin = dx;\n        if (dx > xmax) xmax = dx;\n      }\n    });\n\n    const [intercept, slope] = ols(X, Y, XY, X2),\n        fn = x => slope * x + intercept,\n        out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];\n    \n    out.a = slope;\n    out.b = intercept;\n    out.predict = fn;\n    out.rSquared = determination(data, x, y, Y, fn);\n\n    return out;\n  }\n\n  linear.domain = function(arr){\n    return arguments.length ? (domain = arr, linear) : domain;\n  }\n\n  linear.x = function(fn){\n    return arguments.length ? (x = fn, linear) : x;\n  }\n\n  linear.y = function(fn){\n    return arguments.length ? (y = fn, linear) : y;\n  }\n\n  return linear;\n}\n"]},"metadata":{},"sourceType":"module"}