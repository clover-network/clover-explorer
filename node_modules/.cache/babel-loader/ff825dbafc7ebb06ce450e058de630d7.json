{"ast":null,"code":"/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { __extends } from \"tslib\";\nimport isArray from '@antv/util/lib/is-array';\nimport isString from '@antv/util/lib/is-string';\nimport { BaseLayout } from './layout';\nimport { getDegree } from '../util/math';\nimport { isNumber } from '@antv/util';\n/**\n * 同心圆布局\n */\n\nvar ConcentricLayout =\n/** @class */\nfunction (_super) {\n  __extends(ConcentricLayout, _super);\n\n  function ConcentricLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    _this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.minNodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n\n    _this.equidistant = false;\n    /** where nodes start in radians */\n\n    _this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n\n    _this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n\n    _this.sortBy = 'degree';\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    return _this;\n  }\n\n  ConcentricLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      nodeSize: 30,\n      minNodeSpacing: 10,\n      preventOverlap: false,\n      sweep: undefined,\n      equidistant: false,\n      startAngle: 3 / 2 * Math.PI,\n      clockwise: true,\n      maxLevelDiff: undefined,\n      sortBy: 'degree'\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ConcentricLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var edges = self.edges;\n    var n = nodes.length;\n    var center = self.center;\n\n    if (n === 0) {\n      return;\n    }\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var layoutNodes = [];\n    var maxNodeSize;\n\n    if (isArray(self.nodeSize)) {\n      maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n    } else {\n      maxNodeSize = self.nodeSize;\n    }\n\n    nodes.forEach(function (node) {\n      layoutNodes.push(node);\n      var nodeSize = maxNodeSize;\n\n      if (isArray(node.size)) {\n        nodeSize = Math.max(node.size[0], node.size[1]);\n      } else if (isNumber(node.size)) {\n        nodeSize = node.size;\n      }\n\n      maxNodeSize = Math.max(maxNodeSize, nodeSize);\n    });\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise; // layout\n\n    var nodeMap = {};\n    var nodeIdxMap = {};\n    layoutNodes.forEach(function (node, i) {\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    }); // get the node degrees\n\n    if (self.sortBy === 'degree' || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = 'degree';\n\n      if (!isNumber(nodes[0].degree)) {\n        var values_1 = getDegree(nodes.length, nodeIdxMap, edges);\n        layoutNodes.forEach(function (node, i) {\n          node.degree = values_1[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort(function (n1, n2) {\n      return n2[self.sortBy] - n1[self.sortBy];\n    });\n    self.maxValueNode = layoutNodes[0];\n    self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4; // put the values into levels\n\n    var levels = [[]];\n    var currentLevel = levels[0];\n    layoutNodes.forEach(function (node) {\n      if (currentLevel.length > 0) {\n        var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n\n        if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n\n      currentLevel.push(node);\n    }); // create positions for levels\n\n    var minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n\n    if (!self.preventOverlap) {\n      // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = Math.min(self.width, self.height) / 2 - minDist;\n      var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n      minDist = Math.min(minDist, rStep);\n    } // find the metrics for each level\n\n\n    var r = 0;\n    levels.forEach(function (level) {\n      var sweep = self.sweep;\n\n      if (sweep === undefined) {\n        sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n      }\n\n      var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n      if (level.length > 1 && self.preventOverlap) {\n        // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n\n      level.r = r;\n      r += minDist;\n    });\n\n    if (self.equidistant) {\n      var rDeltaMax_1 = 0;\n      var rr_1 = 0;\n\n      for (var i = 0; i < levels.length; i++) {\n        var level = levels[i];\n        var rDelta = level.r - rr_1;\n        rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);\n      }\n\n      rr_1 = 0;\n      levels.forEach(function (level, i) {\n        if (i === 0) {\n          rr_1 = level.r;\n        }\n\n        level.r = rr_1;\n        rr_1 += rDeltaMax_1;\n      });\n    } // calculate the node positions\n\n\n    levels.forEach(function (level) {\n      var dTheta = level.dTheta;\n      var rr = level.r;\n      level.forEach(function (node, j) {\n        var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n        node.x = center[0] + rr * Math.cos(theta);\n        node.y = center[1] + rr * Math.sin(theta);\n      });\n    });\n  };\n\n  return ConcentricLayout;\n}(BaseLayout);\n\nexport default ConcentricLayout;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/concentric.js"],"names":["__extends","isArray","isString","BaseLayout","getDegree","isNumber","ConcentricLayout","_super","_this","apply","arguments","center","nodeSize","minNodeSpacing","preventOverlap","equidistant","startAngle","Math","PI","clockwise","sortBy","nodes","edges","width","height","prototype","getDefaultCfg","sweep","undefined","maxLevelDiff","execute","self","n","length","x","y","layoutNodes","maxNodeSize","max","forEach","node","push","size","window","innerWidth","innerHeight","counterclockwise","nodeMap","nodeIdxMap","i","id","degree","values_1","sort","n1","n2","maxValueNode","levels","currentLevel","diff","abs","minDist","firstLvlHasMulti","maxR","min","rStep","r","level","dTheta","dcos","cos","dsin","sin","rMin","sqrt","rDeltaMax_1","rr_1","rDelta","rr","j","theta"],"mappings":"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","sourcesContent":["/**\n * @fileOverview concentric layout\n * @author shiwu.wyy@antfin.com\n * this algorithm refers to <cytoscape.js> - https://github.com/cytoscape/cytoscape.js/\n */\nimport { __extends } from \"tslib\";\nimport isArray from '@antv/util/lib/is-array';\nimport isString from '@antv/util/lib/is-string';\nimport { BaseLayout } from './layout';\nimport { getDegree } from '../util/math';\nimport { isNumber } from '@antv/util';\n/**\n * 同心圆布局\n */\n\nvar ConcentricLayout =\n/** @class */\nfunction (_super) {\n  __extends(ConcentricLayout, _super);\n\n  function ConcentricLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    _this.nodeSize = 30;\n    /** min spacing between outside of nodes (used for radius adjustment) */\n\n    _this.minNodeSpacing = 10;\n    /** prevents node overlap, may overflow boundingBox if not enough space */\n\n    _this.preventOverlap = false;\n    /** whether levels have an equal radial distance betwen them, may cause bounding box overflow */\n\n    _this.equidistant = false;\n    /** where nodes start in radians */\n\n    _this.startAngle = 3 / 2 * Math.PI;\n    /** whether the layout should go clockwise (true) or counterclockwise/anticlockwise (false) */\n\n    _this.clockwise = true;\n    /** 根据 sortBy 指定的属性进行排布，数值高的放在中心，如果是 sortBy 则会计算节点度数，度数最高的放在中心 */\n\n    _this.sortBy = 'degree';\n    _this.nodes = [];\n    _this.edges = [];\n    _this.width = 300;\n    _this.height = 300;\n    return _this;\n  }\n\n  ConcentricLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      nodeSize: 30,\n      minNodeSpacing: 10,\n      preventOverlap: false,\n      sweep: undefined,\n      equidistant: false,\n      startAngle: 3 / 2 * Math.PI,\n      clockwise: true,\n      maxLevelDiff: undefined,\n      sortBy: 'degree'\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  ConcentricLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var edges = self.edges;\n    var n = nodes.length;\n    var center = self.center;\n\n    if (n === 0) {\n      return;\n    }\n\n    if (n === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var layoutNodes = [];\n    var maxNodeSize;\n\n    if (isArray(self.nodeSize)) {\n      maxNodeSize = Math.max(self.nodeSize[0], self.nodeSize[1]);\n    } else {\n      maxNodeSize = self.nodeSize;\n    }\n\n    nodes.forEach(function (node) {\n      layoutNodes.push(node);\n      var nodeSize = maxNodeSize;\n\n      if (isArray(node.size)) {\n        nodeSize = Math.max(node.size[0], node.size[1]);\n      } else if (isNumber(node.size)) {\n        nodeSize = node.size;\n      }\n\n      maxNodeSize = Math.max(maxNodeSize, nodeSize);\n    });\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    self.clockwise = self.counterclockwise !== undefined ? !self.counterclockwise : self.clockwise; // layout\n\n    var nodeMap = {};\n    var nodeIdxMap = {};\n    layoutNodes.forEach(function (node, i) {\n      nodeMap[node.id] = node;\n      nodeIdxMap[node.id] = i;\n    }); // get the node degrees\n\n    if (self.sortBy === 'degree' || !isString(self.sortBy) || layoutNodes[0][self.sortBy] === undefined) {\n      self.sortBy = 'degree';\n\n      if (!isNumber(nodes[0].degree)) {\n        var values_1 = getDegree(nodes.length, nodeIdxMap, edges);\n        layoutNodes.forEach(function (node, i) {\n          node.degree = values_1[i];\n        });\n      }\n    } // sort nodes by value\n\n\n    layoutNodes.sort(function (n1, n2) {\n      return n2[self.sortBy] - n1[self.sortBy];\n    });\n    self.maxValueNode = layoutNodes[0];\n    self.maxLevelDiff = self.maxLevelDiff || self.maxValueNode[self.sortBy] / 4; // put the values into levels\n\n    var levels = [[]];\n    var currentLevel = levels[0];\n    layoutNodes.forEach(function (node) {\n      if (currentLevel.length > 0) {\n        var diff = Math.abs(currentLevel[0][self.sortBy] - node[self.sortBy]);\n\n        if (self.maxLevelDiff && diff >= self.maxLevelDiff) {\n          currentLevel = [];\n          levels.push(currentLevel);\n        }\n      }\n\n      currentLevel.push(node);\n    }); // create positions for levels\n\n    var minDist = maxNodeSize + self.minNodeSpacing; // min dist between nodes\n\n    if (!self.preventOverlap) {\n      // then strictly constrain to bb\n      var firstLvlHasMulti = levels.length > 0 && levels[0].length > 1;\n      var maxR = Math.min(self.width, self.height) / 2 - minDist;\n      var rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));\n      minDist = Math.min(minDist, rStep);\n    } // find the metrics for each level\n\n\n    var r = 0;\n    levels.forEach(function (level) {\n      var sweep = self.sweep;\n\n      if (sweep === undefined) {\n        sweep = 2 * Math.PI - 2 * Math.PI / level.length;\n      }\n\n      var dTheta = level.dTheta = sweep / Math.max(1, level.length - 1); // calculate the radius\n\n      if (level.length > 1 && self.preventOverlap) {\n        // but only if more than one node (can't overlap)\n        var dcos = Math.cos(dTheta) - Math.cos(0);\n        var dsin = Math.sin(dTheta) - Math.sin(0);\n        var rMin = Math.sqrt(minDist * minDist / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping\n\n        r = Math.max(rMin, r);\n      }\n\n      level.r = r;\n      r += minDist;\n    });\n\n    if (self.equidistant) {\n      var rDeltaMax_1 = 0;\n      var rr_1 = 0;\n\n      for (var i = 0; i < levels.length; i++) {\n        var level = levels[i];\n        var rDelta = level.r - rr_1;\n        rDeltaMax_1 = Math.max(rDeltaMax_1, rDelta);\n      }\n\n      rr_1 = 0;\n      levels.forEach(function (level, i) {\n        if (i === 0) {\n          rr_1 = level.r;\n        }\n\n        level.r = rr_1;\n        rr_1 += rDeltaMax_1;\n      });\n    } // calculate the node positions\n\n\n    levels.forEach(function (level) {\n      var dTheta = level.dTheta;\n      var rr = level.r;\n      level.forEach(function (node, j) {\n        var theta = self.startAngle + (self.clockwise ? 1 : -1) * dTheta * j;\n        node.x = center[0] + rr * Math.cos(theta);\n        node.y = center[1] + rr * Math.sin(theta);\n      });\n    });\n  };\n\n  return ConcentricLayout;\n}(BaseLayout);\n\nexport default ConcentricLayout;"]},"metadata":{},"sourceType":"module"}