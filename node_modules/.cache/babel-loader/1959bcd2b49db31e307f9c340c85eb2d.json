{"ast":null,"code":"import { __extends } from \"tslib\";\nimport Base from '../base';\n\nfunction getEucliDis(pointA, pointB, eps) {\n  var vx = pointA.x - pointB.x;\n  var vy = pointA.y - pointB.y;\n\n  if (!eps || Math.abs(vx) > eps || Math.abs(vy) > eps) {\n    return Math.sqrt(vx * vx + vy * vy);\n  }\n\n  return eps;\n}\n\nfunction getDotProduct(ei, ej) {\n  return ei.x * ej.x + ei.y * ej.y;\n}\n\nfunction projectPointToEdge(p, e) {\n  var k = (e.source.y - e.target.y) / (e.source.x - e.target.x);\n  var x = (k * k * e.source.x + k * (p.y - e.source.y) + p.x) / (k * k + 1);\n  var y = k * (x - e.source.x) + e.source.y;\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar Bundling =\n/** @class */\nfunction (_super) {\n  __extends(Bundling, _super);\n\n  function Bundling() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Bundling.prototype.getDefaultCfgs = function () {\n    return {\n      edgeBundles: [],\n      edgePoints: [],\n      K: 0.1,\n      lambda: 0.1,\n      divisions: 1,\n      divRate: 2,\n      cycles: 6,\n      iterations: 90,\n      iterRate: 0.6666667,\n      bundleThreshold: 0.6,\n      eps: 1e-6,\n      onLayoutEnd: function onLayoutEnd() {},\n      onTick: function onTick() {}\n    };\n  };\n\n  Bundling.prototype.init = function () {\n    var graph = this.get('graph');\n    var onTick = this.get('onTick');\n\n    var tick = function tick() {\n      if (onTick) {\n        onTick();\n      }\n\n      graph.refreshPositions();\n    };\n\n    this.set('tick', tick);\n  };\n\n  Bundling.prototype.bundling = function (data) {\n    var self = this;\n    self.set('data', data); // 如果正在布局，忽略布局请求\n\n    if (self.isTicking()) {\n      return;\n    }\n\n    var edges = data.edges || [];\n    var nodes = data.nodes || [];\n    var nodeIdMap = {};\n    var error = false;\n    nodes.forEach(function (node) {\n      if (node.x === null || !node.y === null || node.x === undefined || !node.y === undefined) {\n        error = true;\n      }\n\n      nodeIdMap[node.id] = node;\n    });\n    if (error) throw new Error('please layout the graph or assign x and y for nodes first');\n    self.set('nodeIdMap', nodeIdMap); // subdivide each edges\n\n    var divisions = self.get('divisions');\n    var divRate = self.get('divRate');\n    var edgePoints = self.divideEdges(divisions);\n    self.set('edgePoints', edgePoints); // compute the bundles\n\n    var edgeBundles = self.getEdgeBundles();\n    self.set('edgeBundles', edgeBundles); // iterations\n\n    var C = self.get('cycles');\n    var iterations = self.get('iterations');\n    var iterRate = self.get('iterRate');\n    var lambda = self.get('lambda');\n\n    for (var i = 0; i < C; i++) {\n      var _loop_1 = function _loop_1(j) {\n        var forces = [];\n        edges.forEach(function (e, k) {\n          if (e.source === e.target) return;\n          var source = nodeIdMap[e.source];\n          var target = nodeIdMap[e.target];\n          forces[k] = self.getEdgeForces({\n            source: source,\n            target: target\n          }, k, divisions, lambda);\n\n          for (var p = 0; p < divisions + 1; p++) {\n            edgePoints[k][p].x += forces[k][p].x;\n            edgePoints[k][p].y += forces[k][p].y;\n          }\n        });\n      };\n\n      for (var j = 0; j < iterations; j++) {\n        _loop_1(j);\n      } // parameters for nex cycle\n\n\n      lambda = lambda / 2;\n      divisions *= divRate;\n      iterations *= iterRate;\n      edgePoints = self.divideEdges(divisions);\n      self.set('edgePoints', edgePoints);\n    } // change the edges according to edgePoints\n\n\n    edges.forEach(function (e, i) {\n      if (e.source === e.target) return;\n      e.shape = 'polyline';\n      e.type = 'polyline';\n      e.controlPoints = edgePoints[i].slice(1, edgePoints[i].length - 1);\n    });\n    var graph = self.get('graph');\n    graph.refresh();\n  };\n\n  Bundling.prototype.updateBundling = function (cfg) {\n    var self = this;\n    var data = cfg.data;\n\n    if (data) {\n      self.set('data', data);\n    }\n\n    if (self.get('ticking')) {\n      self.set('ticking', false);\n    }\n\n    Object.keys(cfg).forEach(function (key) {\n      self.set(key, cfg[key]);\n    });\n\n    if (cfg.onTick) {\n      var graph_1 = this.get('graph');\n      self.set('tick', function () {\n        cfg.onTick();\n        graph_1.refresh();\n      });\n    }\n\n    self.bundling(data);\n  };\n\n  Bundling.prototype.divideEdges = function (divisions) {\n    var self = this;\n    var edges = self.get('data').edges;\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgePoints = self.get('edgePoints');\n    if (!edgePoints || edgePoints === undefined) edgePoints = [];\n    edges.forEach(function (edge, i) {\n      if (!edgePoints[i] || edgePoints[i] === undefined) {\n        edgePoints[i] = [];\n      }\n\n      var source = nodeIdMap[edge.source];\n      var target = nodeIdMap[edge.target];\n\n      if (divisions === 1) {\n        edgePoints[i].push({\n          x: source.x,\n          y: source.y\n        }); // source\n\n        edgePoints[i].push({\n          x: 0.5 * (source.x + target.x),\n          y: 0.5 * (source.y + target.y)\n        }); // mid\n\n        edgePoints[i].push({\n          x: target.x,\n          y: target.y\n        }); // target\n      } else {\n        var edgeLength = 0;\n\n        if (!edgePoints[i] || edgePoints[i] === []) {\n          // it is a straight line\n          edgeLength = getEucliDis({\n            x: source.x,\n            y: source.y\n          }, {\n            x: target.x,\n            y: target.y\n          });\n        } else {\n          edgeLength = self.getEdgeLength(edgePoints[i]);\n        }\n\n        var divisionLength_1 = edgeLength / (divisions + 1);\n        var currentDivisonLength_1 = divisionLength_1;\n        var newEdgePoints_1 = [{\n          x: source.x,\n          y: source.y\n        }]; // source\n\n        edgePoints[i].forEach(function (ep, j) {\n          if (j === 0) return;\n          var oriDivisionLength = getEucliDis(ep, edgePoints[i][j - 1]);\n\n          while (oriDivisionLength > currentDivisonLength_1) {\n            var ratio = currentDivisonLength_1 / oriDivisionLength;\n            var edgePoint = {\n              x: edgePoints[i][j - 1].x,\n              y: edgePoints[i][j - 1].y\n            };\n            edgePoint.x += ratio * (ep.x - edgePoints[i][j - 1].x);\n            edgePoint.y += ratio * (ep.y - edgePoints[i][j - 1].y);\n            newEdgePoints_1.push(edgePoint);\n            oriDivisionLength -= currentDivisonLength_1;\n            currentDivisonLength_1 = divisionLength_1;\n          }\n\n          currentDivisonLength_1 -= oriDivisionLength;\n        });\n        newEdgePoints_1.push({\n          x: target.x,\n          y: target.y\n        }); // target\n\n        edgePoints[i] = newEdgePoints_1;\n      }\n    });\n    return edgePoints;\n  };\n  /**\n   * 计算边的长度\n   * @param points\n   */\n\n\n  Bundling.prototype.getEdgeLength = function (points) {\n    var length = 0;\n    points.forEach(function (p, i) {\n      if (i === 0) return;\n      length += getEucliDis(p, points[i - 1]);\n    });\n    return length;\n  };\n\n  Bundling.prototype.getEdgeBundles = function () {\n    var self = this;\n    var data = self.get('data');\n    var edges = data.edges || [];\n    var bundleThreshold = self.get('bundleThreshold');\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgeBundles = self.get('edgeBundles');\n    if (!edgeBundles) edgeBundles = [];\n    edges.forEach(function (e, i) {\n      if (!edgeBundles[i] || edgeBundles[i] === undefined) {\n        edgeBundles[i] = [];\n      }\n    });\n    edges.forEach(function (ei, i) {\n      var iSource = nodeIdMap[ei.source];\n      var iTarget = nodeIdMap[ei.target];\n      edges.forEach(function (ej, j) {\n        if (j <= i) return;\n        var jSource = nodeIdMap[ej.source];\n        var jTarget = nodeIdMap[ej.target];\n        var score = self.getBundleScore({\n          source: iSource,\n          target: iTarget\n        }, {\n          source: jSource,\n          target: jTarget\n        });\n\n        if (score >= bundleThreshold) {\n          edgeBundles[i].push(j);\n          edgeBundles[j].push(i);\n        }\n      });\n    });\n    return edgeBundles;\n  };\n\n  Bundling.prototype.getBundleScore = function (ei, ej) {\n    var self = this;\n    ei.vx = ei.target.x - ei.source.x;\n    ei.vy = ei.target.y - ei.source.y;\n    ej.vx = ej.target.x - ej.source.x;\n    ej.vy = ej.target.y - ej.source.y;\n    ei.length = getEucliDis({\n      x: ei.source.x,\n      y: ei.source.y\n    }, {\n      x: ei.target.x,\n      y: ei.target.y\n    });\n    ej.length = getEucliDis({\n      x: ej.source.x,\n      y: ej.source.y\n    }, {\n      x: ej.target.x,\n      y: ej.target.y\n    }); // angle score\n\n    var aScore = self.getAngleScore(ei, ej); // scale score\n\n    var sScore = self.getScaleScore(ei, ej); // position score\n\n    var pScore = self.getPositionScore(ei, ej); // visibility socre\n\n    var vScore = self.getVisibilityScore(ei, ej);\n    return aScore * sScore * pScore * vScore;\n  };\n\n  Bundling.prototype.getAngleScore = function (ei, ej) {\n    var dotProduct = getDotProduct({\n      x: ei.vx,\n      y: ei.vy\n    }, {\n      x: ej.vx,\n      y: ej.vy\n    });\n    return dotProduct / (ei.length * ej.length);\n  };\n\n  Bundling.prototype.getScaleScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var score = 2 / (aLength / Math.min(ei.length, ej.length) + Math.max(ei.length, ej.length) / aLength);\n    return score;\n  };\n\n  Bundling.prototype.getPositionScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    var jMid = {\n      x: (ej.source.x + ej.target.x) / 2,\n      y: (ej.source.y + ej.target.y) / 2\n    };\n    var distance = getEucliDis(iMid, jMid);\n    return aLength / (aLength + distance);\n  };\n\n  Bundling.prototype.getVisibilityScore = function (ei, ej) {\n    var vij = this.getEdgeVisibility(ei, ej);\n    var vji = this.getEdgeVisibility(ej, ei);\n    return vij < vji ? vij : vji;\n  };\n\n  Bundling.prototype.getEdgeVisibility = function (ei, ej) {\n    var ps = projectPointToEdge(ej.source, ei);\n    var pt = projectPointToEdge(ej.target, ei);\n    var pMid = {\n      x: (ps.x + pt.x) / 2,\n      y: (ps.y + pt.y) / 2\n    };\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    return Math.max(0, 1 - 2 * getEucliDis(pMid, iMid) / getEucliDis(ps, pt));\n  };\n\n  Bundling.prototype.getEdgeForces = function (e, eidx, divisions, lambda) {\n    var self = this;\n    var edgePoints = self.get('edgePoints');\n    var K = self.get('K');\n    var kp = K / (getEucliDis(e.source, e.target) * (divisions + 1));\n    var edgePointForces = [{\n      x: 0,\n      y: 0\n    }];\n\n    for (var i = 1; i < divisions; i++) {\n      var force = {\n        x: 0,\n        y: 0\n      };\n      var spring = self.getSpringForce({\n        pre: edgePoints[eidx][i - 1],\n        cur: edgePoints[eidx][i],\n        next: edgePoints[eidx][i + 1]\n      }, kp);\n      var electrostatic = self.getElectrostaticForce(i, eidx);\n      force.x = lambda * (spring.x + electrostatic.x);\n      force.y = lambda * (spring.y + electrostatic.y);\n      edgePointForces.push(force);\n    }\n\n    edgePointForces.push({\n      x: 0,\n      y: 0\n    });\n    return edgePointForces;\n  };\n\n  Bundling.prototype.getSpringForce = function (divisions, kp) {\n    var x = divisions.pre.x + divisions.next.x - 2 * divisions.cur.x;\n    var y = divisions.pre.y + divisions.next.y - 2 * divisions.cur.y;\n    x *= kp;\n    y *= kp;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  Bundling.prototype.getElectrostaticForce = function (pidx, eidx) {\n    var self = this;\n    var eps = self.get('eps');\n    var edgeBundles = self.get('edgeBundles');\n    var edgePoints = self.get('edgePoints');\n    var edgeBundle = edgeBundles[eidx];\n    var resForce = {\n      x: 0,\n      y: 0\n    };\n    edgeBundle.forEach(function (eb) {\n      var force = {\n        x: edgePoints[eb][pidx].x - edgePoints[eidx][pidx].x,\n        y: edgePoints[eb][pidx].y - edgePoints[eidx][pidx].y\n      };\n\n      if (Math.abs(force.x) > eps || Math.abs(force.y) > eps) {\n        var length_1 = getEucliDis(edgePoints[eb][pidx], edgePoints[eidx][pidx]);\n        var diff = 1 / length_1;\n        resForce.x += force.x * diff;\n        resForce.y += force.y * diff;\n      }\n    });\n    return resForce;\n  };\n\n  Bundling.prototype.isTicking = function () {\n    return this.get('ticking');\n  };\n\n  Bundling.prototype.getSimulation = function () {\n    return this.get('forceSimulation');\n  };\n\n  Bundling.prototype.destroy = function () {\n    if (this.get('ticking')) {\n      this.getSimulation().stop();\n    }\n\n    _super.prototype.destroy.call(this);\n  };\n\n  return Bundling;\n}(Base);\n\nexport default Bundling;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/plugins/bundling/index.js"],"names":["__extends","Base","getEucliDis","pointA","pointB","eps","vx","x","vy","y","Math","abs","sqrt","getDotProduct","ei","ej","projectPointToEdge","p","e","k","source","target","Bundling","_super","apply","arguments","prototype","getDefaultCfgs","edgeBundles","edgePoints","K","lambda","divisions","divRate","cycles","iterations","iterRate","bundleThreshold","onLayoutEnd","onTick","init","graph","get","tick","refreshPositions","set","bundling","data","self","isTicking","edges","nodes","nodeIdMap","error","forEach","node","undefined","id","Error","divideEdges","getEdgeBundles","C","i","_loop_1","j","forces","getEdgeForces","shape","type","controlPoints","slice","length","refresh","updateBundling","cfg","Object","keys","key","graph_1","edge","push","edgeLength","getEdgeLength","divisionLength_1","currentDivisonLength_1","newEdgePoints_1","ep","oriDivisionLength","ratio","edgePoint","points","iSource","iTarget","jSource","jTarget","score","getBundleScore","aScore","getAngleScore","sScore","getScaleScore","pScore","getPositionScore","vScore","getVisibilityScore","dotProduct","aLength","min","max","iMid","jMid","distance","vij","getEdgeVisibility","vji","ps","pt","pMid","eidx","kp","edgePointForces","force","spring","getSpringForce","pre","cur","next","electrostatic","getElectrostaticForce","pidx","edgeBundle","resForce","eb","length_1","diff","getSimulation","destroy","stop","call"],"mappings":"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","sourcesContent":["import { __extends } from \"tslib\";\nimport Base from '../base';\n\nfunction getEucliDis(pointA, pointB, eps) {\n  var vx = pointA.x - pointB.x;\n  var vy = pointA.y - pointB.y;\n\n  if (!eps || Math.abs(vx) > eps || Math.abs(vy) > eps) {\n    return Math.sqrt(vx * vx + vy * vy);\n  }\n\n  return eps;\n}\n\nfunction getDotProduct(ei, ej) {\n  return ei.x * ej.x + ei.y * ej.y;\n}\n\nfunction projectPointToEdge(p, e) {\n  var k = (e.source.y - e.target.y) / (e.source.x - e.target.x);\n  var x = (k * k * e.source.x + k * (p.y - e.source.y) + p.x) / (k * k + 1);\n  var y = k * (x - e.source.x) + e.source.y;\n  return {\n    x: x,\n    y: y\n  };\n}\n\nvar Bundling =\n/** @class */\nfunction (_super) {\n  __extends(Bundling, _super);\n\n  function Bundling() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Bundling.prototype.getDefaultCfgs = function () {\n    return {\n      edgeBundles: [],\n      edgePoints: [],\n      K: 0.1,\n      lambda: 0.1,\n      divisions: 1,\n      divRate: 2,\n      cycles: 6,\n      iterations: 90,\n      iterRate: 0.6666667,\n      bundleThreshold: 0.6,\n      eps: 1e-6,\n      onLayoutEnd: function onLayoutEnd() {},\n      onTick: function onTick() {}\n    };\n  };\n\n  Bundling.prototype.init = function () {\n    var graph = this.get('graph');\n    var onTick = this.get('onTick');\n\n    var tick = function tick() {\n      if (onTick) {\n        onTick();\n      }\n\n      graph.refreshPositions();\n    };\n\n    this.set('tick', tick);\n  };\n\n  Bundling.prototype.bundling = function (data) {\n    var self = this;\n    self.set('data', data); // 如果正在布局，忽略布局请求\n\n    if (self.isTicking()) {\n      return;\n    }\n\n    var edges = data.edges || [];\n    var nodes = data.nodes || [];\n    var nodeIdMap = {};\n    var error = false;\n    nodes.forEach(function (node) {\n      if (node.x === null || !node.y === null || node.x === undefined || !node.y === undefined) {\n        error = true;\n      }\n\n      nodeIdMap[node.id] = node;\n    });\n    if (error) throw new Error('please layout the graph or assign x and y for nodes first');\n    self.set('nodeIdMap', nodeIdMap); // subdivide each edges\n\n    var divisions = self.get('divisions');\n    var divRate = self.get('divRate');\n    var edgePoints = self.divideEdges(divisions);\n    self.set('edgePoints', edgePoints); // compute the bundles\n\n    var edgeBundles = self.getEdgeBundles();\n    self.set('edgeBundles', edgeBundles); // iterations\n\n    var C = self.get('cycles');\n    var iterations = self.get('iterations');\n    var iterRate = self.get('iterRate');\n    var lambda = self.get('lambda');\n\n    for (var i = 0; i < C; i++) {\n      var _loop_1 = function _loop_1(j) {\n        var forces = [];\n        edges.forEach(function (e, k) {\n          if (e.source === e.target) return;\n          var source = nodeIdMap[e.source];\n          var target = nodeIdMap[e.target];\n          forces[k] = self.getEdgeForces({\n            source: source,\n            target: target\n          }, k, divisions, lambda);\n\n          for (var p = 0; p < divisions + 1; p++) {\n            edgePoints[k][p].x += forces[k][p].x;\n            edgePoints[k][p].y += forces[k][p].y;\n          }\n        });\n      };\n\n      for (var j = 0; j < iterations; j++) {\n        _loop_1(j);\n      } // parameters for nex cycle\n\n\n      lambda = lambda / 2;\n      divisions *= divRate;\n      iterations *= iterRate;\n      edgePoints = self.divideEdges(divisions);\n      self.set('edgePoints', edgePoints);\n    } // change the edges according to edgePoints\n\n\n    edges.forEach(function (e, i) {\n      if (e.source === e.target) return;\n      e.shape = 'polyline';\n      e.type = 'polyline';\n      e.controlPoints = edgePoints[i].slice(1, edgePoints[i].length - 1);\n    });\n    var graph = self.get('graph');\n    graph.refresh();\n  };\n\n  Bundling.prototype.updateBundling = function (cfg) {\n    var self = this;\n    var data = cfg.data;\n\n    if (data) {\n      self.set('data', data);\n    }\n\n    if (self.get('ticking')) {\n      self.set('ticking', false);\n    }\n\n    Object.keys(cfg).forEach(function (key) {\n      self.set(key, cfg[key]);\n    });\n\n    if (cfg.onTick) {\n      var graph_1 = this.get('graph');\n      self.set('tick', function () {\n        cfg.onTick();\n        graph_1.refresh();\n      });\n    }\n\n    self.bundling(data);\n  };\n\n  Bundling.prototype.divideEdges = function (divisions) {\n    var self = this;\n    var edges = self.get('data').edges;\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgePoints = self.get('edgePoints');\n    if (!edgePoints || edgePoints === undefined) edgePoints = [];\n    edges.forEach(function (edge, i) {\n      if (!edgePoints[i] || edgePoints[i] === undefined) {\n        edgePoints[i] = [];\n      }\n\n      var source = nodeIdMap[edge.source];\n      var target = nodeIdMap[edge.target];\n\n      if (divisions === 1) {\n        edgePoints[i].push({\n          x: source.x,\n          y: source.y\n        }); // source\n\n        edgePoints[i].push({\n          x: 0.5 * (source.x + target.x),\n          y: 0.5 * (source.y + target.y)\n        }); // mid\n\n        edgePoints[i].push({\n          x: target.x,\n          y: target.y\n        }); // target\n      } else {\n        var edgeLength = 0;\n\n        if (!edgePoints[i] || edgePoints[i] === []) {\n          // it is a straight line\n          edgeLength = getEucliDis({\n            x: source.x,\n            y: source.y\n          }, {\n            x: target.x,\n            y: target.y\n          });\n        } else {\n          edgeLength = self.getEdgeLength(edgePoints[i]);\n        }\n\n        var divisionLength_1 = edgeLength / (divisions + 1);\n        var currentDivisonLength_1 = divisionLength_1;\n        var newEdgePoints_1 = [{\n          x: source.x,\n          y: source.y\n        }]; // source\n\n        edgePoints[i].forEach(function (ep, j) {\n          if (j === 0) return;\n          var oriDivisionLength = getEucliDis(ep, edgePoints[i][j - 1]);\n\n          while (oriDivisionLength > currentDivisonLength_1) {\n            var ratio = currentDivisonLength_1 / oriDivisionLength;\n            var edgePoint = {\n              x: edgePoints[i][j - 1].x,\n              y: edgePoints[i][j - 1].y\n            };\n            edgePoint.x += ratio * (ep.x - edgePoints[i][j - 1].x);\n            edgePoint.y += ratio * (ep.y - edgePoints[i][j - 1].y);\n            newEdgePoints_1.push(edgePoint);\n            oriDivisionLength -= currentDivisonLength_1;\n            currentDivisonLength_1 = divisionLength_1;\n          }\n\n          currentDivisonLength_1 -= oriDivisionLength;\n        });\n        newEdgePoints_1.push({\n          x: target.x,\n          y: target.y\n        }); // target\n\n        edgePoints[i] = newEdgePoints_1;\n      }\n    });\n    return edgePoints;\n  };\n  /**\n   * 计算边的长度\n   * @param points\n   */\n\n\n  Bundling.prototype.getEdgeLength = function (points) {\n    var length = 0;\n    points.forEach(function (p, i) {\n      if (i === 0) return;\n      length += getEucliDis(p, points[i - 1]);\n    });\n    return length;\n  };\n\n  Bundling.prototype.getEdgeBundles = function () {\n    var self = this;\n    var data = self.get('data');\n    var edges = data.edges || [];\n    var bundleThreshold = self.get('bundleThreshold');\n    var nodeIdMap = self.get('nodeIdMap');\n    var edgeBundles = self.get('edgeBundles');\n    if (!edgeBundles) edgeBundles = [];\n    edges.forEach(function (e, i) {\n      if (!edgeBundles[i] || edgeBundles[i] === undefined) {\n        edgeBundles[i] = [];\n      }\n    });\n    edges.forEach(function (ei, i) {\n      var iSource = nodeIdMap[ei.source];\n      var iTarget = nodeIdMap[ei.target];\n      edges.forEach(function (ej, j) {\n        if (j <= i) return;\n        var jSource = nodeIdMap[ej.source];\n        var jTarget = nodeIdMap[ej.target];\n        var score = self.getBundleScore({\n          source: iSource,\n          target: iTarget\n        }, {\n          source: jSource,\n          target: jTarget\n        });\n\n        if (score >= bundleThreshold) {\n          edgeBundles[i].push(j);\n          edgeBundles[j].push(i);\n        }\n      });\n    });\n    return edgeBundles;\n  };\n\n  Bundling.prototype.getBundleScore = function (ei, ej) {\n    var self = this;\n    ei.vx = ei.target.x - ei.source.x;\n    ei.vy = ei.target.y - ei.source.y;\n    ej.vx = ej.target.x - ej.source.x;\n    ej.vy = ej.target.y - ej.source.y;\n    ei.length = getEucliDis({\n      x: ei.source.x,\n      y: ei.source.y\n    }, {\n      x: ei.target.x,\n      y: ei.target.y\n    });\n    ej.length = getEucliDis({\n      x: ej.source.x,\n      y: ej.source.y\n    }, {\n      x: ej.target.x,\n      y: ej.target.y\n    }); // angle score\n\n    var aScore = self.getAngleScore(ei, ej); // scale score\n\n    var sScore = self.getScaleScore(ei, ej); // position score\n\n    var pScore = self.getPositionScore(ei, ej); // visibility socre\n\n    var vScore = self.getVisibilityScore(ei, ej);\n    return aScore * sScore * pScore * vScore;\n  };\n\n  Bundling.prototype.getAngleScore = function (ei, ej) {\n    var dotProduct = getDotProduct({\n      x: ei.vx,\n      y: ei.vy\n    }, {\n      x: ej.vx,\n      y: ej.vy\n    });\n    return dotProduct / (ei.length * ej.length);\n  };\n\n  Bundling.prototype.getScaleScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var score = 2 / (aLength / Math.min(ei.length, ej.length) + Math.max(ei.length, ej.length) / aLength);\n    return score;\n  };\n\n  Bundling.prototype.getPositionScore = function (ei, ej) {\n    var aLength = (ei.length + ej.length) / 2;\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    var jMid = {\n      x: (ej.source.x + ej.target.x) / 2,\n      y: (ej.source.y + ej.target.y) / 2\n    };\n    var distance = getEucliDis(iMid, jMid);\n    return aLength / (aLength + distance);\n  };\n\n  Bundling.prototype.getVisibilityScore = function (ei, ej) {\n    var vij = this.getEdgeVisibility(ei, ej);\n    var vji = this.getEdgeVisibility(ej, ei);\n    return vij < vji ? vij : vji;\n  };\n\n  Bundling.prototype.getEdgeVisibility = function (ei, ej) {\n    var ps = projectPointToEdge(ej.source, ei);\n    var pt = projectPointToEdge(ej.target, ei);\n    var pMid = {\n      x: (ps.x + pt.x) / 2,\n      y: (ps.y + pt.y) / 2\n    };\n    var iMid = {\n      x: (ei.source.x + ei.target.x) / 2,\n      y: (ei.source.y + ei.target.y) / 2\n    };\n    return Math.max(0, 1 - 2 * getEucliDis(pMid, iMid) / getEucliDis(ps, pt));\n  };\n\n  Bundling.prototype.getEdgeForces = function (e, eidx, divisions, lambda) {\n    var self = this;\n    var edgePoints = self.get('edgePoints');\n    var K = self.get('K');\n    var kp = K / (getEucliDis(e.source, e.target) * (divisions + 1));\n    var edgePointForces = [{\n      x: 0,\n      y: 0\n    }];\n\n    for (var i = 1; i < divisions; i++) {\n      var force = {\n        x: 0,\n        y: 0\n      };\n      var spring = self.getSpringForce({\n        pre: edgePoints[eidx][i - 1],\n        cur: edgePoints[eidx][i],\n        next: edgePoints[eidx][i + 1]\n      }, kp);\n      var electrostatic = self.getElectrostaticForce(i, eidx);\n      force.x = lambda * (spring.x + electrostatic.x);\n      force.y = lambda * (spring.y + electrostatic.y);\n      edgePointForces.push(force);\n    }\n\n    edgePointForces.push({\n      x: 0,\n      y: 0\n    });\n    return edgePointForces;\n  };\n\n  Bundling.prototype.getSpringForce = function (divisions, kp) {\n    var x = divisions.pre.x + divisions.next.x - 2 * divisions.cur.x;\n    var y = divisions.pre.y + divisions.next.y - 2 * divisions.cur.y;\n    x *= kp;\n    y *= kp;\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  Bundling.prototype.getElectrostaticForce = function (pidx, eidx) {\n    var self = this;\n    var eps = self.get('eps');\n    var edgeBundles = self.get('edgeBundles');\n    var edgePoints = self.get('edgePoints');\n    var edgeBundle = edgeBundles[eidx];\n    var resForce = {\n      x: 0,\n      y: 0\n    };\n    edgeBundle.forEach(function (eb) {\n      var force = {\n        x: edgePoints[eb][pidx].x - edgePoints[eidx][pidx].x,\n        y: edgePoints[eb][pidx].y - edgePoints[eidx][pidx].y\n      };\n\n      if (Math.abs(force.x) > eps || Math.abs(force.y) > eps) {\n        var length_1 = getEucliDis(edgePoints[eb][pidx], edgePoints[eidx][pidx]);\n        var diff = 1 / length_1;\n        resForce.x += force.x * diff;\n        resForce.y += force.y * diff;\n      }\n    });\n    return resForce;\n  };\n\n  Bundling.prototype.isTicking = function () {\n    return this.get('ticking');\n  };\n\n  Bundling.prototype.getSimulation = function () {\n    return this.get('forceSimulation');\n  };\n\n  Bundling.prototype.destroy = function () {\n    if (this.get('ticking')) {\n      this.getSimulation().stop();\n    }\n\n    _super.prototype.destroy.call(this);\n  };\n\n  return Bundling;\n}(Base);\n\nexport default Bundling;"]},"metadata":{},"sourceType":"module"}