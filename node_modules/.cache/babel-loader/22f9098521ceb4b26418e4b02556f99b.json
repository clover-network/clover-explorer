{"ast":null,"code":"import { __extends } from \"tslib\";\nimport each from '@antv/util/lib/each';\nimport isNil from '@antv/util/lib/is-nil';\nimport mix from '@antv/util/lib/mix';\nimport { distance, getCircleIntersectByPoint, getEllipseIntersectByPoint, getRectIntersectByPoint } from '../util/math';\nimport Item from './item';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\n\nvar Node =\n/** @class */\nfunction (_super) {\n  __extends(Node, _super);\n\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = distance(points[0], curPoint);\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = distance(point, curPoint);\n\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n\n\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n\n\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n\n\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n\n\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n\n    var edges = this.get('edges');\n\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    } // 若未指定 type ，则返回所有邻居\n\n\n    var neighhborsConverter = function neighhborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n\n    return edges.map(neighhborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n\n\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n\n\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n\n    if (itemType === 'combo') {\n      centerX = (bbox.maxX + bbox.minX) / 2;\n      centerY = (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n\n    switch (type) {\n      case 'circle':\n        intersectPoint = getCircleIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n\n      case 'ellipse':\n        intersectPoint = getEllipseIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n\n      default:\n        intersectPoint = getRectIntersectByPoint(bbox, point);\n    }\n\n    var linkPoint = intersectPoint; // 如果存在锚点，则使用交点计算最近的锚点\n\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n\n\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.shape || model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      each(points, function (pointArr, index) {\n        var point = mix({\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height\n        }, pointArr[2], {\n          index: index\n        });\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n\n\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n\n\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n\n\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n\n\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n\n    if (index > -1) {\n      edges.splice(index, 1);\n    }\n  };\n\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 是否仅仅移动节点，其他属性没变化\n   * @param cfg 节点数据模型\n   */\n\n\n  Node.prototype.isOnlyMove = function (cfg) {\n    if (!cfg) {\n      return false;\n    }\n\n    var existX = !isNil(cfg.x);\n    var existY = !isNil(cfg.y);\n    var keys = Object.keys(cfg); // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n\n    return keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY;\n  };\n\n  return Node;\n}(Item);\n\nexport default Node;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/item/node.js"],"names":["__extends","each","isNil","mix","distance","getCircleIntersectByPoint","getEllipseIntersectByPoint","getRectIntersectByPoint","Item","CACHE_ANCHOR_POINTS","CACHE_BBOX","Node","_super","apply","arguments","prototype","getNearestPoint","points","curPoint","index","nearestPoint","minDistance","i","length","point","dis","anchorIndex","getDefaultCfg","type","edges","getEdges","get","getInEdges","self","filter","edge","getOutEdges","getNeighbors","_this","neighhborsConverter_1","getSource","map","getTarget","neighhborsConverter_2","neighhborsConverter","getLinkPointByAnchor","anchorPoints","getAnchorPoints","getLinkPoint","keyShape","itemType","centerX","centerY","bbox","getBBox","maxX","minX","maxY","minY","intersectPoint","x","y","r","width","rx","ry","height","linkPoint","shapeFactory","bbox_1","model","shapeCfg","getShapeCfg","shape","pointArr","push","set","addEdge","lock","unlock","hasLocked","removeEdge","indexOf","splice","clearCache","isOnlyMove","cfg","existX","existY","keys","Object"],"mappings":"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","sourcesContent":["import { __extends } from \"tslib\";\nimport each from '@antv/util/lib/each';\nimport isNil from '@antv/util/lib/is-nil';\nimport mix from '@antv/util/lib/mix';\nimport { distance, getCircleIntersectByPoint, getEllipseIntersectByPoint, getRectIntersectByPoint } from '../util/math';\nimport Item from './item';\nvar CACHE_ANCHOR_POINTS = 'anchorPointsCache';\nvar CACHE_BBOX = 'bboxCache';\n\nvar Node =\n/** @class */\nfunction (_super) {\n  __extends(Node, _super);\n\n  function Node() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  Node.prototype.getNearestPoint = function (points, curPoint) {\n    var index = 0;\n    var nearestPoint = points[0];\n    var minDistance = distance(points[0], curPoint);\n\n    for (var i = 0; i < points.length; i++) {\n      var point = points[i];\n      var dis = distance(point, curPoint);\n\n      if (dis < minDistance) {\n        nearestPoint = point;\n        minDistance = dis;\n        index = i;\n      }\n    }\n\n    nearestPoint.anchorIndex = index;\n    return nearestPoint;\n  };\n\n  Node.prototype.getDefaultCfg = function () {\n    return {\n      type: 'node',\n      edges: []\n    };\n  };\n  /**\n   * 获取从节点关联的所有边\n   */\n\n\n  Node.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取所有的入边\n   */\n\n\n  Node.prototype.getInEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('target') === self;\n    });\n  };\n  /**\n   * 获取所有的出边\n   */\n\n\n  Node.prototype.getOutEdges = function () {\n    var self = this;\n    return this.get('edges').filter(function (edge) {\n      return edge.get('source') === self;\n    });\n  };\n  /**\n   * 获取节点的邻居节点\n   *\n   * @returns {INode[]}\n   * @memberof Node\n   */\n\n\n  Node.prototype.getNeighbors = function (type) {\n    var _this = this;\n\n    var edges = this.get('edges');\n\n    if (type === 'target') {\n      // 当前节点为 source，它所指向的目标节点\n      var neighhborsConverter_1 = function neighhborsConverter_1(edge) {\n        return edge.getSource() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_1).map(function (edge) {\n        return edge.getTarget();\n      });\n    }\n\n    if (type === 'source') {\n      // 当前节点为 target，它所指向的源节点\n      var neighhborsConverter_2 = function neighhborsConverter_2(edge) {\n        return edge.getTarget() === _this;\n      };\n\n      return edges.filter(neighhborsConverter_2).map(function (edge) {\n        return edge.getSource();\n      });\n    } // 若未指定 type ，则返回所有邻居\n\n\n    var neighhborsConverter = function neighhborsConverter(edge) {\n      return edge.getSource() === _this ? edge.getTarget() : edge.getSource();\n    };\n\n    return edges.map(neighhborsConverter);\n  };\n  /**\n   * 根据锚点的索引获取连接点\n   * @param  {Number} index 索引\n   */\n\n\n  Node.prototype.getLinkPointByAnchor = function (index) {\n    var anchorPoints = this.getAnchorPoints();\n    return anchorPoints[index];\n  };\n  /**\n   * 获取连接点\n   * @param point\n   */\n\n\n  Node.prototype.getLinkPoint = function (point) {\n    var keyShape = this.get('keyShape');\n    var type = keyShape.get('type');\n    var itemType = this.get('type');\n    var centerX;\n    var centerY;\n    var bbox = this.getBBox();\n\n    if (itemType === 'combo') {\n      centerX = (bbox.maxX + bbox.minX) / 2;\n      centerY = (bbox.maxY + bbox.minY) / 2;\n    } else {\n      centerX = bbox.centerX;\n      centerY = bbox.centerY;\n    }\n\n    var anchorPoints = this.getAnchorPoints();\n    var intersectPoint;\n\n    switch (type) {\n      case 'circle':\n        intersectPoint = getCircleIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          r: bbox.width / 2\n        }, point);\n        break;\n\n      case 'ellipse':\n        intersectPoint = getEllipseIntersectByPoint({\n          x: centerX,\n          y: centerY,\n          rx: bbox.width / 2,\n          ry: bbox.height / 2\n        }, point);\n        break;\n\n      default:\n        intersectPoint = getRectIntersectByPoint(bbox, point);\n    }\n\n    var linkPoint = intersectPoint; // 如果存在锚点，则使用交点计算最近的锚点\n\n    if (anchorPoints.length) {\n      if (!linkPoint) {\n        // 如果计算不出交点\n        linkPoint = point;\n      }\n\n      linkPoint = this.getNearestPoint(anchorPoints, linkPoint);\n    }\n\n    if (!linkPoint) {\n      // 如果最终依然没法找到锚点和连接点，直接返回中心点\n      linkPoint = {\n        x: centerX,\n        y: centerY\n      };\n    }\n\n    return linkPoint;\n  };\n  /**\n   * 获取锚点的定义\n   * @return {array} anchorPoints\n   */\n\n\n  Node.prototype.getAnchorPoints = function () {\n    var anchorPoints = this.get(CACHE_ANCHOR_POINTS);\n\n    if (!anchorPoints) {\n      anchorPoints = [];\n      var shapeFactory = this.get('shapeFactory');\n      var bbox_1 = this.getBBox();\n      var model = this.get('model');\n      var shapeCfg = this.getShapeCfg(model);\n      var type = model.shape || model.type;\n      var points = shapeFactory.getAnchorPoints(type, shapeCfg) || [];\n      each(points, function (pointArr, index) {\n        var point = mix({\n          x: bbox_1.minX + pointArr[0] * bbox_1.width,\n          y: bbox_1.minY + pointArr[1] * bbox_1.height\n        }, pointArr[2], {\n          index: index\n        });\n        anchorPoints.push(point);\n      });\n      this.set(CACHE_ANCHOR_POINTS, anchorPoints);\n    }\n\n    return anchorPoints;\n  };\n  /**\n   * add edge\n   * @param edge Edge instance\n   */\n\n\n  Node.prototype.addEdge = function (edge) {\n    this.get('edges').push(edge);\n  };\n  /**\n   * 锁定节点\n   */\n\n\n  Node.prototype.lock = function () {\n    this.set('locked', true);\n  };\n  /**\n   * 解锁锁定的节点\n   */\n\n\n  Node.prototype.unlock = function () {\n    this.set('locked', false);\n  };\n\n  Node.prototype.hasLocked = function () {\n    return this.get('locked');\n  };\n  /**\n   * 移除边\n   * @param {Edge} edge 边\n   */\n\n\n  Node.prototype.removeEdge = function (edge) {\n    var edges = this.getEdges();\n    var index = edges.indexOf(edge);\n\n    if (index > -1) {\n      edges.splice(index, 1);\n    }\n  };\n\n  Node.prototype.clearCache = function () {\n    this.set(CACHE_BBOX, null); // 清理缓存的 bbox\n\n    this.set(CACHE_ANCHOR_POINTS, null);\n  };\n  /**\n   * 是否仅仅移动节点，其他属性没变化\n   * @param cfg 节点数据模型\n   */\n\n\n  Node.prototype.isOnlyMove = function (cfg) {\n    if (!cfg) {\n      return false;\n    }\n\n    var existX = !isNil(cfg.x);\n    var existY = !isNil(cfg.y);\n    var keys = Object.keys(cfg); // 仅有一个字段，包含 x 或者 包含 y\n    // 两个字段，同时有 x，同时有 y\n\n    return keys.length === 1 && (existX || existY) || keys.length === 2 && existX && existY;\n  };\n\n  return Node;\n}(Item);\n\nexport default Node;"]},"metadata":{},"sourceType":"module"}