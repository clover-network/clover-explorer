{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar innerStore_1 = require(\"../../util/innerStore\");\n\nvar labelStyle_1 = require(\"../../label/labelStyle\");\n\nvar Model_1 = require(\"../../model/Model\");\n\nvar number_1 = require(\"../../util/number\");\n\nvar symbol_1 = require(\"../../util/symbol\");\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar vector_1 = require(\"zrender/lib/core/vector\");\n\nvar axisHelper_1 = require(\"../../coord/axisHelper\");\n\nvar PI = Math.PI;\n\nvar AxisBuilder = function () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new graphic.Group();\n    this.opt = opt;\n    this.axisModel = axisModel;\n    util_1.defaults(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function () {\n        return true;\n      }\n    });\n    var transformGroup = new graphic.Group({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    });\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = number_1.remRadian(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if (number_1.isRadianAroundZero(rotationDiff)) {\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if (number_1.isRadianAroundZero(rotationDiff - PI)) {\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n\n  return AxisBuilder;\n}();\n\n;\nvar builders = {\n  axisLine: function (opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n\n    if (!shown) {\n      return;\n    }\n\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      vector_1.applyTransform(pt1, pt1, matrix);\n      vector_1.applyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = util_1.extend({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new graphic.Line({\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n    var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n    var arrowOffset = axisModel.get(['axisLine', 'symbolOffset']) || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      util_1.each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = symbol_1.createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);\n          var r = point.r + point.offset;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt1[0] + r * Math.cos(opt.rotation),\n            y: pt1[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function (opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);\n  },\n  axisName: function (opt, axisModel, group, transformGroup) {\n    var name = util_1.retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180;\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = util_1.retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: labelStyle_1.createTextStyle(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    textEl.tooltip = tooltipOpt && tooltipOpt.show ? util_1.extend({\n      content: name,\n      formatter: function () {\n        return name;\n      },\n      formatterParams: formatterParams\n    }, tooltipOpt) : null;\n    textEl.__fullText = name;\n    textEl.anid = 'name';\n\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      innerStore_1.getECData(textEl).eventData = eventData;\n    }\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = number_1.remRadian(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (number_1.isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (number_1.isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (axisHelper_1.shouldShowAllLabels(axisModel.axis)) {\n    return;\n  }\n\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']);\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next) {\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  }\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n\n    if (tickTransform) {\n      vector_1.applyTransform(pt1, pt1, tickTransform);\n      vector_1.applyTransform(pt2, pt2, tickTransform);\n    }\n\n    var tickEl = new graphic.Line({\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, util_1.defaults(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n\n  return ticksEls;\n}\n\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var minorTicksCoords = axis.getMinorTicksCoords();\n\n  if (!minorTicksCoords.length) {\n    return;\n  }\n\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = util_1.defaults(lineStyleModel.getLineStyle(), util_1.defaults(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\n\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = util_1.retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels();\n  var labelRotation = (util_1.retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  util_1.each(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawIndex(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n\n      if (util_1.isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new Model_1[\"default\"](rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var textEl = new graphic.Text({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10,\n      style: labelStyle_1.createTextStyle(itemLabelModel, {\n        text: formattedLabel,\n        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n        fill: typeof textColor === 'function' ? textColor(axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue;\n\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      innerStore_1.getECData(textEl).eventData = eventData;\n    }\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nexports[\"default\"] = AxisBuilder;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/component/axis/AxisBuilder.js"],"names":["exports","__esModule","util_1","require","graphic","innerStore_1","labelStyle_1","Model_1","number_1","symbol_1","matrixUtil","vector_1","axisHelper_1","PI","Math","AxisBuilder","axisModel","opt","group","Group","defaults","labelOffset","nameDirection","tickDirection","labelDirection","silent","handleAutoShown","transformGroup","x","position","y","rotation","updateTransform","_transformGroup","prototype","hasBuilder","name","builders","add","getGroup","innerTextLayout","axisRotation","textRotation","direction","rotationDiff","remRadian","textAlign","textVerticalAlign","isRadianAroundZero","makeAxisEventDataBase","eventData","componentType","mainType","componentIndex","isLabelSilent","tooltipOpt","get","show","axisLine","shown","extent","axis","getExtent","matrix","transform","pt1","pt2","applyTransform","lineStyle","extend","lineCap","getModel","getLineStyle","line","Line","subPixelOptimize","shape","x1","y1","x2","y2","style","strokeContainThreshold","z2","anid","arrows","arrowSize","arrowOffset","symbolWidth_1","symbolHeight_1","each","rotate","offset","r","sqrt","point","index","symbol","createSymbol","stroke","attr","cos","sin","axisTickLabel","ticksEls","buildAxisMajorTicks","labelEls","buildAxisLabel","fixMinMaxLabelShow","buildAxisMinorTicks","axisName","retrieve","nameLocation","textStyleModel","gap","gapSignal","pos","isNameLocationCenter","labelLayout","nameRotation","axisNameAvailableWidth","endTextLayout","abs","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","formatterParams","$vars","textEl","Text","createTextStyle","text","font","overflow","width","fill","getTextColor","align","verticalAlign","tooltip","content","formatter","__fullText","targetType","getECData","decomposeTransform","textPosition","textRotate","inverse","onLeft","tickEls","shouldShowAllLabels","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","length","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","el","ignore","current","next","firstRect","getBoundingRect","clone","nextRect","mRotationBack","identity","mul","getLocalTransform","intersect","createTicks","ticksCoords","tickTransform","tickEndCoord","tickLineStyle","anidPrefix","i","tickCoord","coord","tickEl","autoBatch","tickValue","push","tickModel","scale","isBlank","lineStyleModel","getTicksCoords","minorTickModel","minorTicksCoords","getMinorTicksCoords","minorTickLineStyle","minorTicksEls","k","axisLabelShow","labelModel","labelMargin","labels","getViewLabels","labelRotation","labelRotate","rawCategoryData","getCategories","triggerEvent","labelItem","type","getRawIndex","formattedLabel","rawLabel","itemLabelModel","rawCategoryItem","isObject","textStyle","ecModel","textColor","dataToCoord","getShallow","value"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AAEA,IAAIC,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIC,OAAO,GAAGD,OAAO,CAAC,oBAAD,CAArB;;AAEA,IAAIE,YAAY,GAAGF,OAAO,CAAC,uBAAD,CAA1B;;AAEA,IAAIG,YAAY,GAAGH,OAAO,CAAC,wBAAD,CAA1B;;AAEA,IAAII,OAAO,GAAGJ,OAAO,CAAC,mBAAD,CAArB;;AAEA,IAAIK,QAAQ,GAAGL,OAAO,CAAC,mBAAD,CAAtB;;AAEA,IAAIM,QAAQ,GAAGN,OAAO,CAAC,mBAAD,CAAtB;;AAEA,IAAIO,UAAU,GAAGP,OAAO,CAAC,yBAAD,CAAxB;;AAEA,IAAIQ,QAAQ,GAAGR,OAAO,CAAC,yBAAD,CAAtB;;AAEA,IAAIS,YAAY,GAAGT,OAAO,CAAC,wBAAD,CAA1B;;AAEA,IAAIU,EAAE,GAAGC,IAAI,CAACD,EAAd;;AAEA,IAAIE,WAAW,GAAG,YAAY;AAC5B,WAASA,WAAT,CAAqBC,SAArB,EAAgCC,GAAhC,EAAqC;AACnC,SAAKC,KAAL,GAAa,IAAId,OAAO,CAACe,KAAZ,EAAb;AACA,SAAKF,GAAL,GAAWA,GAAX;AACA,SAAKD,SAAL,GAAiBA,SAAjB;AACAd,IAAAA,MAAM,CAACkB,QAAP,CAAgBH,GAAhB,EAAqB;AACnBI,MAAAA,WAAW,EAAE,CADM;AAEnBC,MAAAA,aAAa,EAAE,CAFI;AAGnBC,MAAAA,aAAa,EAAE,CAHI;AAInBC,MAAAA,cAAc,EAAE,CAJG;AAKnBC,MAAAA,MAAM,EAAE,IALW;AAMnBC,MAAAA,eAAe,EAAE,YAAY;AAC3B,eAAO,IAAP;AACD;AARkB,KAArB;AAUA,QAAIC,cAAc,GAAG,IAAIvB,OAAO,CAACe,KAAZ,CAAkB;AACrCS,MAAAA,CAAC,EAAEX,GAAG,CAACY,QAAJ,CAAa,CAAb,CADkC;AAErCC,MAAAA,CAAC,EAAEb,GAAG,CAACY,QAAJ,CAAa,CAAb,CAFkC;AAGrCE,MAAAA,QAAQ,EAAEd,GAAG,CAACc;AAHuB,KAAlB,CAArB;AAKAJ,IAAAA,cAAc,CAACK,eAAf;AACA,SAAKC,eAAL,GAAuBN,cAAvB;AACD;;AAEDZ,EAAAA,WAAW,CAACmB,SAAZ,CAAsBC,UAAtB,GAAmC,UAAUC,IAAV,EAAgB;AACjD,WAAO,CAAC,CAACC,QAAQ,CAACD,IAAD,CAAjB;AACD,GAFD;;AAIArB,EAAAA,WAAW,CAACmB,SAAZ,CAAsBI,GAAtB,GAA4B,UAAUF,IAAV,EAAgB;AAC1CC,IAAAA,QAAQ,CAACD,IAAD,CAAR,CAAe,KAAKnB,GAApB,EAAyB,KAAKD,SAA9B,EAAyC,KAAKE,KAA9C,EAAqD,KAAKe,eAA1D;AACD,GAFD;;AAIAlB,EAAAA,WAAW,CAACmB,SAAZ,CAAsBK,QAAtB,GAAiC,YAAY;AAC3C,WAAO,KAAKrB,KAAZ;AACD,GAFD;;AAIAH,EAAAA,WAAW,CAACyB,eAAZ,GAA8B,UAAUC,YAAV,EAAwBC,YAAxB,EAAsCC,SAAtC,EAAiD;AAC7E,QAAIC,YAAY,GAAGpC,QAAQ,CAACqC,SAAT,CAAmBH,YAAY,GAAGD,YAAlC,CAAnB;AACA,QAAIK,SAAJ;AACA,QAAIC,iBAAJ;;AAEA,QAAIvC,QAAQ,CAACwC,kBAAT,CAA4BJ,YAA5B,CAAJ,EAA+C;AAC7CG,MAAAA,iBAAiB,GAAGJ,SAAS,GAAG,CAAZ,GAAgB,KAAhB,GAAwB,QAA5C;AACAG,MAAAA,SAAS,GAAG,QAAZ;AACD,KAHD,MAGO,IAAItC,QAAQ,CAACwC,kBAAT,CAA4BJ,YAAY,GAAG/B,EAA3C,CAAJ,EAAoD;AACzDkC,MAAAA,iBAAiB,GAAGJ,SAAS,GAAG,CAAZ,GAAgB,QAAhB,GAA2B,KAA/C;AACAG,MAAAA,SAAS,GAAG,QAAZ;AACD,KAHM,MAGA;AACLC,MAAAA,iBAAiB,GAAG,QAApB;;AAEA,UAAIH,YAAY,GAAG,CAAf,IAAoBA,YAAY,GAAG/B,EAAvC,EAA2C;AACzCiC,QAAAA,SAAS,GAAGH,SAAS,GAAG,CAAZ,GAAgB,OAAhB,GAA0B,MAAtC;AACD,OAFD,MAEO;AACLG,QAAAA,SAAS,GAAGH,SAAS,GAAG,CAAZ,GAAgB,MAAhB,GAAyB,OAArC;AACD;AACF;;AAED,WAAO;AACLZ,MAAAA,QAAQ,EAAEa,YADL;AAELE,MAAAA,SAAS,EAAEA,SAFN;AAGLC,MAAAA,iBAAiB,EAAEA;AAHd,KAAP;AAKD,GA1BD;;AA4BAhC,EAAAA,WAAW,CAACkC,qBAAZ,GAAoC,UAAUjC,SAAV,EAAqB;AACvD,QAAIkC,SAAS,GAAG;AACdC,MAAAA,aAAa,EAAEnC,SAAS,CAACoC,QADX;AAEdC,MAAAA,cAAc,EAAErC,SAAS,CAACqC;AAFZ,KAAhB;AAIAH,IAAAA,SAAS,CAAClC,SAAS,CAACoC,QAAV,GAAqB,OAAtB,CAAT,GAA0CpC,SAAS,CAACqC,cAApD;AACA,WAAOH,SAAP;AACD,GAPD;;AASAnC,EAAAA,WAAW,CAACuC,aAAZ,GAA4B,UAAUtC,SAAV,EAAqB;AAC/C,QAAIuC,UAAU,GAAGvC,SAAS,CAACwC,GAAV,CAAc,SAAd,CAAjB;AACA,WAAOxC,SAAS,CAACwC,GAAV,CAAc,QAAd,KAA2B,EAAExC,SAAS,CAACwC,GAAV,CAAc,cAAd,KAAiCD,UAAU,IAAIA,UAAU,CAACE,IAA5D,CAAlC;AACD,GAHD;;AAKA,SAAO1C,WAAP;AACD,CA/EiB,EAAlB;;AAiFA;AACA,IAAIsB,QAAQ,GAAG;AACbqB,EAAAA,QAAQ,EAAE,UAAUzC,GAAV,EAAeD,SAAf,EAA0BE,KAA1B,EAAiCS,cAAjC,EAAiD;AACzD,QAAIgC,KAAK,GAAG3C,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,MAAb,CAAd,CAAZ;;AAEA,QAAIG,KAAK,KAAK,MAAV,IAAoB1C,GAAG,CAACS,eAA5B,EAA6C;AAC3CiC,MAAAA,KAAK,GAAG1C,GAAG,CAACS,eAAJ,CAAoB,UAApB,CAAR;AACD;;AAED,QAAI,CAACiC,KAAL,EAAY;AACV;AACD;;AAED,QAAIC,MAAM,GAAG5C,SAAS,CAAC6C,IAAV,CAAeC,SAAf,EAAb;AACA,QAAIC,MAAM,GAAGpC,cAAc,CAACqC,SAA5B;AACA,QAAIC,GAAG,GAAG,CAACL,MAAM,CAAC,CAAD,CAAP,EAAY,CAAZ,CAAV;AACA,QAAIM,GAAG,GAAG,CAACN,MAAM,CAAC,CAAD,CAAP,EAAY,CAAZ,CAAV;;AAEA,QAAIG,MAAJ,EAAY;AACVpD,MAAAA,QAAQ,CAACwD,cAAT,CAAwBF,GAAxB,EAA6BA,GAA7B,EAAkCF,MAAlC;AACApD,MAAAA,QAAQ,CAACwD,cAAT,CAAwBD,GAAxB,EAA6BA,GAA7B,EAAkCH,MAAlC;AACD;;AAED,QAAIK,SAAS,GAAGlE,MAAM,CAACmE,MAAP,CAAc;AAC5BC,MAAAA,OAAO,EAAE;AADmB,KAAd,EAEbtD,SAAS,CAACuD,QAAV,CAAmB,CAAC,UAAD,EAAa,WAAb,CAAnB,EAA8CC,YAA9C,EAFa,CAAhB;AAGA,QAAIC,IAAI,GAAG,IAAIrE,OAAO,CAACsE,IAAZ,CAAiB;AAC1BC,MAAAA,gBAAgB,EAAE,IADQ;AAE1BC,MAAAA,KAAK,EAAE;AACLC,QAAAA,EAAE,EAAEZ,GAAG,CAAC,CAAD,CADF;AAELa,QAAAA,EAAE,EAAEb,GAAG,CAAC,CAAD,CAFF;AAGLc,QAAAA,EAAE,EAAEb,GAAG,CAAC,CAAD,CAHF;AAILc,QAAAA,EAAE,EAAEd,GAAG,CAAC,CAAD;AAJF,OAFmB;AAQ1Be,MAAAA,KAAK,EAAEb,SARmB;AAS1Bc,MAAAA,sBAAsB,EAAEjE,GAAG,CAACiE,sBAAJ,IAA8B,CAT5B;AAU1BzD,MAAAA,MAAM,EAAE,IAVkB;AAW1B0D,MAAAA,EAAE,EAAE;AAXsB,KAAjB,CAAX;AAaAV,IAAAA,IAAI,CAACW,IAAL,GAAY,MAAZ;AACAlE,IAAAA,KAAK,CAACoB,GAAN,CAAUmC,IAAV;AACA,QAAIY,MAAM,GAAGrE,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,QAAb,CAAd,CAAb;AACA,QAAI8B,SAAS,GAAGtE,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,YAAb,CAAd,CAAhB;AACA,QAAI+B,WAAW,GAAGvE,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,cAAb,CAAd,KAA+C,CAAjE;;AAEA,QAAI,OAAO+B,WAAP,KAAuB,QAA3B,EAAqC;AACnCA,MAAAA,WAAW,GAAG,CAACA,WAAD,EAAcA,WAAd,CAAd;AACD;;AAED,QAAIF,MAAM,IAAI,IAAd,EAAoB;AAClB,UAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,QAAAA,MAAM,GAAG,CAACA,MAAD,EAASA,MAAT,CAAT;AACD;;AAED,UAAI,OAAOC,SAAP,KAAqB,QAArB,IAAiC,OAAOA,SAAP,KAAqB,QAA1D,EAAoE;AAClEA,QAAAA,SAAS,GAAG,CAACA,SAAD,EAAYA,SAAZ,CAAZ;AACD;;AAED,UAAIE,aAAa,GAAGF,SAAS,CAAC,CAAD,CAA7B;AACA,UAAIG,cAAc,GAAGH,SAAS,CAAC,CAAD,CAA9B;AACApF,MAAAA,MAAM,CAACwF,IAAP,CAAY,CAAC;AACXC,QAAAA,MAAM,EAAE1E,GAAG,CAACc,QAAJ,GAAejB,IAAI,CAACD,EAAL,GAAU,CADtB;AAEX+E,QAAAA,MAAM,EAAEL,WAAW,CAAC,CAAD,CAFR;AAGXM,QAAAA,CAAC,EAAE;AAHQ,OAAD,EAIT;AACDF,QAAAA,MAAM,EAAE1E,GAAG,CAACc,QAAJ,GAAejB,IAAI,CAACD,EAAL,GAAU,CADhC;AAED+E,QAAAA,MAAM,EAAEL,WAAW,CAAC,CAAD,CAFlB;AAGDM,QAAAA,CAAC,EAAE/E,IAAI,CAACgF,IAAL,CAAU,CAAC7B,GAAG,CAAC,CAAD,CAAH,GAASC,GAAG,CAAC,CAAD,CAAb,KAAqBD,GAAG,CAAC,CAAD,CAAH,GAASC,GAAG,CAAC,CAAD,CAAjC,IAAwC,CAACD,GAAG,CAAC,CAAD,CAAH,GAASC,GAAG,CAAC,CAAD,CAAb,KAAqBD,GAAG,CAAC,CAAD,CAAH,GAASC,GAAG,CAAC,CAAD,CAAjC,CAAlD;AAHF,OAJS,CAAZ,EAQI,UAAU6B,KAAV,EAAiBC,KAAjB,EAAwB;AAC1B,YAAIX,MAAM,CAACW,KAAD,CAAN,KAAkB,MAAlB,IAA4BX,MAAM,CAACW,KAAD,CAAN,IAAiB,IAAjD,EAAuD;AACrD,cAAIC,MAAM,GAAGxF,QAAQ,CAACyF,YAAT,CAAsBb,MAAM,CAACW,KAAD,CAA5B,EAAqC,CAACR,aAAD,GAAiB,CAAtD,EAAyD,CAACC,cAAD,GAAkB,CAA3E,EAA8ED,aAA9E,EAA6FC,cAA7F,EAA6GrB,SAAS,CAAC+B,MAAvH,EAA+H,IAA/H,CAAb;AACA,cAAIN,CAAC,GAAGE,KAAK,CAACF,CAAN,GAAUE,KAAK,CAACH,MAAxB;AACAK,UAAAA,MAAM,CAACG,IAAP,CAAY;AACVrE,YAAAA,QAAQ,EAAEgE,KAAK,CAACJ,MADN;AAEV/D,YAAAA,CAAC,EAAEqC,GAAG,CAAC,CAAD,CAAH,GAAS4B,CAAC,GAAG/E,IAAI,CAACuF,GAAL,CAASpF,GAAG,CAACc,QAAb,CAFN;AAGVD,YAAAA,CAAC,EAAEmC,GAAG,CAAC,CAAD,CAAH,GAAS4B,CAAC,GAAG/E,IAAI,CAACwF,GAAL,CAASrF,GAAG,CAACc,QAAb,CAHN;AAIVN,YAAAA,MAAM,EAAE,IAJE;AAKV0D,YAAAA,EAAE,EAAE;AALM,WAAZ;AAOAjE,UAAAA,KAAK,CAACoB,GAAN,CAAU2D,MAAV;AACD;AACF,OArBD;AAsBD;AACF,GAlFY;AAmFbM,EAAAA,aAAa,EAAE,UAAUtF,GAAV,EAAeD,SAAf,EAA0BE,KAA1B,EAAiCS,cAAjC,EAAiD;AAC9D,QAAI6E,QAAQ,GAAGC,mBAAmB,CAACvF,KAAD,EAAQS,cAAR,EAAwBX,SAAxB,EAAmCC,GAAnC,CAAlC;AACA,QAAIyF,QAAQ,GAAGC,cAAc,CAACzF,KAAD,EAAQS,cAAR,EAAwBX,SAAxB,EAAmCC,GAAnC,CAA7B;AACA2F,IAAAA,kBAAkB,CAAC5F,SAAD,EAAY0F,QAAZ,EAAsBF,QAAtB,CAAlB;AACAK,IAAAA,mBAAmB,CAAC3F,KAAD,EAAQS,cAAR,EAAwBX,SAAxB,EAAmCC,GAAG,CAACM,aAAvC,CAAnB;AACD,GAxFY;AAyFbuF,EAAAA,QAAQ,EAAE,UAAU7F,GAAV,EAAeD,SAAf,EAA0BE,KAA1B,EAAiCS,cAAjC,EAAiD;AACzD,QAAIS,IAAI,GAAGlC,MAAM,CAAC6G,QAAP,CAAgB9F,GAAG,CAAC6F,QAApB,EAA8B9F,SAAS,CAACwC,GAAV,CAAc,MAAd,CAA9B,CAAX;;AAEA,QAAI,CAACpB,IAAL,EAAW;AACT;AACD;;AAED,QAAI4E,YAAY,GAAGhG,SAAS,CAACwC,GAAV,CAAc,cAAd,CAAnB;AACA,QAAIlC,aAAa,GAAGL,GAAG,CAACK,aAAxB;AACA,QAAI2F,cAAc,GAAGjG,SAAS,CAACuD,QAAV,CAAmB,eAAnB,CAArB;AACA,QAAI2C,GAAG,GAAGlG,SAAS,CAACwC,GAAV,CAAc,SAAd,KAA4B,CAAtC;AACA,QAAII,MAAM,GAAG5C,SAAS,CAAC6C,IAAV,CAAeC,SAAf,EAAb;AACA,QAAIqD,SAAS,GAAGvD,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAlB,GAAwB,CAAC,CAAzB,GAA6B,CAA7C;AACA,QAAIwD,GAAG,GAAG,CAACJ,YAAY,KAAK,OAAjB,GAA2BpD,MAAM,CAAC,CAAD,CAAN,GAAYuD,SAAS,GAAGD,GAAnD,GAAyDF,YAAY,KAAK,KAAjB,GAAyBpD,MAAM,CAAC,CAAD,CAAN,GAAYuD,SAAS,GAAGD,GAAjD,GAAuD,CAACtD,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAnB,IAA0B,CAA3I,EAA8IyD,oBAAoB,CAACL,YAAD,CAApB,GAAqC/F,GAAG,CAACI,WAAJ,GAAkBC,aAAa,GAAG4F,GAAvE,GAA6E,CAA3N,CAAV;AACA,QAAII,WAAJ;AACA,QAAIC,YAAY,GAAGvG,SAAS,CAACwC,GAAV,CAAc,YAAd,CAAnB;;AAEA,QAAI+D,YAAY,IAAI,IAApB,EAA0B;AACxBA,MAAAA,YAAY,GAAGA,YAAY,GAAG1G,EAAf,GAAoB,GAAnC;AACD;;AAED,QAAI2G,sBAAJ;;AAEA,QAAIH,oBAAoB,CAACL,YAAD,CAAxB,EAAwC;AACtCM,MAAAA,WAAW,GAAGvG,WAAW,CAACyB,eAAZ,CAA4BvB,GAAG,CAACc,QAAhC,EAA0CwF,YAAY,IAAI,IAAhB,GAAuBA,YAAvB,GAAsCtG,GAAG,CAACc,QAApF,EAA8FT,aAA9F,CAAd;AACD,KAFD,MAEO;AACLgG,MAAAA,WAAW,GAAGG,aAAa,CAACxG,GAAG,CAACc,QAAL,EAAeiF,YAAf,EAA6BO,YAAY,IAAI,CAA7C,EAAgD3D,MAAhD,CAA3B;AACA4D,MAAAA,sBAAsB,GAAGvG,GAAG,CAACuG,sBAA7B;;AAEA,UAAIA,sBAAsB,IAAI,IAA9B,EAAoC;AAClCA,QAAAA,sBAAsB,GAAG1G,IAAI,CAAC4G,GAAL,CAASF,sBAAsB,GAAG1G,IAAI,CAACwF,GAAL,CAASgB,WAAW,CAACvF,QAArB,CAAlC,CAAzB;AACA,SAAC4F,QAAQ,CAACH,sBAAD,CAAT,KAAsCA,sBAAsB,GAAG,IAA/D;AACD;AACF;;AAED,QAAII,QAAQ,GAAGX,cAAc,CAACY,OAAf,EAAf;AACA,QAAIC,WAAW,GAAG9G,SAAS,CAACwC,GAAV,CAAc,cAAd,EAA8B,IAA9B,KAAuC,EAAzD;AACA,QAAIuE,QAAQ,GAAGD,WAAW,CAACC,QAA3B;AACA,QAAIC,QAAQ,GAAG9H,MAAM,CAAC6G,QAAP,CAAgB9F,GAAG,CAACgH,oBAApB,EAA0CH,WAAW,CAACE,QAAtD,EAAgER,sBAAhE,CAAf;AACA,QAAIjE,UAAU,GAAGvC,SAAS,CAACwC,GAAV,CAAc,SAAd,EAAyB,IAAzB,CAAjB;AACA,QAAIJ,QAAQ,GAAGpC,SAAS,CAACoC,QAAzB;AACA,QAAI8E,eAAe,GAAG;AACpB/E,MAAAA,aAAa,EAAEC,QADK;AAEpBhB,MAAAA,IAAI,EAAEA,IAFc;AAGpB+F,MAAAA,KAAK,EAAE,CAAC,MAAD;AAHa,KAAtB;AAKAD,IAAAA,eAAe,CAAC9E,QAAQ,GAAG,OAAZ,CAAf,GAAsCpC,SAAS,CAACqC,cAAhD;AACA,QAAI+E,MAAM,GAAG,IAAIhI,OAAO,CAACiI,IAAZ,CAAiB;AAC5BzG,MAAAA,CAAC,EAAEwF,GAAG,CAAC,CAAD,CADsB;AAE5BtF,MAAAA,CAAC,EAAEsF,GAAG,CAAC,CAAD,CAFsB;AAG5BrF,MAAAA,QAAQ,EAAEuF,WAAW,CAACvF,QAHM;AAI5BN,MAAAA,MAAM,EAAEV,WAAW,CAACuC,aAAZ,CAA0BtC,SAA1B,CAJoB;AAK5BiE,MAAAA,KAAK,EAAE3E,YAAY,CAACgI,eAAb,CAA6BrB,cAA7B,EAA6C;AAClDsB,QAAAA,IAAI,EAAEnG,IAD4C;AAElDoG,QAAAA,IAAI,EAAEZ,QAF4C;AAGlDa,QAAAA,QAAQ,EAAE,UAHwC;AAIlDC,QAAAA,KAAK,EAAEV,QAJ2C;AAKlDD,QAAAA,QAAQ,EAAEA,QALwC;AAMlDY,QAAAA,IAAI,EAAE1B,cAAc,CAAC2B,YAAf,MAAiC5H,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,WAAb,EAA0B,OAA1B,CAAd,CANW;AAOlDqF,QAAAA,KAAK,EAAE5B,cAAc,CAACzD,GAAf,CAAmB,OAAnB,KAA+B8D,WAAW,CAACxE,SAPA;AAQlDgG,QAAAA,aAAa,EAAE7B,cAAc,CAACzD,GAAf,CAAmB,eAAnB,KAAuC8D,WAAW,CAACvE;AARhB,OAA7C,CALqB;AAe5BoC,MAAAA,EAAE,EAAE;AAfwB,KAAjB,CAAb;AAiBAiD,IAAAA,MAAM,CAACW,OAAP,GAAiBxF,UAAU,IAAIA,UAAU,CAACE,IAAzB,GAAgCvD,MAAM,CAACmE,MAAP,CAAc;AAC7D2E,MAAAA,OAAO,EAAE5G,IADoD;AAE7D6G,MAAAA,SAAS,EAAE,YAAY;AACrB,eAAO7G,IAAP;AACD,OAJ4D;AAK7D8F,MAAAA,eAAe,EAAEA;AAL4C,KAAd,EAM9C3E,UAN8C,CAAhC,GAMA,IANjB;AAOA6E,IAAAA,MAAM,CAACc,UAAP,GAAoB9G,IAApB;AACAgG,IAAAA,MAAM,CAAChD,IAAP,GAAc,MAAd;;AAEA,QAAIpE,SAAS,CAACwC,GAAV,CAAc,cAAd,CAAJ,EAAmC;AACjC,UAAIN,SAAS,GAAGnC,WAAW,CAACkC,qBAAZ,CAAkCjC,SAAlC,CAAhB;AACAkC,MAAAA,SAAS,CAACiG,UAAV,GAAuB,UAAvB;AACAjG,MAAAA,SAAS,CAACd,IAAV,GAAiBA,IAAjB;AACA/B,MAAAA,YAAY,CAAC+I,SAAb,CAAuBhB,MAAvB,EAA+BlF,SAA/B,GAA2CA,SAA3C;AACD;;AAEDvB,IAAAA,cAAc,CAACW,GAAf,CAAmB8F,MAAnB;AACAA,IAAAA,MAAM,CAACpG,eAAP;AACAd,IAAAA,KAAK,CAACoB,GAAN,CAAU8F,MAAV;AACAA,IAAAA,MAAM,CAACiB,kBAAP;AACD;AA9KY,CAAf;;AAiLA,SAAS5B,aAAT,CAAuB1F,QAAvB,EAAiCuH,YAAjC,EAA+CC,UAA/C,EAA2D3F,MAA3D,EAAmE;AACjE,MAAIhB,YAAY,GAAGpC,QAAQ,CAACqC,SAAT,CAAmB0G,UAAU,GAAGxH,QAAhC,CAAnB;AACA,MAAIe,SAAJ;AACA,MAAIC,iBAAJ;AACA,MAAIyG,OAAO,GAAG5F,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAAhC;AACA,MAAI6F,MAAM,GAAGH,YAAY,KAAK,OAAjB,IAA4B,CAACE,OAA7B,IAAwCF,YAAY,KAAK,OAAjB,IAA4BE,OAAjF;;AAEA,MAAIhJ,QAAQ,CAACwC,kBAAT,CAA4BJ,YAAY,GAAG/B,EAAE,GAAG,CAAhD,CAAJ,EAAwD;AACtDkC,IAAAA,iBAAiB,GAAG0G,MAAM,GAAG,QAAH,GAAc,KAAxC;AACA3G,IAAAA,SAAS,GAAG,QAAZ;AACD,GAHD,MAGO,IAAItC,QAAQ,CAACwC,kBAAT,CAA4BJ,YAAY,GAAG/B,EAAE,GAAG,GAAhD,CAAJ,EAA0D;AAC/DkC,IAAAA,iBAAiB,GAAG0G,MAAM,GAAG,KAAH,GAAW,QAArC;AACA3G,IAAAA,SAAS,GAAG,QAAZ;AACD,GAHM,MAGA;AACLC,IAAAA,iBAAiB,GAAG,QAApB;;AAEA,QAAIH,YAAY,GAAG/B,EAAE,GAAG,GAApB,IAA2B+B,YAAY,GAAG/B,EAAE,GAAG,CAAnD,EAAsD;AACpDiC,MAAAA,SAAS,GAAG2G,MAAM,GAAG,MAAH,GAAY,OAA9B;AACD,KAFD,MAEO;AACL3G,MAAAA,SAAS,GAAG2G,MAAM,GAAG,OAAH,GAAa,MAA/B;AACD;AACF;;AAED,SAAO;AACL1H,IAAAA,QAAQ,EAAEa,YADL;AAELE,IAAAA,SAAS,EAAEA,SAFN;AAGLC,IAAAA,iBAAiB,EAAEA;AAHd,GAAP;AAKD;;AAED,SAAS6D,kBAAT,CAA4B5F,SAA5B,EAAuC0F,QAAvC,EAAiDgD,OAAjD,EAA0D;AACxD,MAAI9I,YAAY,CAAC+I,mBAAb,CAAiC3I,SAAS,CAAC6C,IAA3C,CAAJ,EAAsD;AACpD;AACD;;AAED,MAAI+F,YAAY,GAAG5I,SAAS,CAACwC,GAAV,CAAc,CAAC,WAAD,EAAc,cAAd,CAAd,CAAnB;AACA,MAAIqG,YAAY,GAAG7I,SAAS,CAACwC,GAAV,CAAc,CAAC,WAAD,EAAc,cAAd,CAAd,CAAnB;AACAkD,EAAAA,QAAQ,GAAGA,QAAQ,IAAI,EAAvB;AACAgD,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAII,UAAU,GAAGpD,QAAQ,CAAC,CAAD,CAAzB;AACA,MAAIqD,SAAS,GAAGrD,QAAQ,CAAC,CAAD,CAAxB;AACA,MAAIsD,SAAS,GAAGtD,QAAQ,CAACA,QAAQ,CAACuD,MAAT,GAAkB,CAAnB,CAAxB;AACA,MAAIC,SAAS,GAAGxD,QAAQ,CAACA,QAAQ,CAACuD,MAAT,GAAkB,CAAnB,CAAxB;AACA,MAAIE,SAAS,GAAGT,OAAO,CAAC,CAAD,CAAvB;AACA,MAAIU,QAAQ,GAAGV,OAAO,CAAC,CAAD,CAAtB;AACA,MAAIW,QAAQ,GAAGX,OAAO,CAACA,OAAO,CAACO,MAAR,GAAiB,CAAlB,CAAtB;AACA,MAAIK,QAAQ,GAAGZ,OAAO,CAACA,OAAO,CAACO,MAAR,GAAiB,CAAlB,CAAtB;;AAEA,MAAIL,YAAY,KAAK,KAArB,EAA4B;AAC1BW,IAAAA,QAAQ,CAACT,UAAD,CAAR;AACAS,IAAAA,QAAQ,CAACJ,SAAD,CAAR;AACD,GAHD,MAGO,IAAIK,oBAAoB,CAACV,UAAD,EAAaC,SAAb,CAAxB,EAAiD;AACtD,QAAIH,YAAJ,EAAkB;AAChBW,MAAAA,QAAQ,CAACR,SAAD,CAAR;AACAQ,MAAAA,QAAQ,CAACH,QAAD,CAAR;AACD,KAHD,MAGO;AACLG,MAAAA,QAAQ,CAACT,UAAD,CAAR;AACAS,MAAAA,QAAQ,CAACJ,SAAD,CAAR;AACD;AACF;;AAED,MAAIN,YAAY,KAAK,KAArB,EAA4B;AAC1BU,IAAAA,QAAQ,CAACP,SAAD,CAAR;AACAO,IAAAA,QAAQ,CAACF,QAAD,CAAR;AACD,GAHD,MAGO,IAAIG,oBAAoB,CAACN,SAAD,EAAYF,SAAZ,CAAxB,EAAgD;AACrD,QAAIH,YAAJ,EAAkB;AAChBU,MAAAA,QAAQ,CAACL,SAAD,CAAR;AACAK,MAAAA,QAAQ,CAACD,QAAD,CAAR;AACD,KAHD,MAGO;AACLC,MAAAA,QAAQ,CAACP,SAAD,CAAR;AACAO,MAAAA,QAAQ,CAACF,QAAD,CAAR;AACD;AACF;AACF;;AAED,SAASE,QAAT,CAAkBE,EAAlB,EAAsB;AACpBA,EAAAA,EAAE,KAAKA,EAAE,CAACC,MAAH,GAAY,IAAjB,CAAF;AACD;;AAED,SAASF,oBAAT,CAA8BG,OAA9B,EAAuCC,IAAvC,EAA6C;AAC3C,MAAIC,SAAS,GAAGF,OAAO,IAAIA,OAAO,CAACG,eAAR,GAA0BC,KAA1B,EAA3B;AACA,MAAIC,QAAQ,GAAGJ,IAAI,IAAIA,IAAI,CAACE,eAAL,GAAuBC,KAAvB,EAAvB;;AAEA,MAAI,CAACF,SAAD,IAAc,CAACG,QAAnB,EAA6B;AAC3B;AACD;;AAED,MAAIC,aAAa,GAAGvK,UAAU,CAACwK,QAAX,CAAoB,EAApB,CAApB;AACAxK,EAAAA,UAAU,CAACiF,MAAX,CAAkBsF,aAAlB,EAAiCA,aAAjC,EAAgD,CAACN,OAAO,CAAC5I,QAAzD;AACA8I,EAAAA,SAAS,CAAC1G,cAAV,CAAyBzD,UAAU,CAACyK,GAAX,CAAe,EAAf,EAAmBF,aAAnB,EAAkCN,OAAO,CAACS,iBAAR,EAAlC,CAAzB;AACAJ,EAAAA,QAAQ,CAAC7G,cAAT,CAAwBzD,UAAU,CAACyK,GAAX,CAAe,EAAf,EAAmBF,aAAnB,EAAkCL,IAAI,CAACQ,iBAAL,EAAlC,CAAxB;AACA,SAAOP,SAAS,CAACQ,SAAV,CAAoBL,QAApB,CAAP;AACD;;AAED,SAAS3D,oBAAT,CAA8BL,YAA9B,EAA4C;AAC1C,SAAOA,YAAY,KAAK,QAAjB,IAA6BA,YAAY,KAAK,QAArD;AACD;;AAED,SAASsE,WAAT,CAAqBC,WAArB,EAAkCC,aAAlC,EAAiDC,YAAjD,EAA+DC,aAA/D,EAA8EC,UAA9E,EAA0F;AACxF,MAAIjC,OAAO,GAAG,EAAd;AACA,MAAIzF,GAAG,GAAG,EAAV;AACA,MAAIC,GAAG,GAAG,EAAV;;AAEA,OAAK,IAAI0H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,WAAW,CAACtB,MAAhC,EAAwC2B,CAAC,EAAzC,EAA6C;AAC3C,QAAIC,SAAS,GAAGN,WAAW,CAACK,CAAD,CAAX,CAAeE,KAA/B;AACA7H,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAS4H,SAAT;AACA5H,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAS,CAAT;AACAC,IAAAA,GAAG,CAAC,CAAD,CAAH,GAAS2H,SAAT;AACA3H,IAAAA,GAAG,CAAC,CAAD,CAAH,GAASuH,YAAT;;AAEA,QAAID,aAAJ,EAAmB;AACjB7K,MAAAA,QAAQ,CAACwD,cAAT,CAAwBF,GAAxB,EAA6BA,GAA7B,EAAkCuH,aAAlC;AACA7K,MAAAA,QAAQ,CAACwD,cAAT,CAAwBD,GAAxB,EAA6BA,GAA7B,EAAkCsH,aAAlC;AACD;;AAED,QAAIO,MAAM,GAAG,IAAI3L,OAAO,CAACsE,IAAZ,CAAiB;AAC5BC,MAAAA,gBAAgB,EAAE,IADU;AAE5BC,MAAAA,KAAK,EAAE;AACLC,QAAAA,EAAE,EAAEZ,GAAG,CAAC,CAAD,CADF;AAELa,QAAAA,EAAE,EAAEb,GAAG,CAAC,CAAD,CAFF;AAGLc,QAAAA,EAAE,EAAEb,GAAG,CAAC,CAAD,CAHF;AAILc,QAAAA,EAAE,EAAEd,GAAG,CAAC,CAAD;AAJF,OAFqB;AAQ5Be,MAAAA,KAAK,EAAEyG,aARqB;AAS5BvG,MAAAA,EAAE,EAAE,CATwB;AAU5B6G,MAAAA,SAAS,EAAE,IAViB;AAW5BvK,MAAAA,MAAM,EAAE;AAXoB,KAAjB,CAAb;AAaAsK,IAAAA,MAAM,CAAC3G,IAAP,GAAcuG,UAAU,GAAG,GAAb,GAAmBJ,WAAW,CAACK,CAAD,CAAX,CAAeK,SAAhD;AACAvC,IAAAA,OAAO,CAACwC,IAAR,CAAaH,MAAb;AACD;;AAED,SAAOrC,OAAP;AACD;;AAED,SAASjD,mBAAT,CAA6BvF,KAA7B,EAAoCS,cAApC,EAAoDX,SAApD,EAA+DC,GAA/D,EAAoE;AAClE,MAAI4C,IAAI,GAAG7C,SAAS,CAAC6C,IAArB;AACA,MAAIsI,SAAS,GAAGnL,SAAS,CAACuD,QAAV,CAAmB,UAAnB,CAAhB;AACA,MAAIZ,KAAK,GAAGwI,SAAS,CAAC3I,GAAV,CAAc,MAAd,CAAZ;;AAEA,MAAIG,KAAK,KAAK,MAAV,IAAoB1C,GAAG,CAACS,eAA5B,EAA6C;AAC3CiC,IAAAA,KAAK,GAAG1C,GAAG,CAACS,eAAJ,CAAoB,UAApB,CAAR;AACD;;AAED,MAAI,CAACiC,KAAD,IAAUE,IAAI,CAACuI,KAAL,CAAWC,OAAX,EAAd,EAAoC;AAClC;AACD;;AAED,MAAIC,cAAc,GAAGH,SAAS,CAAC5H,QAAV,CAAmB,WAAnB,CAArB;AACA,MAAIkH,YAAY,GAAGxK,GAAG,CAACM,aAAJ,GAAoB4K,SAAS,CAAC3I,GAAV,CAAc,QAAd,CAAvC;AACA,MAAI+H,WAAW,GAAG1H,IAAI,CAAC0I,cAAL,EAAlB;AACA,MAAI/F,QAAQ,GAAG8E,WAAW,CAACC,WAAD,EAAc5J,cAAc,CAACqC,SAA7B,EAAwCyH,YAAxC,EAAsDvL,MAAM,CAACkB,QAAP,CAAgBkL,cAAc,CAAC9H,YAAf,EAAhB,EAA+C;AAC7H2B,IAAAA,MAAM,EAAEnF,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,WAAb,EAA0B,OAA1B,CAAd;AADqH,GAA/C,CAAtD,EAEtB,OAFsB,CAA1B;;AAIA,OAAK,IAAIoI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpF,QAAQ,CAACyD,MAA7B,EAAqC2B,CAAC,EAAtC,EAA0C;AACxC1K,IAAAA,KAAK,CAACoB,GAAN,CAAUkE,QAAQ,CAACoF,CAAD,CAAlB;AACD;;AAED,SAAOpF,QAAP;AACD;;AAED,SAASK,mBAAT,CAA6B3F,KAA7B,EAAoCS,cAApC,EAAoDX,SAApD,EAA+DO,aAA/D,EAA8E;AAC5E,MAAIsC,IAAI,GAAG7C,SAAS,CAAC6C,IAArB;AACA,MAAI2I,cAAc,GAAGxL,SAAS,CAACuD,QAAV,CAAmB,WAAnB,CAArB;;AAEA,MAAI,CAACiI,cAAc,CAAChJ,GAAf,CAAmB,MAAnB,CAAD,IAA+BK,IAAI,CAACuI,KAAL,CAAWC,OAAX,EAAnC,EAAyD;AACvD;AACD;;AAED,MAAII,gBAAgB,GAAG5I,IAAI,CAAC6I,mBAAL,EAAvB;;AAEA,MAAI,CAACD,gBAAgB,CAACxC,MAAtB,EAA8B;AAC5B;AACD;;AAED,MAAIqC,cAAc,GAAGE,cAAc,CAACjI,QAAf,CAAwB,WAAxB,CAArB;AACA,MAAIkH,YAAY,GAAGlK,aAAa,GAAGiL,cAAc,CAAChJ,GAAf,CAAmB,QAAnB,CAAnC;AACA,MAAImJ,kBAAkB,GAAGzM,MAAM,CAACkB,QAAP,CAAgBkL,cAAc,CAAC9H,YAAf,EAAhB,EAA+CtE,MAAM,CAACkB,QAAP,CAAgBJ,SAAS,CAACuD,QAAV,CAAmB,UAAnB,EAA+BC,YAA/B,EAAhB,EAA+D;AACrI2B,IAAAA,MAAM,EAAEnF,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,WAAb,EAA0B,OAA1B,CAAd;AAD6H,GAA/D,CAA/C,CAAzB;;AAIA,OAAK,IAAIoI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGa,gBAAgB,CAACxC,MAArC,EAA6C2B,CAAC,EAA9C,EAAkD;AAChD,QAAIgB,aAAa,GAAGtB,WAAW,CAACmB,gBAAgB,CAACb,CAAD,CAAjB,EAAsBjK,cAAc,CAACqC,SAArC,EAAgDyH,YAAhD,EAA8DkB,kBAA9D,EAAkF,gBAAgBf,CAAlG,CAA/B;;AAEA,SAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,aAAa,CAAC3C,MAAlC,EAA0C4C,CAAC,EAA3C,EAA+C;AAC7C3L,MAAAA,KAAK,CAACoB,GAAN,CAAUsK,aAAa,CAACC,CAAD,CAAvB;AACD;AACF;AACF;;AAED,SAASlG,cAAT,CAAwBzF,KAAxB,EAA+BS,cAA/B,EAA+CX,SAA/C,EAA0DC,GAA1D,EAA+D;AAC7D,MAAI4C,IAAI,GAAG7C,SAAS,CAAC6C,IAArB;AACA,MAAIJ,IAAI,GAAGvD,MAAM,CAAC6G,QAAP,CAAgB9F,GAAG,CAAC6L,aAApB,EAAmC9L,SAAS,CAACwC,GAAV,CAAc,CAAC,WAAD,EAAc,MAAd,CAAd,CAAnC,CAAX;;AAEA,MAAI,CAACC,IAAD,IAASI,IAAI,CAACuI,KAAL,CAAWC,OAAX,EAAb,EAAmC;AACjC;AACD;;AAED,MAAIU,UAAU,GAAG/L,SAAS,CAACuD,QAAV,CAAmB,WAAnB,CAAjB;AACA,MAAIyI,WAAW,GAAGD,UAAU,CAACvJ,GAAX,CAAe,QAAf,CAAlB;AACA,MAAIyJ,MAAM,GAAGpJ,IAAI,CAACqJ,aAAL,EAAb;AACA,MAAIC,aAAa,GAAG,CAACjN,MAAM,CAAC6G,QAAP,CAAgB9F,GAAG,CAACmM,WAApB,EAAiCL,UAAU,CAACvJ,GAAX,CAAe,QAAf,CAAjC,KAA8D,CAA/D,IAAoE3C,EAApE,GAAyE,GAA7F;AACA,MAAIyG,WAAW,GAAGvG,WAAW,CAACyB,eAAZ,CAA4BvB,GAAG,CAACc,QAAhC,EAA0CoL,aAA1C,EAAyDlM,GAAG,CAACO,cAA7D,CAAlB;AACA,MAAI6L,eAAe,GAAGrM,SAAS,CAACsM,aAAV,IAA2BtM,SAAS,CAACsM,aAAV,CAAwB,IAAxB,CAAjD;AACA,MAAI5G,QAAQ,GAAG,EAAf;AACA,MAAIjF,MAAM,GAAGV,WAAW,CAACuC,aAAZ,CAA0BtC,SAA1B,CAAb;AACA,MAAIuM,YAAY,GAAGvM,SAAS,CAACwC,GAAV,CAAc,cAAd,CAAnB;AACAtD,EAAAA,MAAM,CAACwF,IAAP,CAAYuH,MAAZ,EAAoB,UAAUO,SAAV,EAAqBxH,KAArB,EAA4B;AAC9C,QAAIiG,SAAS,GAAGpI,IAAI,CAACuI,KAAL,CAAWqB,IAAX,KAAoB,SAApB,GAAgC5J,IAAI,CAACuI,KAAL,CAAWsB,WAAX,CAAuBF,SAAS,CAACvB,SAAjC,CAAhC,GAA8EuB,SAAS,CAACvB,SAAxG;AACA,QAAI0B,cAAc,GAAGH,SAAS,CAACG,cAA/B;AACA,QAAIC,QAAQ,GAAGJ,SAAS,CAACI,QAAzB;AACA,QAAIC,cAAc,GAAGd,UAArB;;AAEA,QAAIM,eAAe,IAAIA,eAAe,CAACpB,SAAD,CAAtC,EAAmD;AACjD,UAAI6B,eAAe,GAAGT,eAAe,CAACpB,SAAD,CAArC;;AAEA,UAAI/L,MAAM,CAAC6N,QAAP,CAAgBD,eAAhB,KAAoCA,eAAe,CAACE,SAAxD,EAAmE;AACjEH,QAAAA,cAAc,GAAG,IAAItN,OAAO,CAAC,SAAD,CAAX,CAAuBuN,eAAe,CAACE,SAAvC,EAAkDjB,UAAlD,EAA8D/L,SAAS,CAACiN,OAAxE,CAAjB;AACD;AACF;;AAED,QAAIC,SAAS,GAAGL,cAAc,CAACjF,YAAf,MAAiC5H,SAAS,CAACwC,GAAV,CAAc,CAAC,UAAD,EAAa,WAAb,EAA0B,OAA1B,CAAd,CAAjD;AACA,QAAIqI,SAAS,GAAGhI,IAAI,CAACsK,WAAL,CAAiBlC,SAAjB,CAAhB;AACA,QAAI7D,MAAM,GAAG,IAAIhI,OAAO,CAACiI,IAAZ,CAAiB;AAC5BzG,MAAAA,CAAC,EAAEiK,SADyB;AAE5B/J,MAAAA,CAAC,EAAEb,GAAG,CAACI,WAAJ,GAAkBJ,GAAG,CAACO,cAAJ,GAAqBwL,WAFd;AAG5BjL,MAAAA,QAAQ,EAAEuF,WAAW,CAACvF,QAHM;AAI5BN,MAAAA,MAAM,EAAEA,MAJoB;AAK5B0D,MAAAA,EAAE,EAAE,EALwB;AAM5BF,MAAAA,KAAK,EAAE3E,YAAY,CAACgI,eAAb,CAA6BuF,cAA7B,EAA6C;AAClDtF,QAAAA,IAAI,EAAEoF,cAD4C;AAElD9E,QAAAA,KAAK,EAAEgF,cAAc,CAACO,UAAf,CAA0B,OAA1B,EAAmC,IAAnC,KAA4C9G,WAAW,CAACxE,SAFb;AAGlDgG,QAAAA,aAAa,EAAE+E,cAAc,CAACO,UAAf,CAA0B,eAA1B,EAA2C,IAA3C,KAAoDP,cAAc,CAACO,UAAf,CAA0B,UAA1B,EAAsC,IAAtC,CAApD,IAAmG9G,WAAW,CAACvE,iBAH5E;AAIlD4F,QAAAA,IAAI,EAAE,OAAOuF,SAAP,KAAqB,UAArB,GAAkCA,SAAS,CAACrK,IAAI,CAAC4J,IAAL,KAAc,UAAd,GAA2BG,QAA3B,GAAsC/J,IAAI,CAAC4J,IAAL,KAAc,OAAd,GAAwBxB,SAAS,GAAG,EAApC,GAAyCA,SAAhF,EAA2FjG,KAA3F,CAA3C,GAA+IkI;AAJnG,OAA7C;AANqB,KAAjB,CAAb;AAaA9F,IAAAA,MAAM,CAAChD,IAAP,GAAc,WAAW6G,SAAzB;;AAEA,QAAIsB,YAAJ,EAAkB;AAChB,UAAIrK,SAAS,GAAGnC,WAAW,CAACkC,qBAAZ,CAAkCjC,SAAlC,CAAhB;AACAkC,MAAAA,SAAS,CAACiG,UAAV,GAAuB,WAAvB;AACAjG,MAAAA,SAAS,CAACmL,KAAV,GAAkBT,QAAlB;AACAvN,MAAAA,YAAY,CAAC+I,SAAb,CAAuBhB,MAAvB,EAA+BlF,SAA/B,GAA2CA,SAA3C;AACD;;AAEDvB,IAAAA,cAAc,CAACW,GAAf,CAAmB8F,MAAnB;AACAA,IAAAA,MAAM,CAACpG,eAAP;AACA0E,IAAAA,QAAQ,CAACwF,IAAT,CAAc9D,MAAd;AACAlH,IAAAA,KAAK,CAACoB,GAAN,CAAU8F,MAAV;AACAA,IAAAA,MAAM,CAACiB,kBAAP;AACD,GA3CD;AA4CA,SAAO3C,QAAP;AACD;;AAED1G,OAAO,CAAC,SAAD,CAAP,GAAqBe,WAArB","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar innerStore_1 = require(\"../../util/innerStore\");\n\nvar labelStyle_1 = require(\"../../label/labelStyle\");\n\nvar Model_1 = require(\"../../model/Model\");\n\nvar number_1 = require(\"../../util/number\");\n\nvar symbol_1 = require(\"../../util/symbol\");\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar vector_1 = require(\"zrender/lib/core/vector\");\n\nvar axisHelper_1 = require(\"../../coord/axisHelper\");\n\nvar PI = Math.PI;\n\nvar AxisBuilder = function () {\n  function AxisBuilder(axisModel, opt) {\n    this.group = new graphic.Group();\n    this.opt = opt;\n    this.axisModel = axisModel;\n    util_1.defaults(opt, {\n      labelOffset: 0,\n      nameDirection: 1,\n      tickDirection: 1,\n      labelDirection: 1,\n      silent: true,\n      handleAutoShown: function () {\n        return true;\n      }\n    });\n    var transformGroup = new graphic.Group({\n      x: opt.position[0],\n      y: opt.position[1],\n      rotation: opt.rotation\n    });\n    transformGroup.updateTransform();\n    this._transformGroup = transformGroup;\n  }\n\n  AxisBuilder.prototype.hasBuilder = function (name) {\n    return !!builders[name];\n  };\n\n  AxisBuilder.prototype.add = function (name) {\n    builders[name](this.opt, this.axisModel, this.group, this._transformGroup);\n  };\n\n  AxisBuilder.prototype.getGroup = function () {\n    return this.group;\n  };\n\n  AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n    var rotationDiff = number_1.remRadian(textRotation - axisRotation);\n    var textAlign;\n    var textVerticalAlign;\n\n    if (number_1.isRadianAroundZero(rotationDiff)) {\n      textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n      textAlign = 'center';\n    } else if (number_1.isRadianAroundZero(rotationDiff - PI)) {\n      textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n      textAlign = 'center';\n    } else {\n      textVerticalAlign = 'middle';\n\n      if (rotationDiff > 0 && rotationDiff < PI) {\n        textAlign = direction > 0 ? 'right' : 'left';\n      } else {\n        textAlign = direction > 0 ? 'left' : 'right';\n      }\n    }\n\n    return {\n      rotation: rotationDiff,\n      textAlign: textAlign,\n      textVerticalAlign: textVerticalAlign\n    };\n  };\n\n  AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n    var eventData = {\n      componentType: axisModel.mainType,\n      componentIndex: axisModel.componentIndex\n    };\n    eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n    return eventData;\n  };\n\n  AxisBuilder.isLabelSilent = function (axisModel) {\n    var tooltipOpt = axisModel.get('tooltip');\n    return axisModel.get('silent') || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n  };\n\n  return AxisBuilder;\n}();\n\n;\nvar builders = {\n  axisLine: function (opt, axisModel, group, transformGroup) {\n    var shown = axisModel.get(['axisLine', 'show']);\n\n    if (shown === 'auto' && opt.handleAutoShown) {\n      shown = opt.handleAutoShown('axisLine');\n    }\n\n    if (!shown) {\n      return;\n    }\n\n    var extent = axisModel.axis.getExtent();\n    var matrix = transformGroup.transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      vector_1.applyTransform(pt1, pt1, matrix);\n      vector_1.applyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = util_1.extend({\n      lineCap: 'round'\n    }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle());\n    var line = new graphic.Line({\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    });\n    line.anid = 'line';\n    group.add(line);\n    var arrows = axisModel.get(['axisLine', 'symbol']);\n    var arrowSize = axisModel.get(['axisLine', 'symbolSize']);\n    var arrowOffset = axisModel.get(['axisLine', 'symbolOffset']) || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth_1 = arrowSize[0];\n      var symbolHeight_1 = arrowSize[1];\n      util_1.each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = symbol_1.createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true);\n          var r = point.r + point.offset;\n          symbol.attr({\n            rotation: point.rotate,\n            x: pt1[0] + r * Math.cos(opt.rotation),\n            y: pt1[1] - r * Math.sin(opt.rotation),\n            silent: true,\n            z2: 11\n          });\n          group.add(symbol);\n        }\n      });\n    }\n  },\n  axisTickLabel: function (opt, axisModel, group, transformGroup) {\n    var ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt);\n    var labelEls = buildAxisLabel(group, transformGroup, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, ticksEls);\n    buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection);\n  },\n  axisName: function (opt, axisModel, group, transformGroup) {\n    var name = util_1.retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180;\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = util_1.retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth);\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      x: pos[0],\n      y: pos[1],\n      rotation: labelLayout.rotation,\n      silent: AxisBuilder.isLabelSilent(axisModel),\n      style: labelStyle_1.createTextStyle(textStyleModel, {\n        text: name,\n        font: textFont,\n        overflow: 'truncate',\n        width: maxWidth,\n        ellipsis: ellipsis,\n        fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),\n        align: textStyleModel.get('align') || labelLayout.textAlign,\n        verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n      }),\n      z2: 1\n    });\n    textEl.tooltip = tooltipOpt && tooltipOpt.show ? util_1.extend({\n      content: name,\n      formatter: function () {\n        return name;\n      },\n      formatterParams: formatterParams\n    }, tooltipOpt) : null;\n    textEl.__fullText = name;\n    textEl.anid = 'name';\n\n    if (axisModel.get('triggerEvent')) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisName';\n      eventData.name = name;\n      innerStore_1.getECData(textEl).eventData = eventData;\n    }\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nfunction endTextLayout(rotation, textPosition, textRotate, extent) {\n  var rotationDiff = number_1.remRadian(textRotate - rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (number_1.isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (number_1.isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (axisHelper_1.shouldShowAllLabels(axisModel.axis)) {\n    return;\n  }\n\n  var showMinLabel = axisModel.get(['axisLabel', 'showMinLabel']);\n  var showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']);\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next) {\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  }\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction createTicks(ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {\n  var tickEls = [];\n  var pt1 = [];\n  var pt2 = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = tickEndCoord;\n\n    if (tickTransform) {\n      vector_1.applyTransform(pt1, pt1, tickTransform);\n      vector_1.applyTransform(pt2, pt2, tickTransform);\n    }\n\n    var tickEl = new graphic.Line({\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: tickLineStyle,\n      z2: 2,\n      autoBatch: true,\n      silent: true\n    });\n    tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue;\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisMajorTicks(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var tickModel = axisModel.getModel('axisTick');\n  var shown = tickModel.get('show');\n\n  if (shown === 'auto' && opt.handleAutoShown) {\n    shown = opt.handleAutoShown('axisTick');\n  }\n\n  if (!shown || axis.scale.isBlank()) {\n    return;\n  }\n\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickEndCoord = opt.tickDirection * tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, util_1.defaults(lineStyleModel.getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }), 'ticks');\n\n  for (var i = 0; i < ticksEls.length; i++) {\n    group.add(ticksEls[i]);\n  }\n\n  return ticksEls;\n}\n\nfunction buildAxisMinorTicks(group, transformGroup, axisModel, tickDirection) {\n  var axis = axisModel.axis;\n  var minorTickModel = axisModel.getModel('minorTick');\n\n  if (!minorTickModel.get('show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var minorTicksCoords = axis.getMinorTicksCoords();\n\n  if (!minorTicksCoords.length) {\n    return;\n  }\n\n  var lineStyleModel = minorTickModel.getModel('lineStyle');\n  var tickEndCoord = tickDirection * minorTickModel.get('length');\n  var minorTickLineStyle = util_1.defaults(lineStyleModel.getLineStyle(), util_1.defaults(axisModel.getModel('axisTick').getLineStyle(), {\n    stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])\n  }));\n\n  for (var i = 0; i < minorTicksCoords.length; i++) {\n    var minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i);\n\n    for (var k = 0; k < minorTicksEls.length; k++) {\n      group.add(minorTicksEls[k]);\n    }\n  }\n}\n\nfunction buildAxisLabel(group, transformGroup, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = util_1.retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels();\n  var labelRotation = (util_1.retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = AxisBuilder.isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  util_1.each(labels, function (labelItem, index) {\n    var tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawIndex(labelItem.tickValue) : labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue]) {\n      var rawCategoryItem = rawCategoryData[tickValue];\n\n      if (util_1.isObject(rawCategoryItem) && rawCategoryItem.textStyle) {\n        itemLabelModel = new Model_1[\"default\"](rawCategoryItem.textStyle, labelModel, axisModel.ecModel);\n      }\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']);\n    var tickCoord = axis.dataToCoord(tickValue);\n    var textEl = new graphic.Text({\n      x: tickCoord,\n      y: opt.labelOffset + opt.labelDirection * labelMargin,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10,\n      style: labelStyle_1.createTextStyle(itemLabelModel, {\n        text: formattedLabel,\n        align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n        verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n        fill: typeof textColor === 'function' ? textColor(axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n      })\n    });\n    textEl.anid = 'label_' + tickValue;\n\n    if (triggerEvent) {\n      var eventData = AxisBuilder.makeAxisEventDataBase(axisModel);\n      eventData.targetType = 'axisLabel';\n      eventData.value = rawLabel;\n      innerStore_1.getECData(textEl).eventData = eventData;\n    }\n\n    transformGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nexports[\"default\"] = AxisBuilder;"]},"metadata":{},"sourceType":"script"}