{"ast":null,"code":"import SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\n\nfunction xrange(n, exception) {\n  let range = [];\n\n  for (let i = 0; i < n; i++) {\n    if (i !== exception) {\n      range.push(i);\n    }\n  }\n\n  return range;\n}\n\nfunction dependenciesOneRow(error, matrix, index, thresholdValue = 10e-10, thresholdError = 10e-10) {\n  if (error > thresholdError) {\n    return new Array(matrix.rows + 1).fill(0);\n  } else {\n    let returnArray = matrix.addRow(index, [0]);\n\n    for (let i = 0; i < returnArray.rows; i++) {\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\n        returnArray.set(i, 0, 0);\n      }\n    }\n\n    return returnArray.to1DArray();\n  }\n}\n\nexport function linearDependencies(matrix, options = {}) {\n  const {\n    thresholdValue = 10e-10,\n    thresholdError = 10e-10\n  } = options;\n  matrix = Matrix.checkMatrix(matrix);\n  let n = matrix.rows;\n  let results = new Matrix(n, n);\n\n  for (let i = 0; i < n; i++) {\n    let b = Matrix.columnVector(matrix.getRow(i));\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\n    let svd = new SingularValueDecomposition(Abis);\n    let x = svd.solve(b);\n    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();\n    results.setRow(i, dependenciesOneRow(error, x, i, thresholdValue, thresholdError));\n  }\n\n  return results;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/ml-matrix/src/linearDependencies.js"],"names":["SingularValueDecomposition","Matrix","xrange","n","exception","range","i","push","dependenciesOneRow","error","matrix","index","thresholdValue","thresholdError","Array","rows","fill","returnArray","addRow","Math","abs","get","set","to1DArray","linearDependencies","options","checkMatrix","results","b","columnVector","getRow","Abis","subMatrixRow","transpose","svd","x","solve","sub","mmul","max","setRow"],"mappings":"AAAA,OAAOA,0BAAP,MAAuC,UAAvC;AACA,OAAOC,MAAP,MAAmB,UAAnB;;AAEA,SAASC,MAAT,CAAgBC,CAAhB,EAAmBC,SAAnB,EAA8B;AAC5B,MAAIC,KAAK,GAAG,EAAZ;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAApB,EAAuBG,CAAC,EAAxB,EAA4B;AAC1B,QAAIA,CAAC,KAAKF,SAAV,EAAqB;AACnBC,MAAAA,KAAK,CAACE,IAAN,CAAWD,CAAX;AACD;AACF;;AACD,SAAOD,KAAP;AACD;;AAED,SAASG,kBAAT,CACEC,KADF,EAEEC,MAFF,EAGEC,KAHF,EAIEC,cAAc,GAAG,MAJnB,EAKEC,cAAc,GAAG,MALnB,EAME;AACA,MAAIJ,KAAK,GAAGI,cAAZ,EAA4B;AAC1B,WAAO,IAAIC,KAAJ,CAAUJ,MAAM,CAACK,IAAP,GAAc,CAAxB,EAA2BC,IAA3B,CAAgC,CAAhC,CAAP;AACD,GAFD,MAEO;AACL,QAAIC,WAAW,GAAGP,MAAM,CAACQ,MAAP,CAAcP,KAAd,EAAqB,CAAC,CAAD,CAArB,CAAlB;;AACA,SAAK,IAAIL,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGW,WAAW,CAACF,IAAhC,EAAsCT,CAAC,EAAvC,EAA2C;AACzC,UAAIa,IAAI,CAACC,GAAL,CAASH,WAAW,CAACI,GAAZ,CAAgBf,CAAhB,EAAmB,CAAnB,CAAT,IAAkCM,cAAtC,EAAsD;AACpDK,QAAAA,WAAW,CAACK,GAAZ,CAAgBhB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB;AACD;AACF;;AACD,WAAOW,WAAW,CAACM,SAAZ,EAAP;AACD;AACF;;AAED,OAAO,SAASC,kBAAT,CAA4Bd,MAA5B,EAAoCe,OAAO,GAAG,EAA9C,EAAkD;AACvD,QAAM;AAAEb,IAAAA,cAAc,GAAG,MAAnB;AAA2BC,IAAAA,cAAc,GAAG;AAA5C,MAAuDY,OAA7D;AACAf,EAAAA,MAAM,GAAGT,MAAM,CAACyB,WAAP,CAAmBhB,MAAnB,CAAT;AAEA,MAAIP,CAAC,GAAGO,MAAM,CAACK,IAAf;AACA,MAAIY,OAAO,GAAG,IAAI1B,MAAJ,CAAWE,CAAX,EAAcA,CAAd,CAAd;;AAEA,OAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,CAApB,EAAuBG,CAAC,EAAxB,EAA4B;AAC1B,QAAIsB,CAAC,GAAG3B,MAAM,CAAC4B,YAAP,CAAoBnB,MAAM,CAACoB,MAAP,CAAcxB,CAAd,CAApB,CAAR;AACA,QAAIyB,IAAI,GAAGrB,MAAM,CAACsB,YAAP,CAAoB9B,MAAM,CAACC,CAAD,EAAIG,CAAJ,CAA1B,EAAkC2B,SAAlC,EAAX;AACA,QAAIC,GAAG,GAAG,IAAIlC,0BAAJ,CAA+B+B,IAA/B,CAAV;AACA,QAAII,CAAC,GAAGD,GAAG,CAACE,KAAJ,CAAUR,CAAV,CAAR;AACA,QAAInB,KAAK,GAAGR,MAAM,CAACoC,GAAP,CAAWT,CAAX,EAAcG,IAAI,CAACO,IAAL,CAAUH,CAAV,CAAd,EAA4Bf,GAA5B,GAAkCmB,GAAlC,EAAZ;AACAZ,IAAAA,OAAO,CAACa,MAAR,CACElC,CADF,EAEEE,kBAAkB,CAACC,KAAD,EAAQ0B,CAAR,EAAW7B,CAAX,EAAcM,cAAd,EAA8BC,cAA9B,CAFpB;AAID;;AACD,SAAOc,OAAP;AACD","sourcesContent":["import SingularValueDecomposition from './dc/svd';\nimport Matrix from './matrix';\n\nfunction xrange(n, exception) {\n  let range = [];\n  for (let i = 0; i < n; i++) {\n    if (i !== exception) {\n      range.push(i);\n    }\n  }\n  return range;\n}\n\nfunction dependenciesOneRow(\n  error,\n  matrix,\n  index,\n  thresholdValue = 10e-10,\n  thresholdError = 10e-10,\n) {\n  if (error > thresholdError) {\n    return new Array(matrix.rows + 1).fill(0);\n  } else {\n    let returnArray = matrix.addRow(index, [0]);\n    for (let i = 0; i < returnArray.rows; i++) {\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\n        returnArray.set(i, 0, 0);\n      }\n    }\n    return returnArray.to1DArray();\n  }\n}\n\nexport function linearDependencies(matrix, options = {}) {\n  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;\n  matrix = Matrix.checkMatrix(matrix);\n\n  let n = matrix.rows;\n  let results = new Matrix(n, n);\n\n  for (let i = 0; i < n; i++) {\n    let b = Matrix.columnVector(matrix.getRow(i));\n    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();\n    let svd = new SingularValueDecomposition(Abis);\n    let x = svd.solve(b);\n    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();\n    results.setRow(\n      i,\n      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),\n    );\n  }\n  return results;\n}\n"]},"metadata":{},"sourceType":"module"}