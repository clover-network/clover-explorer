{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar graphic_1 = require(\"../util/graphic\");\n\nfunction prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform();\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new graphic_1.OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nexports.prepareLayoutList = prepareLayoutList;\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    shiftList(-totalShifts / len, 0, len);\n  }\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap();\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1);\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  }\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        var movement = gaps[i] * squeezePercent;\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      for (var i = len - 1; i > 0; i--) {\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n\nfunction shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n\nexports.shiftLayoutOnX = shiftLayoutOnX;\n\nfunction shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\n\nexports.shiftLayoutOnY = shiftLayoutOnY;\n\nfunction hideOverlap(labelList) {\n  var displayedLabels = [];\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new graphic_1.BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect);\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j];\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        existsTextCfg.obb = new graphic_1.OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        obb = new graphic_1.OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    }\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}\n\nexports.hideOverlap = hideOverlap;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/label/labelLayoutHelper.js"],"names":["exports","__esModule","graphic_1","require","prepareLayoutList","input","list","i","length","rawItem","defaultAttr","ignore","label","transform","getComputedTransform","localRect","getBoundingRect","isAxisAligned","minMargin","style","margin","globalRect","clone","applyTransform","x","y","width","height","obb","OrientedBoundingRect","push","labelLine","rect","priority","layoutOption","computedLayoutOption","axisAligned","shiftLayout","xyDim","sizeDim","minBound","maxBound","balanceShift","len","sort","a","b","lastPos","delta","adjusted","shifts","totalShifts","item","shift","Math","max","shiftList","first","last","minGap","maxGap","updateMinMaxGap","squeezeGaps","takeBoundsGap","squeezeWhenBailout","gapThisBound","gapOtherBound","moveDir","moveFromMaxGap","min","remained","start","end","maxSqeezePercent","gaps","totalGaps","prevItemRect","gap","squeezePercent","abs","movement","dir","moveForEachLabel","ceil","shiftLayoutOnX","leftBound","rightBound","shiftLayoutOnY","topBound","bottomBound","hideOverlap","labelList","displayedLabels","BoundingRect","hideEl","el","emphasisState","ensureState","labelItem","copy","overlapped","j","existsTextCfg","intersect","attr","labelGuideIgnore"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AAEA,IAAIC,SAAS,GAAGC,OAAO,CAAC,iBAAD,CAAvB;;AAEA,SAASC,iBAAT,CAA2BC,KAA3B,EAAkC;AAChC,MAAIC,IAAI,GAAG,EAAX;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACG,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,QAAIE,OAAO,GAAGJ,KAAK,CAACE,CAAD,CAAnB;;AAEA,QAAIE,OAAO,CAACC,WAAR,CAAoBC,MAAxB,EAAgC;AAC9B;AACD;;AAED,QAAIC,KAAK,GAAGH,OAAO,CAACG,KAApB;AACA,QAAIC,SAAS,GAAGD,KAAK,CAACE,oBAAN,EAAhB;AACA,QAAIC,SAAS,GAAGH,KAAK,CAACI,eAAN,EAAhB;AACA,QAAIC,aAAa,GAAG,CAACJ,SAAD,IAAcA,SAAS,CAAC,CAAD,CAAT,GAAe,IAAf,IAAuBA,SAAS,CAAC,CAAD,CAAT,GAAe,IAAxE;AACA,QAAIK,SAAS,GAAGN,KAAK,CAACO,KAAN,CAAYC,MAAZ,IAAsB,CAAtC;AACA,QAAIC,UAAU,GAAGN,SAAS,CAACO,KAAV,EAAjB;AACAD,IAAAA,UAAU,CAACE,cAAX,CAA0BV,SAA1B;AACAQ,IAAAA,UAAU,CAACG,CAAX,IAAgBN,SAAS,GAAG,CAA5B;AACAG,IAAAA,UAAU,CAACI,CAAX,IAAgBP,SAAS,GAAG,CAA5B;AACAG,IAAAA,UAAU,CAACK,KAAX,IAAoBR,SAApB;AACAG,IAAAA,UAAU,CAACM,MAAX,IAAqBT,SAArB;AACA,QAAIU,GAAG,GAAGX,aAAa,GAAG,IAAIf,SAAS,CAAC2B,oBAAd,CAAmCd,SAAnC,EAA8CF,SAA9C,CAAH,GAA8D,IAArF;AACAP,IAAAA,IAAI,CAACwB,IAAL,CAAU;AACRlB,MAAAA,KAAK,EAAEA,KADC;AAERmB,MAAAA,SAAS,EAAEtB,OAAO,CAACsB,SAFX;AAGRC,MAAAA,IAAI,EAAEX,UAHE;AAIRN,MAAAA,SAAS,EAAEA,SAJH;AAKRa,MAAAA,GAAG,EAAEA,GALG;AAMRK,MAAAA,QAAQ,EAAExB,OAAO,CAACwB,QANV;AAORvB,MAAAA,WAAW,EAAED,OAAO,CAACC,WAPb;AAQRwB,MAAAA,YAAY,EAAEzB,OAAO,CAAC0B,oBARd;AASRC,MAAAA,WAAW,EAAEnB,aATL;AAURJ,MAAAA,SAAS,EAAEA;AAVH,KAAV;AAYD;;AAED,SAAOP,IAAP;AACD;;AAEDN,OAAO,CAACI,iBAAR,GAA4BA,iBAA5B;;AAEA,SAASiC,WAAT,CAAqB/B,IAArB,EAA2BgC,KAA3B,EAAkCC,OAAlC,EAA2CC,QAA3C,EAAqDC,QAArD,EAA+DC,YAA/D,EAA6E;AAC3E,MAAIC,GAAG,GAAGrC,IAAI,CAACE,MAAf;;AAEA,MAAImC,GAAG,GAAG,CAAV,EAAa;AACX;AACD;;AAEDrC,EAAAA,IAAI,CAACsC,IAAL,CAAU,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AACxB,WAAOD,CAAC,CAACb,IAAF,CAAOM,KAAP,IAAgBQ,CAAC,CAACd,IAAF,CAAOM,KAAP,CAAvB;AACD,GAFD;AAGA,MAAIS,OAAO,GAAG,CAAd;AACA,MAAIC,KAAJ;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,WAAW,GAAG,CAAlB;;AAEA,OAAK,IAAI5C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,GAApB,EAAyBpC,CAAC,EAA1B,EAA8B;AAC5B,QAAI6C,IAAI,GAAG9C,IAAI,CAACC,CAAD,CAAf;AACA,QAAIyB,IAAI,GAAGoB,IAAI,CAACpB,IAAhB;AACAgB,IAAAA,KAAK,GAAGhB,IAAI,CAACM,KAAD,CAAJ,GAAcS,OAAtB;;AAEA,QAAIC,KAAK,GAAG,CAAZ,EAAe;AACbhB,MAAAA,IAAI,CAACM,KAAD,CAAJ,IAAeU,KAAf;AACAI,MAAAA,IAAI,CAACxC,KAAL,CAAW0B,KAAX,KAAqBU,KAArB;AACAC,MAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,QAAII,KAAK,GAAGC,IAAI,CAACC,GAAL,CAAS,CAACP,KAAV,EAAiB,CAAjB,CAAZ;AACAE,IAAAA,MAAM,CAACpB,IAAP,CAAYuB,KAAZ;AACAF,IAAAA,WAAW,IAAIE,KAAf;AACAN,IAAAA,OAAO,GAAGf,IAAI,CAACM,KAAD,CAAJ,GAAcN,IAAI,CAACO,OAAD,CAA5B;AACD;;AAED,MAAIY,WAAW,GAAG,CAAd,IAAmBT,YAAvB,EAAqC;AACnCc,IAAAA,SAAS,CAAC,CAACL,WAAD,GAAeR,GAAhB,EAAqB,CAArB,EAAwBA,GAAxB,CAAT;AACD;;AAED,MAAIc,KAAK,GAAGnD,IAAI,CAAC,CAAD,CAAhB;AACA,MAAIoD,IAAI,GAAGpD,IAAI,CAACqC,GAAG,GAAG,CAAP,CAAf;AACA,MAAIgB,MAAJ;AACA,MAAIC,MAAJ;AACAC,EAAAA,eAAe;AACfF,EAAAA,MAAM,GAAG,CAAT,IAAcG,WAAW,CAAC,CAACH,MAAF,EAAU,GAAV,CAAzB;AACAC,EAAAA,MAAM,GAAG,CAAT,IAAcE,WAAW,CAACF,MAAD,EAAS,GAAT,CAAzB;AACAC,EAAAA,eAAe;AACfE,EAAAA,aAAa,CAACJ,MAAD,EAASC,MAAT,EAAiB,CAAjB,CAAb;AACAG,EAAAA,aAAa,CAACH,MAAD,EAASD,MAAT,EAAiB,CAAC,CAAlB,CAAb;AACAE,EAAAA,eAAe;;AAEf,MAAIF,MAAM,GAAG,CAAb,EAAgB;AACdK,IAAAA,kBAAkB,CAAC,CAACL,MAAF,CAAlB;AACD;;AAED,MAAIC,MAAM,GAAG,CAAb,EAAgB;AACdI,IAAAA,kBAAkB,CAACJ,MAAD,CAAlB;AACD;;AAED,WAASC,eAAT,GAA2B;AACzBF,IAAAA,MAAM,GAAGF,KAAK,CAACzB,IAAN,CAAWM,KAAX,IAAoBE,QAA7B;AACAoB,IAAAA,MAAM,GAAGnB,QAAQ,GAAGiB,IAAI,CAAC1B,IAAL,CAAUM,KAAV,CAAX,GAA8BoB,IAAI,CAAC1B,IAAL,CAAUO,OAAV,CAAvC;AACD;;AAED,WAASwB,aAAT,CAAuBE,YAAvB,EAAqCC,aAArC,EAAoDC,OAApD,EAA6D;AAC3D,QAAIF,YAAY,GAAG,CAAnB,EAAsB;AACpB,UAAIG,cAAc,GAAGd,IAAI,CAACe,GAAL,CAASH,aAAT,EAAwB,CAACD,YAAzB,CAArB;;AAEA,UAAIG,cAAc,GAAG,CAArB,EAAwB;AACtBZ,QAAAA,SAAS,CAACY,cAAc,GAAGD,OAAlB,EAA2B,CAA3B,EAA8BxB,GAA9B,CAAT;AACA,YAAI2B,QAAQ,GAAGF,cAAc,GAAGH,YAAhC;;AAEA,YAAIK,QAAQ,GAAG,CAAf,EAAkB;AAChBR,UAAAA,WAAW,CAAC,CAACQ,QAAD,GAAYH,OAAb,EAAsB,CAAtB,CAAX;AACD;AACF,OAPD,MAOO;AACLL,QAAAA,WAAW,CAAC,CAACG,YAAD,GAAgBE,OAAjB,EAA0B,CAA1B,CAAX;AACD;AACF;AACF;;AAED,WAASX,SAAT,CAAmBR,KAAnB,EAA0BuB,KAA1B,EAAiCC,GAAjC,EAAsC;AACpC,QAAIxB,KAAK,KAAK,CAAd,EAAiB;AACfC,MAAAA,QAAQ,GAAG,IAAX;AACD;;AAED,SAAK,IAAI1C,CAAC,GAAGgE,KAAb,EAAoBhE,CAAC,GAAGiE,GAAxB,EAA6BjE,CAAC,EAA9B,EAAkC;AAChC,UAAI6C,IAAI,GAAG9C,IAAI,CAACC,CAAD,CAAf;AACA,UAAIyB,IAAI,GAAGoB,IAAI,CAACpB,IAAhB;AACAA,MAAAA,IAAI,CAACM,KAAD,CAAJ,IAAeU,KAAf;AACAI,MAAAA,IAAI,CAACxC,KAAL,CAAW0B,KAAX,KAAqBU,KAArB;AACD;AACF;;AAED,WAASc,WAAT,CAAqBd,KAArB,EAA4ByB,gBAA5B,EAA8C;AAC5C,QAAIC,IAAI,GAAG,EAAX;AACA,QAAIC,SAAS,GAAG,CAAhB;;AAEA,SAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,GAApB,EAAyBpC,CAAC,EAA1B,EAA8B;AAC5B,UAAIqE,YAAY,GAAGtE,IAAI,CAACC,CAAC,GAAG,CAAL,CAAJ,CAAYyB,IAA/B;AACA,UAAI6C,GAAG,GAAGvB,IAAI,CAACC,GAAL,CAASjD,IAAI,CAACC,CAAD,CAAJ,CAAQyB,IAAR,CAAaM,KAAb,IAAsBsC,YAAY,CAACtC,KAAD,CAAlC,GAA4CsC,YAAY,CAACrC,OAAD,CAAjE,EAA4E,CAA5E,CAAV;AACAmC,MAAAA,IAAI,CAAC5C,IAAL,CAAU+C,GAAV;AACAF,MAAAA,SAAS,IAAIE,GAAb;AACD;;AAED,QAAI,CAACF,SAAL,EAAgB;AACd;AACD;;AAED,QAAIG,cAAc,GAAGxB,IAAI,CAACe,GAAL,CAASf,IAAI,CAACyB,GAAL,CAAS/B,KAAT,IAAkB2B,SAA3B,EAAsCF,gBAAtC,CAArB;;AAEA,QAAIzB,KAAK,GAAG,CAAZ,EAAe;AACb,WAAK,IAAIzC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,GAAG,GAAG,CAA1B,EAA6BpC,CAAC,EAA9B,EAAkC;AAChC,YAAIyE,QAAQ,GAAGN,IAAI,CAACnE,CAAD,CAAJ,GAAUuE,cAAzB;AACAtB,QAAAA,SAAS,CAACwB,QAAD,EAAW,CAAX,EAAczE,CAAC,GAAG,CAAlB,CAAT;AACD;AACF,KALD,MAKO;AACL,WAAK,IAAIA,CAAC,GAAGoC,GAAG,GAAG,CAAnB,EAAsBpC,CAAC,GAAG,CAA1B,EAA6BA,CAAC,EAA9B,EAAkC;AAChC,YAAIyE,QAAQ,GAAGN,IAAI,CAACnE,CAAC,GAAG,CAAL,CAAJ,GAAcuE,cAA7B;AACAtB,QAAAA,SAAS,CAAC,CAACwB,QAAF,EAAYzE,CAAZ,EAAeoC,GAAf,CAAT;AACD;AACF;AACF;;AAED,WAASqB,kBAAT,CAA4BhB,KAA5B,EAAmC;AACjC,QAAIiC,GAAG,GAAGjC,KAAK,GAAG,CAAR,GAAY,CAAC,CAAb,GAAiB,CAA3B;AACAA,IAAAA,KAAK,GAAGM,IAAI,CAACyB,GAAL,CAAS/B,KAAT,CAAR;AACA,QAAIkC,gBAAgB,GAAG5B,IAAI,CAAC6B,IAAL,CAAUnC,KAAK,IAAIL,GAAG,GAAG,CAAV,CAAf,CAAvB;;AAEA,SAAK,IAAIpC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoC,GAAG,GAAG,CAA1B,EAA6BpC,CAAC,EAA9B,EAAkC;AAChC,UAAI0E,GAAG,GAAG,CAAV,EAAa;AACXzB,QAAAA,SAAS,CAAC0B,gBAAD,EAAmB,CAAnB,EAAsB3E,CAAC,GAAG,CAA1B,CAAT;AACD,OAFD,MAEO;AACLiD,QAAAA,SAAS,CAAC,CAAC0B,gBAAF,EAAoBvC,GAAG,GAAGpC,CAAN,GAAU,CAA9B,EAAiCoC,GAAjC,CAAT;AACD;;AAEDK,MAAAA,KAAK,IAAIkC,gBAAT;;AAEA,UAAIlC,KAAK,IAAI,CAAb,EAAgB;AACd;AACD;AACF;AACF;;AAED,SAAOC,QAAP;AACD;;AAED,SAASmC,cAAT,CAAwB9E,IAAxB,EAA8B+E,SAA9B,EAAyCC,UAAzC,EAAqD5C,YAArD,EAAmE;AACjE,SAAOL,WAAW,CAAC/B,IAAD,EAAO,GAAP,EAAY,OAAZ,EAAqB+E,SAArB,EAAgCC,UAAhC,EAA4C5C,YAA5C,CAAlB;AACD;;AAED1C,OAAO,CAACoF,cAAR,GAAyBA,cAAzB;;AAEA,SAASG,cAAT,CAAwBjF,IAAxB,EAA8BkF,QAA9B,EAAwCC,WAAxC,EAAqD/C,YAArD,EAAmE;AACjE,SAAOL,WAAW,CAAC/B,IAAD,EAAO,GAAP,EAAY,QAAZ,EAAsBkF,QAAtB,EAAgCC,WAAhC,EAA6C/C,YAA7C,CAAlB;AACD;;AAED1C,OAAO,CAACuF,cAAR,GAAyBA,cAAzB;;AAEA,SAASG,WAAT,CAAqBC,SAArB,EAAgC;AAC9B,MAAIC,eAAe,GAAG,EAAtB;AACAD,EAAAA,SAAS,CAAC/C,IAAV,CAAe,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC7B,WAAOA,CAAC,CAACb,QAAF,GAAaY,CAAC,CAACZ,QAAtB;AACD,GAFD;AAGA,MAAIZ,UAAU,GAAG,IAAInB,SAAS,CAAC2F,YAAd,CAA2B,CAA3B,EAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC,CAAjB;;AAEA,WAASC,MAAT,CAAgBC,EAAhB,EAAoB;AAClB,QAAI,CAACA,EAAE,CAACpF,MAAR,EAAgB;AACd,UAAIqF,aAAa,GAAGD,EAAE,CAACE,WAAH,CAAe,UAAf,CAApB;;AAEA,UAAID,aAAa,CAACrF,MAAd,IAAwB,IAA5B,EAAkC;AAChCqF,QAAAA,aAAa,CAACrF,MAAd,GAAuB,KAAvB;AACD;AACF;;AAEDoF,IAAAA,EAAE,CAACpF,MAAH,GAAY,IAAZ;AACD;;AAED,OAAK,IAAIJ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoF,SAAS,CAACnF,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;AACzC,QAAI2F,SAAS,GAAGP,SAAS,CAACpF,CAAD,CAAzB;AACA,QAAIU,aAAa,GAAGiF,SAAS,CAAC9D,WAA9B;AACA,QAAIrB,SAAS,GAAGmF,SAAS,CAACnF,SAA1B;AACA,QAAIF,SAAS,GAAGqF,SAAS,CAACrF,SAA1B;AACA,QAAID,KAAK,GAAGsF,SAAS,CAACtF,KAAtB;AACA,QAAImB,SAAS,GAAGmE,SAAS,CAACnE,SAA1B;AACAV,IAAAA,UAAU,CAAC8E,IAAX,CAAgBD,SAAS,CAAClE,IAA1B;AACAX,IAAAA,UAAU,CAACK,KAAX,IAAoB,GAApB;AACAL,IAAAA,UAAU,CAACM,MAAX,IAAqB,GAArB;AACAN,IAAAA,UAAU,CAACG,CAAX,IAAgB,IAAhB;AACAH,IAAAA,UAAU,CAACI,CAAX,IAAgB,IAAhB;AACA,QAAIG,GAAG,GAAGsE,SAAS,CAACtE,GAApB;AACA,QAAIwE,UAAU,GAAG,KAAjB;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGT,eAAe,CAACpF,MAApC,EAA4C6F,CAAC,EAA7C,EAAiD;AAC/C,UAAIC,aAAa,GAAGV,eAAe,CAACS,CAAD,CAAnC;;AAEA,UAAI,CAAChF,UAAU,CAACkF,SAAX,CAAqBD,aAAa,CAACtE,IAAnC,CAAL,EAA+C;AAC7C;AACD;;AAED,UAAIf,aAAa,IAAIqF,aAAa,CAAClE,WAAnC,EAAgD;AAC9CgE,QAAAA,UAAU,GAAG,IAAb;AACA;AACD;;AAED,UAAI,CAACE,aAAa,CAAC1E,GAAnB,EAAwB;AACtB0E,QAAAA,aAAa,CAAC1E,GAAd,GAAoB,IAAI1B,SAAS,CAAC2B,oBAAd,CAAmCyE,aAAa,CAACvF,SAAjD,EAA4DuF,aAAa,CAACzF,SAA1E,CAApB;AACD;;AAED,UAAI,CAACe,GAAL,EAAU;AACRA,QAAAA,GAAG,GAAG,IAAI1B,SAAS,CAAC2B,oBAAd,CAAmCd,SAAnC,EAA8CF,SAA9C,CAAN;AACD;;AAED,UAAIe,GAAG,CAAC2E,SAAJ,CAAcD,aAAa,CAAC1E,GAA5B,CAAJ,EAAsC;AACpCwE,QAAAA,UAAU,GAAG,IAAb;AACA;AACD;AACF;;AAED,QAAIA,UAAJ,EAAgB;AACdN,MAAAA,MAAM,CAAClF,KAAD,CAAN;AACAmB,MAAAA,SAAS,IAAI+D,MAAM,CAAC/D,SAAD,CAAnB;AACD,KAHD,MAGO;AACLnB,MAAAA,KAAK,CAAC4F,IAAN,CAAW,QAAX,EAAqBN,SAAS,CAACxF,WAAV,CAAsBC,MAA3C;AACAoB,MAAAA,SAAS,IAAIA,SAAS,CAACyE,IAAV,CAAe,QAAf,EAAyBN,SAAS,CAACxF,WAAV,CAAsB+F,gBAA/C,CAAb;AACAb,MAAAA,eAAe,CAAC9D,IAAhB,CAAqBoE,SAArB;AACD;AACF;AACF;;AAEDlG,OAAO,CAAC0F,WAAR,GAAsBA,WAAtB","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar graphic_1 = require(\"../util/graphic\");\n\nfunction prepareLayoutList(input) {\n  var list = [];\n\n  for (var i = 0; i < input.length; i++) {\n    var rawItem = input[i];\n\n    if (rawItem.defaultAttr.ignore) {\n      continue;\n    }\n\n    var label = rawItem.label;\n    var transform = label.getComputedTransform();\n    var localRect = label.getBoundingRect();\n    var isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5;\n    var minMargin = label.style.margin || 0;\n    var globalRect = localRect.clone();\n    globalRect.applyTransform(transform);\n    globalRect.x -= minMargin / 2;\n    globalRect.y -= minMargin / 2;\n    globalRect.width += minMargin;\n    globalRect.height += minMargin;\n    var obb = isAxisAligned ? new graphic_1.OrientedBoundingRect(localRect, transform) : null;\n    list.push({\n      label: label,\n      labelLine: rawItem.labelLine,\n      rect: globalRect,\n      localRect: localRect,\n      obb: obb,\n      priority: rawItem.priority,\n      defaultAttr: rawItem.defaultAttr,\n      layoutOption: rawItem.computedLayoutOption,\n      axisAligned: isAxisAligned,\n      transform: transform\n    });\n  }\n\n  return list;\n}\n\nexports.prepareLayoutList = prepareLayoutList;\n\nfunction shiftLayout(list, xyDim, sizeDim, minBound, maxBound, balanceShift) {\n  var len = list.length;\n\n  if (len < 2) {\n    return;\n  }\n\n  list.sort(function (a, b) {\n    return a.rect[xyDim] - b.rect[xyDim];\n  });\n  var lastPos = 0;\n  var delta;\n  var adjusted = false;\n  var shifts = [];\n  var totalShifts = 0;\n\n  for (var i = 0; i < len; i++) {\n    var item = list[i];\n    var rect = item.rect;\n    delta = rect[xyDim] - lastPos;\n\n    if (delta < 0) {\n      rect[xyDim] -= delta;\n      item.label[xyDim] -= delta;\n      adjusted = true;\n    }\n\n    var shift = Math.max(-delta, 0);\n    shifts.push(shift);\n    totalShifts += shift;\n    lastPos = rect[xyDim] + rect[sizeDim];\n  }\n\n  if (totalShifts > 0 && balanceShift) {\n    shiftList(-totalShifts / len, 0, len);\n  }\n\n  var first = list[0];\n  var last = list[len - 1];\n  var minGap;\n  var maxGap;\n  updateMinMaxGap();\n  minGap < 0 && squeezeGaps(-minGap, 0.8);\n  maxGap < 0 && squeezeGaps(maxGap, 0.8);\n  updateMinMaxGap();\n  takeBoundsGap(minGap, maxGap, 1);\n  takeBoundsGap(maxGap, minGap, -1);\n  updateMinMaxGap();\n\n  if (minGap < 0) {\n    squeezeWhenBailout(-minGap);\n  }\n\n  if (maxGap < 0) {\n    squeezeWhenBailout(maxGap);\n  }\n\n  function updateMinMaxGap() {\n    minGap = first.rect[xyDim] - minBound;\n    maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim];\n  }\n\n  function takeBoundsGap(gapThisBound, gapOtherBound, moveDir) {\n    if (gapThisBound < 0) {\n      var moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound);\n\n      if (moveFromMaxGap > 0) {\n        shiftList(moveFromMaxGap * moveDir, 0, len);\n        var remained = moveFromMaxGap + gapThisBound;\n\n        if (remained < 0) {\n          squeezeGaps(-remained * moveDir, 1);\n        }\n      } else {\n        squeezeGaps(-gapThisBound * moveDir, 1);\n      }\n    }\n  }\n\n  function shiftList(delta, start, end) {\n    if (delta !== 0) {\n      adjusted = true;\n    }\n\n    for (var i = start; i < end; i++) {\n      var item = list[i];\n      var rect = item.rect;\n      rect[xyDim] += delta;\n      item.label[xyDim] += delta;\n    }\n  }\n\n  function squeezeGaps(delta, maxSqeezePercent) {\n    var gaps = [];\n    var totalGaps = 0;\n\n    for (var i = 1; i < len; i++) {\n      var prevItemRect = list[i - 1].rect;\n      var gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0);\n      gaps.push(gap);\n      totalGaps += gap;\n    }\n\n    if (!totalGaps) {\n      return;\n    }\n\n    var squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent);\n\n    if (delta > 0) {\n      for (var i = 0; i < len - 1; i++) {\n        var movement = gaps[i] * squeezePercent;\n        shiftList(movement, 0, i + 1);\n      }\n    } else {\n      for (var i = len - 1; i > 0; i--) {\n        var movement = gaps[i - 1] * squeezePercent;\n        shiftList(-movement, i, len);\n      }\n    }\n  }\n\n  function squeezeWhenBailout(delta) {\n    var dir = delta < 0 ? -1 : 1;\n    delta = Math.abs(delta);\n    var moveForEachLabel = Math.ceil(delta / (len - 1));\n\n    for (var i = 0; i < len - 1; i++) {\n      if (dir > 0) {\n        shiftList(moveForEachLabel, 0, i + 1);\n      } else {\n        shiftList(-moveForEachLabel, len - i - 1, len);\n      }\n\n      delta -= moveForEachLabel;\n\n      if (delta <= 0) {\n        return;\n      }\n    }\n  }\n\n  return adjusted;\n}\n\nfunction shiftLayoutOnX(list, leftBound, rightBound, balanceShift) {\n  return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift);\n}\n\nexports.shiftLayoutOnX = shiftLayoutOnX;\n\nfunction shiftLayoutOnY(list, topBound, bottomBound, balanceShift) {\n  return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift);\n}\n\nexports.shiftLayoutOnY = shiftLayoutOnY;\n\nfunction hideOverlap(labelList) {\n  var displayedLabels = [];\n  labelList.sort(function (a, b) {\n    return b.priority - a.priority;\n  });\n  var globalRect = new graphic_1.BoundingRect(0, 0, 0, 0);\n\n  function hideEl(el) {\n    if (!el.ignore) {\n      var emphasisState = el.ensureState('emphasis');\n\n      if (emphasisState.ignore == null) {\n        emphasisState.ignore = false;\n      }\n    }\n\n    el.ignore = true;\n  }\n\n  for (var i = 0; i < labelList.length; i++) {\n    var labelItem = labelList[i];\n    var isAxisAligned = labelItem.axisAligned;\n    var localRect = labelItem.localRect;\n    var transform = labelItem.transform;\n    var label = labelItem.label;\n    var labelLine = labelItem.labelLine;\n    globalRect.copy(labelItem.rect);\n    globalRect.width -= 0.1;\n    globalRect.height -= 0.1;\n    globalRect.x += 0.05;\n    globalRect.y += 0.05;\n    var obb = labelItem.obb;\n    var overlapped = false;\n\n    for (var j = 0; j < displayedLabels.length; j++) {\n      var existsTextCfg = displayedLabels[j];\n\n      if (!globalRect.intersect(existsTextCfg.rect)) {\n        continue;\n      }\n\n      if (isAxisAligned && existsTextCfg.axisAligned) {\n        overlapped = true;\n        break;\n      }\n\n      if (!existsTextCfg.obb) {\n        existsTextCfg.obb = new graphic_1.OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform);\n      }\n\n      if (!obb) {\n        obb = new graphic_1.OrientedBoundingRect(localRect, transform);\n      }\n\n      if (obb.intersect(existsTextCfg.obb)) {\n        overlapped = true;\n        break;\n      }\n    }\n\n    if (overlapped) {\n      hideEl(label);\n      labelLine && hideEl(labelLine);\n    } else {\n      label.attr('ignore', labelItem.defaultAttr.ignore);\n      labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore);\n      displayedLabels.push(labelItem);\n    }\n  }\n}\n\nexports.hideOverlap = hideOverlap;"]},"metadata":{},"sourceType":"script"}