{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar graphic_1 = require(\"../util/graphic\");\n\nvar PathProxy_1 = require(\"zrender/lib/core/PathProxy\");\n\nvar util_1 = require(\"zrender/lib/contain/util\");\n\nvar curve_1 = require(\"zrender/lib/core/curve\");\n\nvar util_2 = require(\"zrender/lib/core/util\");\n\nvar matrix_1 = require(\"zrender/lib/core/matrix\");\n\nvar vector = require(\"zrender/lib/core/vector\");\n\nvar states_1 = require(\"../util/states\");\n\nvar PI2 = Math.PI * 2;\nvar CMD = PathProxy_1[\"default\"].CMD;\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\n\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n\n  switch (pos) {\n    case 'top':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n\n    case 'bottom':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n\n    case 'left':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n\n    case 'right':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\n\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d;\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = util_1.normalizeRadian(endAngle);\n    endAngle = util_1.normalizeRadian(tmp);\n  } else {\n    startAngle = util_1.normalizeRadian(startAngle);\n    endAngle = util_1.normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\n\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen;\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nvar tmpPt = [];\n\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    var d = minDist;\n\n    switch (cmd) {\n      case CMD.M:\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        d = curve_1.cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        d = curve_1.quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy;\n\n        if (i <= 1) {\n          x0 = x1;\n          y0 = y1;\n        }\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n\n  return minDist;\n}\n\nvar pt0 = new graphic_1.Point();\nvar pt1 = new graphic_1.Point();\nvar pt2 = new graphic_1.Point();\nvar dir = new graphic_1.Point();\nvar dir2 = new graphic_1.Point();\n\nfunction updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent();\n\n  if (!(label && labelLine)) {\n    return;\n  }\n\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && matrix_1.invert([], targetTransform);\n  var len = labelLineModel.get('length2') || 0;\n\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    graphic_1.Point.scaleAndAdd(pt1, pt0, dir, len);\n    pt1.transform(targetInversedTransform);\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof graphic_1.Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);\n\n    if (dist < minDist) {\n      minDist = dist;\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n  labelLine.setShape({\n    points: points\n  });\n}\n\nexports.updateLabelLinePoints = updateLabelLinePoints;\nvar tmpArr = [];\nvar tmpProjPoint = new graphic_1.Point();\n\nfunction limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n\n  minTurnAngle = minTurnAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  graphic_1.Point.sub(dir, pt0, pt1);\n  graphic_1.Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n\n  if (minTurnAngleCos < angleCos) {\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n    if (isNaN(t)) {\n      return;\n    }\n\n    if (t < 0) {\n      graphic_1.Point.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      graphic_1.Point.copy(tmpProjPoint, pt2);\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nexports.limitTurnAngle = limitTurnAngle;\n\nfunction limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  graphic_1.Point.sub(dir, pt1, pt0);\n  graphic_1.Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n\n  if (angleCos < maxSurfaceAngleCos) {\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n\n    if (newAngle >= HALF_PI) {\n      graphic_1.Point.copy(tmpProjPoint, pt2);\n    } else {\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n      if (isNaN(t)) {\n        return;\n      }\n\n      if (t < 0) {\n        graphic_1.Point.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        graphic_1.Point.copy(tmpProjPoint, pt2);\n      }\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nexports.limitSurfaceAngle = limitSurfaceAngle;\n\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === 'normal';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);\n  stateObj.ignore = ignore;\n  var smooth = stateModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n\n  stateObj.shape = stateObj.shape || {};\n\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\n\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n\n  if (!points) {\n    return;\n  }\n\n  path.moveTo(points[0][0], points[0][1]);\n\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = vector.dist(points[0], points[1]);\n    var len2 = vector.dist(points[1], points[2]);\n\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n\nfunction setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n\n  if (!label) {\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n\n    return;\n  }\n\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get('show');\n  var labelIgnoreNormal = label.ignore;\n\n  for (var i = 0; i < states_1.DISPLAY_STATES.length; i++) {\n    var stateName = states_1.DISPLAY_STATES[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === 'normal';\n\n    if (stateModel) {\n      var stateShow = stateModel.get('show');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : util_2.retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n\n      if (isLabelIgnored || !util_2.retrieve2(stateShow, showNormal)) {\n        var stateObj = isNormal ? labelLine : labelLine && labelLine.states.normal;\n\n        if (stateObj) {\n          stateObj.ignore = true;\n        }\n\n        continue;\n      }\n\n      if (!labelLine) {\n        labelLine = new graphic_1.Polyline();\n        targetEl.setTextGuideLine(labelLine);\n\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n        }\n\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n\n  if (labelLine) {\n    util_2.defaults(labelLine.style, defaultStyle);\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get('showAbove');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false;\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\n\nexports.setLabelLineStyle = setLabelLineStyle;\n\nfunction getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || 'labelLine';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n\n  for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {\n    var stateName = states_1.SPECIAL_STATES[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n\n  return statesModels;\n}\n\nexports.getLabelLineStatesModels = getLabelLineStatesModels;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/label/labelGuideHelper.js"],"names":["exports","__esModule","graphic_1","require","PathProxy_1","util_1","curve_1","util_2","matrix_1","vector","states_1","PI2","Math","PI","CMD","DEFAULT_SEARCH_SPACE","getCandidateAnchor","pos","distance","rect","outPt","outDir","width","height","set","x","y","projectPointToArc","cx","cy","r","startAngle","endAngle","anticlockwise","out","d","sqrt","ox","oy","abs","tmp","normalizeRadian","angle","atan2","x1","cos","y1","sin","x2","y2","d1","d2","projectPointToLine","limitToEnds","dx","dy","dx1","dy1","lineLen","projectedLen","t","min","max","projectPointToRect","tmpPt","nearestPointOnRect","pt","dist","nearestPointOnPath","path","xi","yi","x0","y0","minDist","Infinity","data","i","length","cmd","M","L","C","cubicProjectPoint","Q","quadraticProjectPoint","A","rx","ry","theta","dTheta","_x","R","Z","pt0","Point","pt1","pt2","dir","dir2","updateLabelLinePoints","target","labelLineModel","labelLine","getTextGuideLine","label","getTextContent","labelGuideConfig","textGuideLineConfig","points","searchSpace","candidates","labelRect","getBoundingRect","clone","applyTransform","getComputedTransform","anchorPoint","anchor","targetTransform","targetInversedTransform","invert","len","get","copy","candidate","scaleAndAdd","transform","boundingRect","Path","toArray","limitTurnAngle","setShape","tmpArr","tmpProjPoint","linePoints","minTurnAngle","fromArray","sub","len1","len2","scale","angleCos","dot","minTurnAngleCos","tan","isNaN","limitSurfaceAngle","surfaceNormal","maxSurfaceAngle","maxSurfaceAngleCos","HALF_PI","angle2","acos","newAngle","setLabelLineState","ignore","stateName","stateModel","isNormal","stateObj","ensureState","smooth","shape","styleObj","getModel","getLineStyle","useStyle","style","buildLabelLinePath","moveTo","lineTo","moveLen","midPoint0","lerp","midPoint2","midPoint1","bezierCurveTo","setLabelLineStyle","targetEl","statesModels","defaultStyle","removeTextGuideLine","normalModel","normal","showNormal","labelIgnoreNormal","DISPLAY_STATES","stateShow","isLabelIgnored","retrieve2","states","Polyline","setTextGuideLine","stateProxy","defaults","fill","showAbove","labelLineConfig","buildPath","getLabelLineStatesModels","itemModel","labelLineName","SPECIAL_STATES"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar graphic_1 = require(\"../util/graphic\");\n\nvar PathProxy_1 = require(\"zrender/lib/core/PathProxy\");\n\nvar util_1 = require(\"zrender/lib/contain/util\");\n\nvar curve_1 = require(\"zrender/lib/core/curve\");\n\nvar util_2 = require(\"zrender/lib/core/util\");\n\nvar matrix_1 = require(\"zrender/lib/core/matrix\");\n\nvar vector = require(\"zrender/lib/core/vector\");\n\nvar states_1 = require(\"../util/states\");\n\nvar PI2 = Math.PI * 2;\nvar CMD = PathProxy_1[\"default\"].CMD;\nvar DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left'];\n\nfunction getCandidateAnchor(pos, distance, rect, outPt, outDir) {\n  var width = rect.width;\n  var height = rect.height;\n\n  switch (pos) {\n    case 'top':\n      outPt.set(rect.x + width / 2, rect.y - distance);\n      outDir.set(0, -1);\n      break;\n\n    case 'bottom':\n      outPt.set(rect.x + width / 2, rect.y + height + distance);\n      outDir.set(0, 1);\n      break;\n\n    case 'left':\n      outPt.set(rect.x - distance, rect.y + height / 2);\n      outDir.set(-1, 0);\n      break;\n\n    case 'right':\n      outPt.set(rect.x + width + distance, rect.y + height / 2);\n      outDir.set(1, 0);\n      break;\n  }\n}\n\nfunction projectPointToArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n  x /= d;\n  y /= d;\n  var ox = x * r + cx;\n  var oy = y * r + cy;\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = util_1.normalizeRadian(endAngle);\n    endAngle = util_1.normalizeRadian(tmp);\n  } else {\n    startAngle = util_1.normalizeRadian(startAngle);\n    endAngle = util_1.normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n    out[0] = ox;\n    out[1] = oy;\n    return d - r;\n  }\n\n  var x1 = r * Math.cos(startAngle) + cx;\n  var y1 = r * Math.sin(startAngle) + cy;\n  var x2 = r * Math.cos(endAngle) + cx;\n  var y2 = r * Math.sin(endAngle) + cy;\n  var d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y);\n  var d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y);\n\n  if (d1 < d2) {\n    out[0] = x1;\n    out[1] = y1;\n    return Math.sqrt(d1);\n  } else {\n    out[0] = x2;\n    out[1] = y2;\n    return Math.sqrt(d2);\n  }\n}\n\nfunction projectPointToLine(x1, y1, x2, y2, x, y, out, limitToEnds) {\n  var dx = x - x1;\n  var dy = y - y1;\n  var dx1 = x2 - x1;\n  var dy1 = y2 - y1;\n  var lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n  dx1 /= lineLen;\n  dy1 /= lineLen;\n  var projectedLen = dx * dx1 + dy * dy1;\n  var t = projectedLen / lineLen;\n\n  if (limitToEnds) {\n    t = Math.min(Math.max(t, 0), 1);\n  }\n\n  t *= lineLen;\n  var ox = out[0] = x1 + t * dx1;\n  var oy = out[1] = y1 + t * dy1;\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nfunction projectPointToRect(x1, y1, width, height, x, y, out) {\n  if (width < 0) {\n    x1 = x1 + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y1 = y1 + height;\n    height = -height;\n  }\n\n  var x2 = x1 + width;\n  var y2 = y1 + height;\n  var ox = out[0] = Math.min(Math.max(x, x1), x2);\n  var oy = out[1] = Math.min(Math.max(y, y1), y2);\n  return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y));\n}\n\nvar tmpPt = [];\n\nfunction nearestPointOnRect(pt, rect, out) {\n  var dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt);\n  out.set(tmpPt[0], tmpPt[1]);\n  return dist;\n}\n\nfunction nearestPointOnPath(pt, path, out) {\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  var x1;\n  var y1;\n  var minDist = Infinity;\n  var data = path.data;\n  var x = pt.x;\n  var y = pt.y;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++];\n\n    if (i === 1) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    var d = minDist;\n\n    switch (cmd) {\n      case CMD.M:\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        d = curve_1.cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        d = curve_1.quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt);\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        i += 1;\n        var anticlockwise = !!(1 - data[i++]);\n        x1 = Math.cos(theta) * rx + cx;\n        y1 = Math.sin(theta) * ry + cy;\n\n        if (i <= 1) {\n          x0 = x1;\n          y0 = y1;\n        }\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt);\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        d = projectPointToRect(x0, y0, width, height, x, y, tmpPt);\n        break;\n\n      case CMD.Z:\n        d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n\n    if (d < minDist) {\n      minDist = d;\n      out.set(tmpPt[0], tmpPt[1]);\n    }\n  }\n\n  return minDist;\n}\n\nvar pt0 = new graphic_1.Point();\nvar pt1 = new graphic_1.Point();\nvar pt2 = new graphic_1.Point();\nvar dir = new graphic_1.Point();\nvar dir2 = new graphic_1.Point();\n\nfunction updateLabelLinePoints(target, labelLineModel) {\n  if (!target) {\n    return;\n  }\n\n  var labelLine = target.getTextGuideLine();\n  var label = target.getTextContent();\n\n  if (!(label && labelLine)) {\n    return;\n  }\n\n  var labelGuideConfig = target.textGuideLineConfig || {};\n  var points = [[0, 0], [0, 0], [0, 0]];\n  var searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE;\n  var labelRect = label.getBoundingRect().clone();\n  labelRect.applyTransform(label.getComputedTransform());\n  var minDist = Infinity;\n  var anchorPoint = labelGuideConfig.anchor;\n  var targetTransform = target.getComputedTransform();\n  var targetInversedTransform = targetTransform && matrix_1.invert([], targetTransform);\n  var len = labelLineModel.get('length2') || 0;\n\n  if (anchorPoint) {\n    pt2.copy(anchorPoint);\n  }\n\n  for (var i = 0; i < searchSpace.length; i++) {\n    var candidate = searchSpace[i];\n    getCandidateAnchor(candidate, 0, labelRect, pt0, dir);\n    graphic_1.Point.scaleAndAdd(pt1, pt0, dir, len);\n    pt1.transform(targetInversedTransform);\n    var boundingRect = target.getBoundingRect();\n    var dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof graphic_1.Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2);\n\n    if (dist < minDist) {\n      minDist = dist;\n      pt1.transform(targetTransform);\n      pt2.transform(targetTransform);\n      pt2.toArray(points[0]);\n      pt1.toArray(points[1]);\n      pt0.toArray(points[2]);\n    }\n  }\n\n  limitTurnAngle(points, labelLineModel.get('minTurnAngle'));\n  labelLine.setShape({\n    points: points\n  });\n}\n\nexports.updateLabelLinePoints = updateLabelLinePoints;\nvar tmpArr = [];\nvar tmpProjPoint = new graphic_1.Point();\n\nfunction limitTurnAngle(linePoints, minTurnAngle) {\n  if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {\n    return;\n  }\n\n  minTurnAngle = minTurnAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  graphic_1.Point.sub(dir, pt0, pt1);\n  graphic_1.Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(dir2);\n  var minTurnAngleCos = Math.cos(minTurnAngle);\n\n  if (minTurnAngleCos < angleCos) {\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle));\n    var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n    if (isNaN(t)) {\n      return;\n    }\n\n    if (t < 0) {\n      graphic_1.Point.copy(tmpProjPoint, pt1);\n    } else if (t > 1) {\n      graphic_1.Point.copy(tmpProjPoint, pt2);\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nexports.limitTurnAngle = limitTurnAngle;\n\nfunction limitSurfaceAngle(linePoints, surfaceNormal, maxSurfaceAngle) {\n  if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {\n    return;\n  }\n\n  maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI;\n  pt0.fromArray(linePoints[0]);\n  pt1.fromArray(linePoints[1]);\n  pt2.fromArray(linePoints[2]);\n  graphic_1.Point.sub(dir, pt1, pt0);\n  graphic_1.Point.sub(dir2, pt2, pt1);\n  var len1 = dir.len();\n  var len2 = dir2.len();\n\n  if (len1 < 1e-3 || len2 < 1e-3) {\n    return;\n  }\n\n  dir.scale(1 / len1);\n  dir2.scale(1 / len2);\n  var angleCos = dir.dot(surfaceNormal);\n  var maxSurfaceAngleCos = Math.cos(maxSurfaceAngle);\n\n  if (angleCos < maxSurfaceAngleCos) {\n    var d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false);\n    tmpProjPoint.fromArray(tmpArr);\n    var HALF_PI = Math.PI / 2;\n    var angle2 = Math.acos(dir2.dot(surfaceNormal));\n    var newAngle = HALF_PI + angle2 - maxSurfaceAngle;\n\n    if (newAngle >= HALF_PI) {\n      graphic_1.Point.copy(tmpProjPoint, pt2);\n    } else {\n      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle));\n      var t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y);\n\n      if (isNaN(t)) {\n        return;\n      }\n\n      if (t < 0) {\n        graphic_1.Point.copy(tmpProjPoint, pt1);\n      } else if (t > 1) {\n        graphic_1.Point.copy(tmpProjPoint, pt2);\n      }\n    }\n\n    tmpProjPoint.toArray(linePoints[1]);\n  }\n}\n\nexports.limitSurfaceAngle = limitSurfaceAngle;\n\nfunction setLabelLineState(labelLine, ignore, stateName, stateModel) {\n  var isNormal = stateName === 'normal';\n  var stateObj = isNormal ? labelLine : labelLine.ensureState(stateName);\n  stateObj.ignore = ignore;\n  var smooth = stateModel.get('smooth');\n\n  if (smooth && smooth === true) {\n    smooth = 0.3;\n  }\n\n  stateObj.shape = stateObj.shape || {};\n\n  if (smooth > 0) {\n    stateObj.shape.smooth = smooth;\n  }\n\n  var styleObj = stateModel.getModel('lineStyle').getLineStyle();\n  isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj;\n}\n\nfunction buildLabelLinePath(path, shape) {\n  var smooth = shape.smooth;\n  var points = shape.points;\n\n  if (!points) {\n    return;\n  }\n\n  path.moveTo(points[0][0], points[0][1]);\n\n  if (smooth > 0 && points.length >= 3) {\n    var len1 = vector.dist(points[0], points[1]);\n    var len2 = vector.dist(points[1], points[2]);\n\n    if (!len1 || !len2) {\n      path.lineTo(points[1][0], points[1][1]);\n      path.lineTo(points[2][0], points[2][1]);\n      return;\n    }\n\n    var moveLen = Math.min(len1, len2) * smooth;\n    var midPoint0 = vector.lerp([], points[1], points[0], moveLen / len1);\n    var midPoint2 = vector.lerp([], points[1], points[2], moveLen / len2);\n    var midPoint1 = vector.lerp([], midPoint0, midPoint2, 0.5);\n    path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1]);\n    path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1]);\n  } else {\n    for (var i = 1; i < points.length; i++) {\n      path.lineTo(points[i][0], points[i][1]);\n    }\n  }\n}\n\nfunction setLabelLineStyle(targetEl, statesModels, defaultStyle) {\n  var labelLine = targetEl.getTextGuideLine();\n  var label = targetEl.getTextContent();\n\n  if (!label) {\n    if (labelLine) {\n      targetEl.removeTextGuideLine();\n    }\n\n    return;\n  }\n\n  var normalModel = statesModels.normal;\n  var showNormal = normalModel.get('show');\n  var labelIgnoreNormal = label.ignore;\n\n  for (var i = 0; i < states_1.DISPLAY_STATES.length; i++) {\n    var stateName = states_1.DISPLAY_STATES[i];\n    var stateModel = statesModels[stateName];\n    var isNormal = stateName === 'normal';\n\n    if (stateModel) {\n      var stateShow = stateModel.get('show');\n      var isLabelIgnored = isNormal ? labelIgnoreNormal : util_2.retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal);\n\n      if (isLabelIgnored || !util_2.retrieve2(stateShow, showNormal)) {\n        var stateObj = isNormal ? labelLine : labelLine && labelLine.states.normal;\n\n        if (stateObj) {\n          stateObj.ignore = true;\n        }\n\n        continue;\n      }\n\n      if (!labelLine) {\n        labelLine = new graphic_1.Polyline();\n        targetEl.setTextGuideLine(labelLine);\n\n        if (!isNormal && (labelIgnoreNormal || !showNormal)) {\n          setLabelLineState(labelLine, true, 'normal', statesModels.normal);\n        }\n\n        if (targetEl.stateProxy) {\n          labelLine.stateProxy = targetEl.stateProxy;\n        }\n      }\n\n      setLabelLineState(labelLine, false, stateName, stateModel);\n    }\n  }\n\n  if (labelLine) {\n    util_2.defaults(labelLine.style, defaultStyle);\n    labelLine.style.fill = null;\n    var showAbove = normalModel.get('showAbove');\n    var labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {};\n    labelLineConfig.showAbove = showAbove || false;\n    labelLine.buildPath = buildLabelLinePath;\n  }\n}\n\nexports.setLabelLineStyle = setLabelLineStyle;\n\nfunction getLabelLineStatesModels(itemModel, labelLineName) {\n  labelLineName = labelLineName || 'labelLine';\n  var statesModels = {\n    normal: itemModel.getModel(labelLineName)\n  };\n\n  for (var i = 0; i < states_1.SPECIAL_STATES.length; i++) {\n    var stateName = states_1.SPECIAL_STATES[i];\n    statesModels[stateName] = itemModel.getModel([stateName, labelLineName]);\n  }\n\n  return statesModels;\n}\n\nexports.getLabelLineStatesModels = getLabelLineStatesModels;"]},"metadata":{},"sourceType":"script"}