{"ast":null,"code":"import { vec2 } from '@antv/matrix-util';\nimport { catmullRom2Bezier } from '@antv/path-util';\n/**\n * 替换字符串中的字段\n * @param {String} str 模版字符串\n * @param {Object} o json data\n */\n\nvar substitute = function substitute(str, o) {\n  if (!str || !o) {\n    return str;\n  }\n\n  return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {\n    if (match.charAt(0) === '\\\\') {\n      return match.slice(1);\n    }\n\n    var res = o[name];\n    if (res === 0) res = '0';\n    return res || '';\n  });\n};\n/**\n * 给定坐标获取三次贝塞尔曲线的 M 及 C 值\n * @param points coordinate set\n */\n\n\nexport var getSpline = function getSpline(points) {\n  var data = [];\n\n  if (points.length < 2) {\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\n  }\n\n  for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n    var point = points_1[_i];\n    var x = point.x,\n        y = point.y;\n    data.push(x);\n    data.push(y);\n  }\n\n  var spliePath = catmullRom2Bezier(data);\n  spliePath.unshift(['M', points[0].x, points[0].y]);\n  return spliePath;\n};\n/**\n * 根据起始点、相对位置、偏移量计算控制点\n * @param  {IPoint} startPoint 起始点，包含 x,y\n * @param  {IPoint} endPoint  结束点, 包含 x,y\n * @param  {Number} percent   相对位置,范围 0-1\n * @param  {Number} offset    偏移量\n * @return {IPoint} 控制点，包含 x,y\n */\n\nexport var getControlPoint = function getControlPoint(startPoint, endPoint, percent, offset) {\n  if (percent === void 0) {\n    percent = 0;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var point = {\n    x: (1 - percent) * startPoint.x + percent * endPoint.x,\n    y: (1 - percent) * startPoint.y + percent * endPoint.y\n  };\n  var tangent = [];\n  vec2.normalize(tangent, [endPoint.x - startPoint.x, endPoint.y - startPoint.y]);\n\n  if (tangent.length === 0) {\n    tangent = [0, 0];\n  }\n\n  var perpendicular = [-tangent[1] * offset, tangent[0] * offset]; // 垂直向量\n\n  point.x += perpendicular[0];\n  point.y += perpendicular[1];\n  return point;\n};\n/**\n * 点集转化为Path多边形\n * @param {Array} points 点集\n * @param {Boolen} z 是否封闭\n * @return {Array} Path\n */\n\nexport var pointsToPolygon = function pointsToPolygon(points, z) {\n  var length = points.length;\n\n  if (!length) {\n    return '';\n  }\n\n  var path = '';\n  var str = '';\n\n  for (var i = 0; i < length; i++) {\n    var item = points[i];\n\n    if (i === 0) {\n      str = 'M{x} {y}';\n    } else {\n      str = 'L{x} {y}';\n    }\n\n    path += substitute(str, item);\n  }\n\n  if (z) {\n    path += 'Z';\n  }\n\n  return path;\n};\nexport var pathToPoints = function pathToPoints(path) {\n  var points = [];\n  path.forEach(function (seg) {\n    var command = seg[0];\n\n    if (command !== 'A') {\n      for (var i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i], seg[i + 1]]);\n      }\n    } else {\n      var length_1 = seg.length;\n      points.push([seg[length_1 - 2], seg[length_1 - 1]]);\n    }\n  });\n  return points;\n};\n/**\n * 生成平滑的闭合曲线\n * @param points\n */\n\nexport var getClosedSpline = function getClosedSpline(points) {\n  if (points.length < 2) {\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\n  }\n\n  var first = points[0];\n  var second = points[1];\n  var last = points[points.length - 1];\n  var lastSecond = points[points.length - 2];\n  points.unshift(last);\n  points.unshift(lastSecond);\n  points.push(first);\n  points.push(second);\n  var closedPath = [];\n\n  for (var i = 1; i < points.length - 2; i += 1) {\n    var x0 = points[i - 1].x;\n    var y0 = points[i - 1].y;\n    var x1 = points[i].x;\n    var y1 = points[i].y;\n    var x2 = points[i + 1].x;\n    var y2 = points[i + 1].y;\n    var x3 = i !== points.length - 2 ? points[i + 2].x : x2;\n    var y3 = i !== points.length - 2 ? points[i + 2].y : y2;\n    var cp1x = x1 + (x2 - x0) / 6;\n    var cp1y = y1 + (y2 - y0) / 6;\n    var cp2x = x2 - (x3 - x1) / 6;\n    var cp2y = y2 - (y3 - y1) / 6;\n    closedPath.push(['C', cp1x, cp1y, cp2x, cp2y, x2, y2]);\n  }\n\n  closedPath.unshift(['M', last.x, last.y]);\n  return closedPath;\n};\n\nvar vecScaleTo = function vecScaleTo(v, length) {\n  // Vector with direction of v with specified length\n  return vec2.scale([], vec2.normalize([], v), length);\n};\n\nvar unitNormal = function unitNormal(p0, p1) {\n  // Returns the unit normal to the line segment from p0 to p1.\n  var n = [p0[1] - p1[1], p1[0] - p0[0]];\n  var nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);\n\n  if (nLength === 0) {\n    throw new Error('p0 should not be equal to p1');\n  }\n\n  return [n[0] / nLength, n[1] / nLength];\n};\n\nvar vecFrom = function vecFrom(p0, p1) {\n  // Vector from p0 to p1\n  return [p1[0] - p0[0], p1[1] - p0[1]];\n};\n/**\n * 传入的节点作为多边形顶点，生成有圆角的多边形\n * @param polyPoints 多边形顶点\n * @param padding 在原多边形基础上增加最终轮廓和原多边形的空白间隔\n */\n\n\nexport function roundedHull(polyPoints, padding) {\n  // The rounded hull path around a single point\n  var roundedHull1 = function roundedHull1(points) {\n    var p1 = [points[0][0], points[0][1] - padding];\n    var p2 = [points[0][0], points[0][1] + padding];\n    return \"M \" + p1 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p2 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p1;\n  }; // The rounded hull path around two points\n\n\n  var roundedHull2 = function roundedHull2(points) {\n    var offsetVector = vec2.scale([], unitNormal(points[0], points[1]), padding);\n    var invOffsetVector = vec2.scale([], offsetVector, -1);\n    var p0 = vec2.add([], points[0], offsetVector);\n    var p1 = vec2.add([], points[1], offsetVector);\n    var p2 = vec2.add([], points[1], invOffsetVector);\n    var p3 = vec2.add([], points[0], invOffsetVector);\n    return \"M \" + p0 + \" L \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" L \" + p3 + \" A \" + [padding, padding, '0,0,0', p0].join(',');\n  }; // 特殊情况处理：节点数小于等于2\n\n\n  if (!polyPoints || polyPoints.length < 1) return '';\n  if (polyPoints.length === 1) return roundedHull1(polyPoints);\n  if (polyPoints.length === 2) return roundedHull2(polyPoints);\n  var segments = new Array(polyPoints.length); // Calculate each offset (outwards) segment of the convex hull.\n\n  for (var segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {\n    var p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];\n    var p1 = polyPoints[segmentIndex]; // Compute the offset vector for the line segment, with length = padding.\n\n    var offset = vec2.scale([], unitNormal(p0, p1), padding);\n    segments[segmentIndex] = [vec2.add([], p0, offset), vec2.add([], p1, offset)];\n  }\n\n  var arcData = \"A \" + [padding, padding, '0,0,0,'].join(',');\n  segments = segments.map(function (segment, index) {\n    var pathFragment = '';\n\n    if (index === 0) {\n      pathFragment = \"M \" + segments[segments.length - 1][1] + \" \";\n    }\n\n    pathFragment += arcData + segment[0] + \" L \" + segment[1];\n    return pathFragment;\n  });\n  return segments.join(' ');\n}\n/**\n * 传入的节点作为多边形顶点，生成平滑的闭合多边形\n * @param polyPoints\n * @param padding\n */\n\nexport function paddedHull(polyPoints, padding) {\n  var pointCount = polyPoints.length;\n\n  var smoothHull1 = function smoothHull1(points) {\n    // Returns the path for a circular hull around a single point.\n    var p1 = [points[0][0], points[0][1] - padding];\n    var p2 = [points[0][0], points[0][1] + padding];\n    return \"M \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" A \" + [padding, padding, '0,0,0', p1].join(',');\n  }; // Returns the path for a rounded hull around two points.\n\n\n  var smoothHull2 = function smoothHull2(points) {\n    var v = vecFrom(points[0], points[1]);\n    var extensionVec = vecScaleTo(v, padding);\n    var extension0 = vec2.add([], points[0], vec2.scale([], extensionVec, -1));\n    var extension1 = vec2.add([], points[1], extensionVec);\n    var tangentHalfLength = 1.2 * padding;\n    var controlDelta = vecScaleTo(vec2.normalize([], v), tangentHalfLength);\n    var invControlDelta = vec2.scale([], controlDelta, -1);\n    var control0 = vec2.add([], extension0, invControlDelta);\n    var control1 = vec2.add([], extension1, invControlDelta);\n    var control3 = vec2.add([], extension0, controlDelta);\n    return \"M \" + extension0 + \" C \" + [control0, control1, extension1].join(',') + \" S \" + [control3, extension0].join(',') + \" Z\";\n  }; // Handle special cases\n\n\n  if (!polyPoints || pointCount < 1) return '';\n  if (pointCount === 1) return smoothHull1(polyPoints);\n  if (pointCount === 2) return smoothHull2(polyPoints);\n  var hullPoints = polyPoints.map(function (point, index) {\n    var pNext = polyPoints[(index + 1) % pointCount];\n    return {\n      p: point,\n      v: vec2.normalize([], vecFrom(point, pNext))\n    };\n  }); // Compute the expanded hull points, and the nearest prior control point for each.\n\n  for (var i = 0; i < hullPoints.length; ++i) {\n    var priorIndex = i > 0 ? i - 1 : pointCount - 1;\n    var extensionVec = vec2.normalize([], vec2.add([], hullPoints[priorIndex].v, vec2.scale([], hullPoints[i].v, -1)));\n    hullPoints[i].p = vec2.add([], hullPoints[i].p, vec2.scale([], extensionVec, padding));\n  }\n\n  return hullPoints.map(function (obj) {\n    var point = obj.p;\n    return {\n      x: point[0],\n      y: point[1]\n    };\n  });\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/util/path.js"],"names":["vec2","catmullRom2Bezier","substitute","str","o","replace","match","name","charAt","slice","res","getSpline","points","data","length","Error","_i","points_1","point","x","y","push","spliePath","unshift","getControlPoint","startPoint","endPoint","percent","offset","tangent","normalize","perpendicular","pointsToPolygon","z","path","i","item","pathToPoints","forEach","seg","command","length_1","getClosedSpline","first","second","last","lastSecond","closedPath","x0","y0","x1","y1","x2","y2","x3","y3","cp1x","cp1y","cp2x","cp2y","vecScaleTo","v","scale","unitNormal","p0","p1","n","nLength","Math","sqrt","vecFrom","roundedHull","polyPoints","padding","roundedHull1","p2","roundedHull2","offsetVector","invOffsetVector","add","p3","join","segments","Array","segmentIndex","arcData","map","segment","index","pathFragment","paddedHull","pointCount","smoothHull1","smoothHull2","extensionVec","extension0","extension1","tangentHalfLength","controlDelta","invControlDelta","control0","control1","control3","hullPoints","pNext","p","priorIndex","obj"],"mappings":"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","sourcesContent":["import { vec2 } from '@antv/matrix-util';\nimport { catmullRom2Bezier } from '@antv/path-util';\n/**\n * 替换字符串中的字段\n * @param {String} str 模版字符串\n * @param {Object} o json data\n */\n\nvar substitute = function substitute(str, o) {\n  if (!str || !o) {\n    return str;\n  }\n\n  return str.replace(/\\\\?\\{([^{}]+)\\}/g, function (match, name) {\n    if (match.charAt(0) === '\\\\') {\n      return match.slice(1);\n    }\n\n    var res = o[name];\n    if (res === 0) res = '0';\n    return res || '';\n  });\n};\n/**\n * 给定坐标获取三次贝塞尔曲线的 M 及 C 值\n * @param points coordinate set\n */\n\n\nexport var getSpline = function getSpline(points) {\n  var data = [];\n\n  if (points.length < 2) {\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\n  }\n\n  for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n    var point = points_1[_i];\n    var x = point.x,\n        y = point.y;\n    data.push(x);\n    data.push(y);\n  }\n\n  var spliePath = catmullRom2Bezier(data);\n  spliePath.unshift(['M', points[0].x, points[0].y]);\n  return spliePath;\n};\n/**\n * 根据起始点、相对位置、偏移量计算控制点\n * @param  {IPoint} startPoint 起始点，包含 x,y\n * @param  {IPoint} endPoint  结束点, 包含 x,y\n * @param  {Number} percent   相对位置,范围 0-1\n * @param  {Number} offset    偏移量\n * @return {IPoint} 控制点，包含 x,y\n */\n\nexport var getControlPoint = function getControlPoint(startPoint, endPoint, percent, offset) {\n  if (percent === void 0) {\n    percent = 0;\n  }\n\n  if (offset === void 0) {\n    offset = 0;\n  }\n\n  var point = {\n    x: (1 - percent) * startPoint.x + percent * endPoint.x,\n    y: (1 - percent) * startPoint.y + percent * endPoint.y\n  };\n  var tangent = [];\n  vec2.normalize(tangent, [endPoint.x - startPoint.x, endPoint.y - startPoint.y]);\n\n  if (tangent.length === 0) {\n    tangent = [0, 0];\n  }\n\n  var perpendicular = [-tangent[1] * offset, tangent[0] * offset]; // 垂直向量\n\n  point.x += perpendicular[0];\n  point.y += perpendicular[1];\n  return point;\n};\n/**\n * 点集转化为Path多边形\n * @param {Array} points 点集\n * @param {Boolen} z 是否封闭\n * @return {Array} Path\n */\n\nexport var pointsToPolygon = function pointsToPolygon(points, z) {\n  var length = points.length;\n\n  if (!length) {\n    return '';\n  }\n\n  var path = '';\n  var str = '';\n\n  for (var i = 0; i < length; i++) {\n    var item = points[i];\n\n    if (i === 0) {\n      str = 'M{x} {y}';\n    } else {\n      str = 'L{x} {y}';\n    }\n\n    path += substitute(str, item);\n  }\n\n  if (z) {\n    path += 'Z';\n  }\n\n  return path;\n};\nexport var pathToPoints = function pathToPoints(path) {\n  var points = [];\n  path.forEach(function (seg) {\n    var command = seg[0];\n\n    if (command !== 'A') {\n      for (var i = 1; i < seg.length; i = i + 2) {\n        points.push([seg[i], seg[i + 1]]);\n      }\n    } else {\n      var length_1 = seg.length;\n      points.push([seg[length_1 - 2], seg[length_1 - 1]]);\n    }\n  });\n  return points;\n};\n/**\n * 生成平滑的闭合曲线\n * @param points\n */\n\nexport var getClosedSpline = function getClosedSpline(points) {\n  if (points.length < 2) {\n    throw new Error(\"point length must largn than 2, now it's \" + points.length);\n  }\n\n  var first = points[0];\n  var second = points[1];\n  var last = points[points.length - 1];\n  var lastSecond = points[points.length - 2];\n  points.unshift(last);\n  points.unshift(lastSecond);\n  points.push(first);\n  points.push(second);\n  var closedPath = [];\n\n  for (var i = 1; i < points.length - 2; i += 1) {\n    var x0 = points[i - 1].x;\n    var y0 = points[i - 1].y;\n    var x1 = points[i].x;\n    var y1 = points[i].y;\n    var x2 = points[i + 1].x;\n    var y2 = points[i + 1].y;\n    var x3 = i !== points.length - 2 ? points[i + 2].x : x2;\n    var y3 = i !== points.length - 2 ? points[i + 2].y : y2;\n    var cp1x = x1 + (x2 - x0) / 6;\n    var cp1y = y1 + (y2 - y0) / 6;\n    var cp2x = x2 - (x3 - x1) / 6;\n    var cp2y = y2 - (y3 - y1) / 6;\n    closedPath.push(['C', cp1x, cp1y, cp2x, cp2y, x2, y2]);\n  }\n\n  closedPath.unshift(['M', last.x, last.y]);\n  return closedPath;\n};\n\nvar vecScaleTo = function vecScaleTo(v, length) {\n  // Vector with direction of v with specified length\n  return vec2.scale([], vec2.normalize([], v), length);\n};\n\nvar unitNormal = function unitNormal(p0, p1) {\n  // Returns the unit normal to the line segment from p0 to p1.\n  var n = [p0[1] - p1[1], p1[0] - p0[0]];\n  var nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);\n\n  if (nLength === 0) {\n    throw new Error('p0 should not be equal to p1');\n  }\n\n  return [n[0] / nLength, n[1] / nLength];\n};\n\nvar vecFrom = function vecFrom(p0, p1) {\n  // Vector from p0 to p1\n  return [p1[0] - p0[0], p1[1] - p0[1]];\n};\n/**\n * 传入的节点作为多边形顶点，生成有圆角的多边形\n * @param polyPoints 多边形顶点\n * @param padding 在原多边形基础上增加最终轮廓和原多边形的空白间隔\n */\n\n\nexport function roundedHull(polyPoints, padding) {\n  // The rounded hull path around a single point\n  var roundedHull1 = function roundedHull1(points) {\n    var p1 = [points[0][0], points[0][1] - padding];\n    var p2 = [points[0][0], points[0][1] + padding];\n    return \"M \" + p1 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p2 + \" A \" + padding + \",\" + padding + \",0,0,0,\" + p1;\n  }; // The rounded hull path around two points\n\n\n  var roundedHull2 = function roundedHull2(points) {\n    var offsetVector = vec2.scale([], unitNormal(points[0], points[1]), padding);\n    var invOffsetVector = vec2.scale([], offsetVector, -1);\n    var p0 = vec2.add([], points[0], offsetVector);\n    var p1 = vec2.add([], points[1], offsetVector);\n    var p2 = vec2.add([], points[1], invOffsetVector);\n    var p3 = vec2.add([], points[0], invOffsetVector);\n    return \"M \" + p0 + \" L \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" L \" + p3 + \" A \" + [padding, padding, '0,0,0', p0].join(',');\n  }; // 特殊情况处理：节点数小于等于2\n\n\n  if (!polyPoints || polyPoints.length < 1) return '';\n  if (polyPoints.length === 1) return roundedHull1(polyPoints);\n  if (polyPoints.length === 2) return roundedHull2(polyPoints);\n  var segments = new Array(polyPoints.length); // Calculate each offset (outwards) segment of the convex hull.\n\n  for (var segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {\n    var p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];\n    var p1 = polyPoints[segmentIndex]; // Compute the offset vector for the line segment, with length = padding.\n\n    var offset = vec2.scale([], unitNormal(p0, p1), padding);\n    segments[segmentIndex] = [vec2.add([], p0, offset), vec2.add([], p1, offset)];\n  }\n\n  var arcData = \"A \" + [padding, padding, '0,0,0,'].join(',');\n  segments = segments.map(function (segment, index) {\n    var pathFragment = '';\n\n    if (index === 0) {\n      pathFragment = \"M \" + segments[segments.length - 1][1] + \" \";\n    }\n\n    pathFragment += arcData + segment[0] + \" L \" + segment[1];\n    return pathFragment;\n  });\n  return segments.join(' ');\n}\n/**\n * 传入的节点作为多边形顶点，生成平滑的闭合多边形\n * @param polyPoints\n * @param padding\n */\n\nexport function paddedHull(polyPoints, padding) {\n  var pointCount = polyPoints.length;\n\n  var smoothHull1 = function smoothHull1(points) {\n    // Returns the path for a circular hull around a single point.\n    var p1 = [points[0][0], points[0][1] - padding];\n    var p2 = [points[0][0], points[0][1] + padding];\n    return \"M \" + p1 + \" A \" + [padding, padding, '0,0,0', p2].join(',') + \" A \" + [padding, padding, '0,0,0', p1].join(',');\n  }; // Returns the path for a rounded hull around two points.\n\n\n  var smoothHull2 = function smoothHull2(points) {\n    var v = vecFrom(points[0], points[1]);\n    var extensionVec = vecScaleTo(v, padding);\n    var extension0 = vec2.add([], points[0], vec2.scale([], extensionVec, -1));\n    var extension1 = vec2.add([], points[1], extensionVec);\n    var tangentHalfLength = 1.2 * padding;\n    var controlDelta = vecScaleTo(vec2.normalize([], v), tangentHalfLength);\n    var invControlDelta = vec2.scale([], controlDelta, -1);\n    var control0 = vec2.add([], extension0, invControlDelta);\n    var control1 = vec2.add([], extension1, invControlDelta);\n    var control3 = vec2.add([], extension0, controlDelta);\n    return \"M \" + extension0 + \" C \" + [control0, control1, extension1].join(',') + \" S \" + [control3, extension0].join(',') + \" Z\";\n  }; // Handle special cases\n\n\n  if (!polyPoints || pointCount < 1) return '';\n  if (pointCount === 1) return smoothHull1(polyPoints);\n  if (pointCount === 2) return smoothHull2(polyPoints);\n  var hullPoints = polyPoints.map(function (point, index) {\n    var pNext = polyPoints[(index + 1) % pointCount];\n    return {\n      p: point,\n      v: vec2.normalize([], vecFrom(point, pNext))\n    };\n  }); // Compute the expanded hull points, and the nearest prior control point for each.\n\n  for (var i = 0; i < hullPoints.length; ++i) {\n    var priorIndex = i > 0 ? i - 1 : pointCount - 1;\n    var extensionVec = vec2.normalize([], vec2.add([], hullPoints[priorIndex].v, vec2.scale([], hullPoints[i].v, -1)));\n    hullPoints[i].p = vec2.add([], hullPoints[i].p, vec2.scale([], extensionVec, padding));\n  }\n\n  return hullPoints.map(function (obj) {\n    var point = obj.p;\n    return {\n      x: point[0],\n      y: point[1]\n    };\n  });\n}"]},"metadata":{},"sourceType":"module"}