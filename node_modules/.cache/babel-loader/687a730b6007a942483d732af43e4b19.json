{"ast":null,"code":"import PropTypes from 'prop-types';\nimport { scaleLinear, scaleLog, scaleSymlog, scalePoint, scaleUtc, scaleTime } from 'd3-scale';\nimport { utcParse, timeParse } from 'd3-time-format';\nimport uniq from 'lodash/uniq';\nimport uniqBy from 'lodash/uniqBy';\nimport sortBy from 'lodash/sortBy';\nimport last from 'lodash/last';\nimport isDate from 'lodash/isDate';\n\nvar linearScale = function linearScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 0 : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$stacked = _ref.stacked,\n      stacked = _ref$stacked === void 0 ? false : _ref$stacked,\n      _ref$reverse = _ref.reverse,\n      reverse = _ref$reverse === void 0 ? false : _ref$reverse;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = stacked === true ? values.minStacked : values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = stacked === true ? values.maxStacked : values.max;\n  }\n\n  var scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0]);\n  if (reverse === true) scale.domain([maxValue, minValue]);else scale.domain([minValue, maxValue]);\n  scale.type = 'linear';\n  scale.stacked = stacked;\n  return scale;\n};\n\nvar linearScalePropTypes = {\n  type: PropTypes.oneOf(['linear']).isRequired,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  stacked: PropTypes.bool,\n  reverse: PropTypes.bool\n};\n\nvar logScale = function logScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$base = _ref.base,\n      base = _ref$base === void 0 ? 10 : _ref$base,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var hasZero = values.all.some(function (v) {\n    return v === 0;\n  });\n  var sign;\n  var hasMixedSign = false;\n  values.all.filter(function (v) {\n    return v != null;\n  }).forEach(function (v) {\n    if (hasMixedSign === true) return;\n\n    if (sign === undefined) {\n      sign = Math.sign(v);\n    } else if (Math.sign(v) !== sign) {\n      hasMixedSign = true;\n    }\n  });\n\n  if (hasZero || hasMixedSign) {\n    throw new Error([\"a log scale domain must be strictly-positive or strictly-negative,\", \"and must not include or cross zero.\"].join('\\n'));\n  }\n\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  }\n\n  var scale = scaleLog().domain([minValue, maxValue]).rangeRound(axis === 'x' ? [0, size] : [size, 0]).base(base).nice();\n  scale.type = 'log';\n  return scale;\n};\n\nvar logScalePropTypes = {\n  type: PropTypes.oneOf(['log']).isRequired,\n  base: PropTypes.number,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number])\n};\n\nvar symlogScale = function symlogScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$constant = _ref.constant,\n      constant = _ref$constant === void 0 ? 1 : _ref$constant,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  }\n\n  var scale = scaleSymlog().domain([minValue, maxValue]).constant(constant).rangeRound(axis === 'x' ? [0, size] : [size, 0]).nice();\n  scale.type = 'symlog';\n  return scale;\n};\n\nvar symLogScalePropTypes = {\n  type: PropTypes.oneOf(['symlog']).isRequired,\n  constant: PropTypes.number,\n  min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n  max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number])\n};\n\nvar pointScale = function pointScale(_ref, xy, width, height) {\n  var axis = _ref.axis;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var scale = scalePoint().range([0, size]).domain(values.all);\n  scale.type = 'point';\n  return scale;\n};\n\nvar pointScalePropTypes = {\n  type: PropTypes.oneOf(['point']).isRequired\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar _precisionCutOffsByTy;\n\nvar TIME_PRECISION_MILLISECOND = 'millisecond';\nvar TIME_PRECISION_SECOND = 'second';\nvar TIME_PRECISION_MINUTE = 'minute';\nvar TIME_PRECISION_HOUR = 'hour';\nvar TIME_PRECISION_DAY = 'day';\nvar TIME_PRECISION_MONTH = 'month';\nvar TIME_PRECISION_YEAR = 'year';\nvar timePrecisions = [TIME_PRECISION_MILLISECOND, TIME_PRECISION_SECOND, TIME_PRECISION_MINUTE, TIME_PRECISION_HOUR, TIME_PRECISION_DAY, TIME_PRECISION_MONTH, TIME_PRECISION_YEAR];\nvar precisionCutOffs = [function (date) {\n  return date.setMilliseconds(0);\n}, function (date) {\n  return date.setSeconds(0);\n}, function (date) {\n  return date.setMinutes(0);\n}, function (date) {\n  return date.setHours(0);\n}, function (date) {\n  return date.setDate(1);\n}, function (date) {\n  return date.setMonth(0);\n}];\nvar precisionCutOffsByType = (_precisionCutOffsByTy = {}, _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MILLISECOND, []), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_SECOND, precisionCutOffs.slice(0, 1)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MINUTE, precisionCutOffs.slice(0, 2)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_HOUR, precisionCutOffs.slice(0, 3)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_DAY, precisionCutOffs.slice(0, 4)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_MONTH, precisionCutOffs.slice(0, 5)), _defineProperty(_precisionCutOffsByTy, TIME_PRECISION_YEAR, precisionCutOffs.slice(0, 6)), _precisionCutOffsByTy);\n\nvar createPrecisionMethod = function createPrecisionMethod(precision) {\n  return function (date) {\n    precisionCutOffsByType[precision].forEach(function (cutOff) {\n      cutOff(date);\n    });\n    return date;\n  };\n};\n\nvar createDateNormalizer = function createDateNormalizer(_ref) {\n  var _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? 'millisecond' : _ref$precision,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var precisionFn = createPrecisionMethod(precision);\n  if (format === 'native') return function (v) {\n    return precisionFn(v);\n  };\n  var parseTime = useUTC ? utcParse(format) : timeParse(format);\n  return function (v) {\n    return precisionFn(parseTime(v));\n  };\n};\n\nvar timeScale = function timeScale(_ref, xy, width, height) {\n  var axis = _ref.axis,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'native' : _ref$format,\n      _ref$precision = _ref.precision,\n      precision = _ref$precision === void 0 ? TIME_PRECISION_MILLISECOND : _ref$precision,\n      _ref$min = _ref.min,\n      min = _ref$min === void 0 ? 'auto' : _ref$min,\n      _ref$max = _ref.max,\n      max = _ref$max === void 0 ? 'auto' : _ref$max,\n      _ref$useUTC = _ref.useUTC,\n      useUTC = _ref$useUTC === void 0 ? true : _ref$useUTC;\n  var values = xy[axis];\n  var size = axis === 'x' ? width : height;\n  var normalize = createDateNormalizer({\n    format: format,\n    precision: precision,\n    useUTC: useUTC\n  });\n  var minValue = min;\n\n  if (min === 'auto') {\n    minValue = values.min;\n  } else if (format !== 'native') {\n    minValue = normalize(min);\n  }\n\n  var maxValue = max;\n\n  if (max === 'auto') {\n    maxValue = values.max;\n  } else if (format !== 'native') {\n    maxValue = normalize(max);\n  }\n\n  var scale = useUTC ? scaleUtc() : scaleTime();\n  scale.domain([minValue, maxValue]).range([0, size]);\n  scale.type = 'time';\n  scale.useUTC = useUTC;\n  return scale;\n};\n\nvar timeScalePropTypes = {\n  type: PropTypes.oneOf(['time']).isRequired,\n  format: PropTypes.string,\n  precision: PropTypes.oneOf(timePrecisions)\n};\nvar bandScalePropTypes = {\n  type: PropTypes.oneOf(['band']).isRequired,\n  round: PropTypes.bool\n};\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar getOtherAxis = function getOtherAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n};\n\nvar compareValues = function compareValues(a, b) {\n  return a === b;\n};\n\nvar compareDateValues = function compareDateValues(a, b) {\n  return a.getTime() === b.getTime();\n};\n\nvar computeXYScalesForSeries = function computeXYScalesForSeries(_series, xScaleSpec, yScaleSpec, width, height) {\n  var series = _series.map(function (serie) {\n    return _objectSpread2(_objectSpread2({}, serie), {}, {\n      data: serie.data.map(function (d) {\n        return {\n          data: _objectSpread2({}, d)\n        };\n      })\n    });\n  });\n\n  var xy = generateSeriesXY(series, xScaleSpec, yScaleSpec);\n\n  if (xScaleSpec.stacked === true) {\n    stackX(yScaleSpec.type, xy, series);\n  }\n\n  if (yScaleSpec.stacked === true) {\n    stackY(xScaleSpec.type, xy, series);\n  }\n\n  var xScale = computeScale(_objectSpread2(_objectSpread2({}, xScaleSpec), {}, {\n    axis: 'x'\n  }), xy, width, height);\n  var yScale = computeScale(_objectSpread2(_objectSpread2({}, yScaleSpec), {}, {\n    axis: 'y'\n  }), xy, width, height);\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      d.position = {\n        x: xScale.stacked === true ? d.data.xStacked === null ? null : xScale(d.data.xStacked) : d.data.x === null ? null : xScale(d.data.x),\n        y: yScale.stacked === true ? d.data.yStacked === null ? null : yScale(d.data.yStacked) : d.data.y === null ? null : yScale(d.data.y)\n      };\n    });\n  });\n  return _objectSpread2(_objectSpread2({}, xy), {}, {\n    series: series,\n    xScale: xScale,\n    yScale: yScale\n  });\n};\n\nvar computeScale = function computeScale(spec, xy, width, height) {\n  if (spec.type === 'linear') return linearScale(spec, xy, width, height);else if (spec.type === 'point') return pointScale(spec, xy, width, height);else if (spec.type === 'time') return timeScale(spec, xy, width, height);else if (spec.type === 'log') return logScale(spec, xy, width, height);else if (spec.type === 'symlog') return symlogScale(spec, xy, width, height);\n};\n\nvar generateSeriesXY = function generateSeriesXY(series, xScaleSpec, yScaleSpec) {\n  return {\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec)\n  };\n};\n\nvar generateSeriesAxis = function generateSeriesAxis(series, axis, scaleSpec) {\n  var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n      _ref$getValue = _ref.getValue,\n      getValue = _ref$getValue === void 0 ? function (d) {\n    return d.data[axis];\n  } : _ref$getValue,\n      _ref$setValue = _ref.setValue,\n      setValue = _ref$setValue === void 0 ? function (d, v) {\n    d.data[axis] = v;\n  } : _ref$setValue;\n\n  if (scaleSpec.type === 'linear') {\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)));\n      });\n    });\n  } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n    var parseTime = createDateNormalizer(scaleSpec);\n    series.forEach(function (serie) {\n      serie.data.forEach(function (d) {\n        setValue(d, getValue(d) === null ? null : parseTime(getValue(d)));\n      });\n    });\n  }\n\n  var all = [];\n  series.forEach(function (serie) {\n    serie.data.forEach(function (d) {\n      all.push(getValue(d));\n    });\n  });\n  var min, max;\n\n  if (scaleSpec.type === 'linear') {\n    all = uniq(all);\n    all = sortBy(all, function (v) {\n      return v;\n    });\n    min = Math.min.apply(Math, _toConsumableArray(all));\n    max = Math.max.apply(Math, _toConsumableArray(all));\n  } else if (scaleSpec.type === 'time') {\n    all = uniqBy(all, function (v) {\n      return v.getTime();\n    });\n    all = all.slice(0).sort(function (a, b) {\n      return b - a;\n    }).reverse();\n    min = all[0];\n    max = last(all);\n  } else {\n    all = uniq(all);\n    min = all[0];\n    max = last(all);\n  }\n\n  return {\n    all: all,\n    min: min,\n    max: max\n  };\n};\n\nvar stackAxis = function stackAxis(axis, otherType, xy, series) {\n  var otherAxis = getOtherAxis(axis);\n  var all = [];\n  xy[otherAxis].all.forEach(function (v) {\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    var stack = [];\n    series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n      var value = null;\n      var stackValue = null;\n\n      if (datum !== undefined) {\n        value = datum.data[axis];\n\n        if (value !== null) {\n          var head = last(stack);\n\n          if (head === undefined) {\n            stackValue = value;\n          } else if (head !== null) {\n            stackValue = head + value;\n          }\n        }\n\n        datum.data[\"\".concat(axis, \"Stacked\")] = stackValue;\n      }\n\n      stack.push(stackValue);\n      all.push(stackValue);\n    });\n  });\n  all = all.filter(function (v) {\n    return v !== null;\n  });\n  xy[axis].minStacked = Math.min.apply(Math, _toConsumableArray(all));\n  xy[axis].maxStacked = Math.max.apply(Math, _toConsumableArray(all));\n};\n\nvar stackX = function stackX(xy, otherType, series) {\n  return stackAxis('x', xy, otherType, series);\n};\n\nvar stackY = function stackY(xy, otherType, series) {\n  return stackAxis('y', xy, otherType, series);\n};\n\nvar computeAxisSlices = function computeAxisSlices(axis, data) {\n  var otherAxis = getOtherAxis(axis);\n  return data[otherAxis].all.map(function (v) {\n    var _slice;\n\n    var slice = (_slice = {\n      id: v\n    }, _defineProperty(_slice, otherAxis, data[\"\".concat(otherAxis, \"Scale\")](v)), _defineProperty(_slice, \"data\", []), _slice);\n    var compare = isDate(v) ? compareDateValues : compareValues;\n    data.series.forEach(function (serie) {\n      var datum = serie.data.find(function (d) {\n        return compare(d.data[otherAxis], v);\n      });\n\n      if (datum !== undefined) {\n        slice.data.push(_objectSpread2(_objectSpread2({}, datum), {}, {\n          serie: serie\n        }));\n      }\n    });\n    slice.data.reverse();\n    return slice;\n  });\n};\n\nvar computeXSlices = function computeXSlices(data) {\n  return computeAxisSlices('x', data);\n};\n\nvar computeYSlices = function computeYSlices(data) {\n  return computeAxisSlices('y', data);\n};\n\nvar scalePropType = PropTypes.oneOfType([PropTypes.shape(linearScalePropTypes), PropTypes.shape(pointScalePropTypes), PropTypes.shape(timeScalePropTypes), PropTypes.shape(logScalePropTypes), PropTypes.shape(symLogScalePropTypes), PropTypes.shape(bandScalePropTypes)]);\nexport { TIME_PRECISION_DAY, TIME_PRECISION_HOUR, TIME_PRECISION_MILLISECOND, TIME_PRECISION_MINUTE, TIME_PRECISION_MONTH, TIME_PRECISION_SECOND, TIME_PRECISION_YEAR, bandScalePropTypes, compareDateValues, compareValues, computeAxisSlices, computeScale, computeXSlices, computeXYScalesForSeries, computeYSlices, createDateNormalizer, createPrecisionMethod, generateSeriesAxis, generateSeriesXY, getOtherAxis, linearScale, linearScalePropTypes, logScale, logScalePropTypes, pointScale, pointScalePropTypes, precisionCutOffs, precisionCutOffsByType, scalePropType, stackAxis, stackX, stackY, symLogScalePropTypes, symlogScale, timePrecisions, timeScale, timeScalePropTypes };","map":{"version":3,"sources":["../src/linearScale.js","../src/logScale.js","../src/symlogScale.js","../src/pointScale.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../src/timeHelpers.js","../src/timeScale.js","../src/bandScale.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../src/compute.js","../src/index.js"],"names":["linearScale","axis","min","max","stacked","reverse","values","xy","size","minValue","maxValue","scale","scaleLinear","linearScalePropTypes","type","PropTypes","bool","logScale","base","hasZero","v","hasMixedSign","sign","Math","scaleLog","logScalePropTypes","symlogScale","constant","scaleSymlog","symLogScalePropTypes","pointScale","scalePoint","pointScalePropTypes","isRequired","TIME_PRECISION_MILLISECOND","TIME_PRECISION_SECOND","TIME_PRECISION_MINUTE","TIME_PRECISION_HOUR","TIME_PRECISION_DAY","TIME_PRECISION_MONTH","TIME_PRECISION_YEAR","timePrecisions","precisionCutOffs","date","precisionCutOffsByType","createPrecisionMethod","cutOff","createDateNormalizer","format","precision","useUTC","precisionFn","parseTime","utcParse","timeParse","timeScale","normalize","scaleUtc","scaleTime","timeScalePropTypes","bandScalePropTypes","round","arrayLikeToArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread","defineProperty","getOtherAxis","compareValues","a","compareDateValues","b","computeXYScalesForSeries","series","data","generateSeriesXY","xScaleSpec","stackX","yScaleSpec","stackY","xScale","computeScale","yScale","serie","d","x","y","spec","generateSeriesAxis","getValue","setValue","scaleSpec","parseFloat","all","uniq","sortBy","uniqBy","last","stackAxis","otherAxis","compare","isDate","stack","datum","value","stackValue","head","computeAxisSlices","slice","id","computeXSlices","computeYSlices","scalePropType"],"mappings":";;;;;;;;;IAWaA,WAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,MAAA,EAKtB;AAAA,MAJCC,IAID,GAAA,IAAA,CAJCA,IAID;AAAA,MAAA,QAAA,GAAA,IAAA,CAJOC,GAIP;AAAA,MAJOA,GAIP,GAAA,QAAA,KAAA,KAAA,CAAA,GAJa,CAIb,GAAA,QAAA;AAAA,MAAA,QAAA,GAAA,IAAA,CAJgBC,GAIhB;AAAA,MAJgBA,GAIhB,GAAA,QAAA,KAAA,KAAA,CAAA,GAJsB,MAItB,GAAA,QAAA;AAAA,MAAA,YAAA,GAAA,IAAA,CAJ8BC,OAI9B;AAAA,MAJ8BA,OAI9B,GAAA,YAAA,KAAA,KAAA,CAAA,GAJwC,KAIxC,GAAA,YAAA;AAAA,MAAA,YAAA,GAAA,IAAA,CAJ+CC,OAI/C;AAAA,MAJ+CA,OAI/C,GAAA,YAAA,KAAA,KAAA,CAAA,GAJyD,KAIzD,GAAA,YAAA;AACD,MAAMC,MAAM,GAAGC,EAAE,CAAjB,IAAiB,CAAjB;AACA,MAAMC,IAAI,GAAGP,IAAI,KAAJA,GAAAA,GAAAA,KAAAA,GAAb,MAAA;AAEA,MAAIQ,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGL,OAAO,KAAPA,IAAAA,GAAmBE,MAAM,CAAzBF,UAAAA,GAAuCE,MAAM,CAAxDG,GAAAA;AACH;;AACD,MAAIC,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGN,OAAO,KAAPA,IAAAA,GAAmBE,MAAM,CAAzBF,UAAAA,GAAuCE,MAAM,CAAxDI,GAAAA;AACH;;AAED,MAAMC,KAAK,GAAGC,WAAW,GAAXA,UAAAA,CAAyBX,IAAI,KAAJA,GAAAA,GAAe,CAAA,CAAA,EAAfA,IAAe,CAAfA,GAA2B,CAAA,IAAA,EAAlE,CAAkE,CAApDW,CAAd;AAEA,MAAIP,OAAO,KAAX,IAAA,EAAsBM,KAAK,CAALA,MAAAA,CAAa,CAAA,QAAA,EAAnC,QAAmC,CAAbA,EAAtB,KACKA,KAAK,CAALA,MAAAA,CAAa,CAAA,QAAA,EAAbA,QAAa,CAAbA;AAELA,EAAAA,KAAK,CAALA,IAAAA,GAAAA,QAAAA;AACAA,EAAAA,KAAK,CAALA,OAAAA,GAAAA,OAAAA;AAEA,SAAA,KAAA;AACH,C;;IAEYE,oBAAoB,GAAG;AAChCC,EAAAA,IAAI,EAAEC,SAAS,CAATA,KAAAA,CAAgB,CAAhBA,QAAgB,CAAhBA,EAD0B,UAAA;AAEhCb,EAAAA,GAAG,EAAEa,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,KAAAA,CAAgB,CAAjB,MAAiB,CAAhBA,CAAD,EAA4BA,SAAS,CAF9B,MAEP,CAApBA,CAF2B;AAGhCZ,EAAAA,GAAG,EAAEY,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,KAAAA,CAAgB,CAAjB,MAAiB,CAAhBA,CAAD,EAA4BA,SAAS,CAH9B,MAGP,CAApBA,CAH2B;AAIhCX,EAAAA,OAAO,EAAEW,SAAS,CAJc,IAAA;AAKhCV,EAAAA,OAAO,EAAEU,SAAS,CAACC;AALa,C;;IC7BvBC,QAAQ,GAAG,SAAXA,QAAW,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,MAAA,EAAwE;AAAA,MAArEhB,IAAqE,GAAA,IAAA,CAArEA,IAAqE;AAAA,MAAA,SAAA,GAAA,IAAA,CAA/DiB,IAA+D;AAAA,MAA/DA,IAA+D,GAAA,SAAA,KAAA,KAAA,CAAA,GAAxD,EAAwD,GAAA,SAAA;AAAA,MAAA,QAAA,GAAA,IAAA,CAApDhB,GAAoD;AAAA,MAApDA,GAAoD,GAAA,QAAA,KAAA,KAAA,CAAA,GAA9C,MAA8C,GAAA,QAAA;AAAA,MAAA,QAAA,GAAA,IAAA,CAAtCC,GAAsC;AAAA,MAAtCA,GAAsC,GAAA,QAAA,KAAA,KAAA,CAAA,GAAhC,MAAgC,GAAA,QAAA;AAC5F,MAAMG,MAAM,GAAGC,EAAE,CAAjB,IAAiB,CAAjB;AACA,MAAMC,IAAI,GAAGP,IAAI,KAAJA,GAAAA,GAAAA,KAAAA,GAAb,MAAA;AAEA,MAAMkB,OAAO,GAAG,MAAM,CAAN,GAAA,CAAA,IAAA,CAAgB,UAAA,CAAA,EAAC;AAAA,WAAIC,CAAC,KAAL,CAAA;AAAjC,GAAgB,CAAhB;AACA,MAAA,IAAA;AACA,MAAIC,YAAY,GAAhB,KAAA;AACAf,EAAAA,MAAM,CAANA,GAAAA,CAAAA,MAAAA,CACY,UAAA,CAAA,EAAC;AAAA,WAAIc,CAAC,IAAL,IAAA;AADbd,GAAAA,EAAAA,OAAAA,CAEa,UAAA,CAAA,EAAK;AACV,QAAIe,YAAY,KAAhB,IAAA,EAA2B;;AAC3B,QAAIC,IAAI,KAAR,SAAA,EAAwB;AACpBA,MAAAA,IAAI,GAAGC,IAAI,CAAJA,IAAAA,CAAPD,CAAOC,CAAPD;AADJ,KAAA,MAEO,IAAIC,IAAI,CAAJA,IAAAA,CAAAA,CAAAA,MAAJ,IAAA,EAA2B;AAC9BF,MAAAA,YAAY,GAAZA,IAAAA;AACH;AARTf,GAAAA;;AAWA,MAAIa,OAAO,IAAX,YAAA,EAA6B;AACzB,UAAM,IAAA,KAAA,CACF,CAAA,oEAAA,EAAA,qCAAA,EAAA,IAAA,CADJ,IACI,CADE,CAAN;AAMH;;AAED,MAAIV,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGH,MAAM,CAAjBG,GAAAA;AACH;;AACD,MAAIC,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGJ,MAAM,CAAjBI,GAAAA;AACH;;AAED,MAAMC,KAAK,GAAGa,QAAQ,GAARA,MAAAA,CACF,CAAA,QAAA,EADEA,QACF,CADEA,EAAAA,UAAAA,CAEEvB,IAAI,KAAJA,GAAAA,GAAe,CAAA,CAAA,EAAfA,IAAe,CAAfA,GAA2B,CAAA,IAAA,EAF7BuB,CAE6B,CAF7BA,EAAAA,IAAAA,CAAAA,IAAAA,EAAd,IAAcA,EAAd;AAMAb,EAAAA,KAAK,CAALA,IAAAA,GAAAA,KAAAA;AAEA,SAAA,KAAA;AACH,C;;IAEYc,iBAAiB,GAAG;AAC7BX,EAAAA,IAAI,EAAEC,SAAS,CAATA,KAAAA,CAAgB,CAAhBA,KAAgB,CAAhBA,EADuB,UAAA;AAE7BG,EAAAA,IAAI,EAAEH,SAAS,CAFc,MAAA;AAG7Bb,EAAAA,GAAG,EAAEa,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,KAAAA,CAAgB,CAAjB,MAAiB,CAAhBA,CAAD,EAA4BA,SAAS,CAHjC,MAGJ,CAApBA,CAHwB;AAI7BZ,EAAAA,GAAG,EAAEY,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,KAAAA,CAAgB,CAAjB,MAAiB,CAAhBA,CAAD,EAA4BA,SAAS,CAAzDA,MAAoB,CAApBA;AAJwB,C;;IC/CpBW,WAAW,GAAG,SAAdA,WAAc,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,MAAA,EAKtB;AAAA,MAJCzB,IAID,GAAA,IAAA,CAJCA,IAID;AAAA,MAAA,aAAA,GAAA,IAAA,CAJO0B,QAIP;AAAA,MAJOA,QAIP,GAAA,aAAA,KAAA,KAAA,CAAA,GAJkB,CAIlB,GAAA,aAAA;AAAA,MAAA,QAAA,GAAA,IAAA,CAJqBzB,GAIrB;AAAA,MAJqBA,GAIrB,GAAA,QAAA,KAAA,KAAA,CAAA,GAJ2B,MAI3B,GAAA,QAAA;AAAA,MAAA,QAAA,GAAA,IAAA,CAJmCC,GAInC;AAAA,MAJmCA,GAInC,GAAA,QAAA,KAAA,KAAA,CAAA,GAJyC,MAIzC,GAAA,QAAA;AACD,MAAMG,MAAM,GAAGC,EAAE,CAAjB,IAAiB,CAAjB;AACA,MAAMC,IAAI,GAAGP,IAAI,KAAJA,GAAAA,GAAAA,KAAAA,GAAb,MAAA;AAEA,MAAIQ,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGH,MAAM,CAAjBG,GAAAA;AACH;;AAED,MAAIC,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGJ,MAAM,CAAjBI,GAAAA;AACH;;AAED,MAAMC,KAAK,GAAGiB,WAAW,GAAXA,MAAAA,CACF,CAAA,QAAA,EADEA,QACF,CADEA,EAAAA,QAAAA,CAAAA,QAAAA,EAAAA,UAAAA,CAGE3B,IAAI,KAAJA,GAAAA,GAAe,CAAA,CAAA,EAAfA,IAAe,CAAfA,GAA2B,CAAA,IAAA,EAH7B2B,CAG6B,CAH7BA,EAAd,IAAcA,EAAd;AAMAjB,EAAAA,KAAK,CAALA,IAAAA,GAAAA,QAAAA;AAEA,SAAA,KAAA;AACH,C;;IAEYkB,oBAAoB,GAAG;AAChCf,EAAAA,IAAI,EAAEC,SAAS,CAATA,KAAAA,CAAgB,CAAhBA,QAAgB,CAAhBA,EAD0B,UAAA;AAEhCY,EAAAA,QAAQ,EAAEZ,SAAS,CAFa,MAAA;AAGhCb,EAAAA,GAAG,EAAEa,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,KAAAA,CAAgB,CAAjB,MAAiB,CAAhBA,CAAD,EAA4BA,SAAS,CAH9B,MAGP,CAApBA,CAH2B;AAIhCZ,EAAAA,GAAG,EAAEY,SAAS,CAATA,SAAAA,CAAoB,CAACA,SAAS,CAATA,KAAAA,CAAgB,CAAjB,MAAiB,CAAhBA,CAAD,EAA4BA,SAAS,CAAzDA,MAAoB,CAApBA;AAJ2B,C;;IC9BvBe,UAAU,GAAG,SAAbA,UAAa,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,MAAA,EAAiC;AAAA,MAA9B7B,IAA8B,GAAA,IAAA,CAA9BA,IAA8B;AACvD,MAAMK,MAAM,GAAGC,EAAE,CAAjB,IAAiB,CAAjB;AACA,MAAMC,IAAI,GAAGP,IAAI,KAAJA,GAAAA,GAAAA,KAAAA,GAAb,MAAA;AAEA,MAAMU,KAAK,GAAGoB,UAAU,GAAVA,KAAAA,CAAmB,CAAA,CAAA,EAAnBA,IAAmB,CAAnBA,EAAAA,MAAAA,CAAqCzB,MAAM,CAAzD,GAAcyB,CAAd;AAEApB,EAAAA,KAAK,CAALA,IAAAA,GAAAA,OAAAA;AAEA,SAAA,KAAA;AACH,C;;IAEYqB,mBAAmB,GAAG;AAC/BlB,EAAAA,IAAI,EAAEC,SAAS,CAATA,KAAAA,CAAgB,CAAhBA,OAAgB,CAAhBA,EAA2BkB;AADF,C;;ACtBpB,SAAS,eAAT,CAAyB,GAAzB,EAA8B,GAA9B,EAAmC,KAAnC,EAA0C;AACvD,MAAI,GAAG,IAAI,GAAX,EAAgB;AACd,IAAA,MAAM,CAAC,cAAP,CAAsB,GAAtB,EAA2B,GAA3B,EAAgC;AAC9B,MAAA,KAAK,EAAE,KADuB;AAE9B,MAAA,UAAU,EAAE,IAFkB;AAG9B,MAAA,YAAY,EAAE,IAHgB;AAI9B,MAAA,QAAQ,EAAE;AAJoB,KAAhC;AAMD,GAPD,MAOO;AACL,IAAA,GAAG,CAAC,GAAD,CAAH,GAAW,KAAX;AACD;;AAED,SAAO,GAAP;AACF;;;;ICHaC,0BAA0B,GAAG,a;IAC7BC,qBAAqB,GAAG,Q;IACxBC,qBAAqB,GAAG,Q;IACxBC,mBAAmB,GAAG,M;IACtBC,kBAAkB,GAAG,K;IACrBC,oBAAoB,GAAG,O;IACvBC,mBAAmB,GAAG,M;IAEtBC,cAAc,GAAG,CAAA,0BAAA,EAAA,qBAAA,EAAA,qBAAA,EAAA,mBAAA,EAAA,kBAAA,EAAA,oBAAA,EAAA,mBAAA,C;IAUjBC,gBAAgB,GAAG,CAC5B,UAAA,IAAA,EAAI;AAAA,SAAIC,IAAI,CAAJA,eAAAA,CAAJ,CAAIA,CAAJ;AADwB,CAAA,EAE5B,UAAA,IAAA,EAAI;AAAA,SAAIA,IAAI,CAAJA,UAAAA,CAAJ,CAAIA,CAAJ;AAFwB,CAAA,EAG5B,UAAA,IAAA,EAAI;AAAA,SAAIA,IAAI,CAAJA,UAAAA,CAAJ,CAAIA,CAAJ;AAHwB,CAAA,EAI5B,UAAA,IAAA,EAAI;AAAA,SAAIA,IAAI,CAAJA,QAAAA,CAAJ,CAAIA,CAAJ;AAJwB,CAAA,EAK5B,UAAA,IAAA,EAAI;AAAA,SAAIA,IAAI,CAAJA,OAAAA,CAAJ,CAAIA,CAAJ;AALwB,CAAA,EAM5B,UAAA,IAAA,EAAI;AAAA,SAAIA,IAAI,CAAJA,QAAAA,CAAJ,CAAIA,CAAJ;AANwB,CAAA,C;IASnBC,sBAAsB,IAAA,qBAAA,GAAA,EAAA,EAAA,eAAA,CAAA,qBAAA,EAAA,0BAAA,EAAA,EAAA,CAAA,EAAA,eAAA,CAAA,qBAAA,EAAA,qBAAA,EAENF,gBAAgB,CAAhBA,KAAAA,CAAAA,CAAAA,EAFM,CAENA,CAFM,CAAA,EAAA,eAAA,CAAA,qBAAA,EAAA,qBAAA,EAGNA,gBAAgB,CAAhBA,KAAAA,CAAAA,CAAAA,EAHM,CAGNA,CAHM,CAAA,EAAA,eAAA,CAAA,qBAAA,EAAA,mBAAA,EAIRA,gBAAgB,CAAhBA,KAAAA,CAAAA,CAAAA,EAJQ,CAIRA,CAJQ,CAAA,EAAA,eAAA,CAAA,qBAAA,EAAA,kBAAA,EAKTA,gBAAgB,CAAhBA,KAAAA,CAAAA,CAAAA,EALS,CAKTA,CALS,CAAA,EAAA,eAAA,CAAA,qBAAA,EAAA,oBAAA,EAMPA,gBAAgB,CAAhBA,KAAAA,CAAAA,CAAAA,EANO,CAMPA,CANO,CAAA,EAAA,eAAA,CAAA,qBAAA,EAAA,mBAAA,EAORA,gBAAgB,CAAhBA,KAAAA,CAAAA,CAAAA,EAPQ,CAORA,CAPQ,CAAA,EAAA,qBAAA,C;;IAUtBG,qBAAqB,GAAG,SAAxBA,qBAAwB,CAAA,SAAA,EAAS;AAAA,SAAI,UAAA,IAAA,EAAQ;AACtDD,IAAAA,sBAAsB,CAAtBA,SAAsB,CAAtBA,CAAAA,OAAAA,CAA0C,UAAA,MAAA,EAAU;AAChDE,MAAAA,MAAM,CAANA,IAAM,CAANA;AADJF,KAAAA;AAGA,WAAA,IAAA;AAJ0C,GAAA;AAAA,C;;IAOjCG,oBAAoB,GAAG,SAAvBA,oBAAuB,CAAA,IAAA,EAI9B;AAAA,MAAA,WAAA,GAAA,IAAA,CAHFC,MAGE;AAAA,MAHFA,MAGE,GAAA,WAAA,KAAA,KAAA,CAAA,GAHO,QAGP,GAAA,WAAA;AAAA,MAAA,cAAA,GAAA,IAAA,CAFFC,SAEE;AAAA,MAFFA,SAEE,GAAA,cAAA,KAAA,KAAA,CAAA,GAFU,aAEV,GAAA,cAAA;AAAA,MAAA,WAAA,GAAA,IAAA,CADFC,MACE;AAAA,MADFA,MACE,GAAA,WAAA,KAAA,KAAA,CAAA,GADO,IACP,GAAA,WAAA;AACF,MAAMC,WAAW,GAAGN,qBAAqB,CAAzC,SAAyC,CAAzC;AACA,MAAIG,MAAM,KAAV,QAAA,EAAyB,OAAO,UAAA,CAAA,EAAC;AAAA,WAAIG,WAAW,CAAf,CAAe,CAAf;AAAR,GAAA;AAEzB,MAAMC,SAAS,GAAGF,MAAM,GAAGG,QAAQ,CAAX,MAAW,CAAX,GAAsBC,SAAS,CAAvD,MAAuD,CAAvD;AACA,SAAO,UAAA,CAAA,EAAC;AAAA,WAAIH,WAAW,CAACC,SAAS,CAAzB,CAAyB,CAAV,CAAf;AAAR,GAAA;AACH,C;;ICpDYG,SAAS,GAAG,SAAZA,SAAY,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,MAAA,EAYpB;AAAA,MAVGtD,IAUH,GAAA,IAAA,CAVGA,IAUH;AAAA,MAAA,WAAA,GAAA,IAAA,CATG+C,MASH;AAAA,MATGA,MASH,GAAA,WAAA,KAAA,KAAA,CAAA,GATY,QASZ,GAAA,WAAA;AAAA,MAAA,cAAA,GAAA,IAAA,CARGC,SAQH;AAAA,MARGA,SAQH,GAAA,cAAA,KAAA,KAAA,CAAA,GARef,0BAQf,GAAA,cAAA;AAAA,MAAA,QAAA,GAAA,IAAA,CAPGhC,GAOH;AAAA,MAPGA,GAOH,GAAA,QAAA,KAAA,KAAA,CAAA,GAPS,MAOT,GAAA,QAAA;AAAA,MAAA,QAAA,GAAA,IAAA,CANGC,GAMH;AAAA,MANGA,GAMH,GAAA,QAAA,KAAA,KAAA,CAAA,GANS,MAMT,GAAA,QAAA;AAAA,MAAA,WAAA,GAAA,IAAA,CALG+C,MAKH;AAAA,MALGA,MAKH,GAAA,WAAA,KAAA,KAAA,CAAA,GALY,IAKZ,GAAA,WAAA;AACD,MAAM5C,MAAM,GAAGC,EAAE,CAAjB,IAAiB,CAAjB;AACA,MAAMC,IAAI,GAAGP,IAAI,KAAJA,GAAAA,GAAAA,KAAAA,GAAb,MAAA;AAEA,MAAMuD,SAAS,GAAGT,oBAAoB,CAAC;AAAEC,IAAAA,MAAM,EAAR,MAAA;AAAUC,IAAAA,SAAS,EAAnB,SAAA;AAAqBC,IAAAA,MAAM,EAANA;AAArB,GAAD,CAAtC;AAEA,MAAIzC,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGH,MAAM,CAAjBG,GAAAA;AADJ,GAAA,MAEO,IAAIuC,MAAM,KAAV,QAAA,EAAyB;AAC5BvC,IAAAA,QAAQ,GAAG+C,SAAS,CAApB/C,GAAoB,CAApBA;AACH;;AAED,MAAIC,QAAQ,GAAZ,GAAA;;AACA,MAAIP,GAAG,KAAP,MAAA,EAAoB;AAChBO,IAAAA,QAAQ,GAAGJ,MAAM,CAAjBI,GAAAA;AADJ,GAAA,MAEO,IAAIsC,MAAM,KAAV,QAAA,EAAyB;AAC5BtC,IAAAA,QAAQ,GAAG8C,SAAS,CAApB9C,GAAoB,CAApBA;AACH;;AAED,MAAMC,KAAK,GAAGuC,MAAM,GAAGO,QAAH,EAAA,GAAgBC,SAApC,EAAA;AACA/C,EAAAA,KAAK,CAALA,MAAAA,CAAa,CAAA,QAAA,EAAbA,QAAa,CAAbA,EAAAA,KAAAA,CAAyC,CAAA,CAAA,EAAzCA,IAAyC,CAAzCA;AAEAA,EAAAA,KAAK,CAALA,IAAAA,GAAAA,MAAAA;AACAA,EAAAA,KAAK,CAALA,MAAAA,GAAAA,MAAAA;AAEA,SAAA,KAAA;AACH,C;;IAEYgD,kBAAkB,GAAG;AAC9B7C,EAAAA,IAAI,EAAEC,SAAS,CAATA,KAAAA,CAAgB,CAAhBA,MAAgB,CAAhBA,EADwB,UAAA;AAE9BiC,EAAAA,MAAM,EAAEjC,SAAS,CAFa,MAAA;AAG9BkC,EAAAA,SAAS,EAAElC,SAAS,CAATA,KAAAA,CAAAA,cAAAA;AAHmB,C;IC3CrB6C,kBAAkB,GAAG;AAC9B9C,EAAAA,IAAI,EAAEC,SAAS,CAATA,KAAAA,CAAgB,CAAhBA,MAAgB,CAAhBA,EADwB,UAAA;AAE9B8C,EAAAA,KAAK,EAAE9C,SAAS,CAACC;AAFa,C;;ACVnB,SAAS,iBAAT,CAA2B,GAA3B,EAAgC,GAAhC,EAAqC;AAClD,MAAI,GAAG,IAAI,IAAP,IAAe,GAAG,GAAG,GAAG,CAAC,MAA7B,EAAqC,GAAG,GAAG,GAAG,CAAC,MAAV;;AAErC,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,IAAI,GAAG,IAAI,KAAJ,CAAU,GAAV,CAAvB,EAAuC,CAAC,GAAG,GAA3C,EAAgD,CAAC,EAAjD,EAAqD;AACnD,IAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAG,CAAC,CAAD,CAAb;AACD;;AAED,SAAO,IAAP;AACF;;ACPe,SAAS,kBAAT,CAA4B,GAA5B,EAAiC;AAC9C,MAAI,KAAK,CAAC,OAAN,CAAc,GAAd,CAAJ,EAAwB,OAAO8C,iBAAgB,CAAC,GAAD,CAAvB;AAC1B;;ACHe,SAAS,gBAAT,CAA0B,IAA1B,EAAgC;AAC7C,MAAI,OAAO,MAAP,KAAkB,WAAlB,IAAiC,MAAM,CAAC,QAAP,IAAmB,MAAM,CAAC,IAAD,CAA9D,EAAsE,OAAO,KAAK,CAAC,IAAN,CAAW,IAAX,CAAP;AACxE;;ACDe,SAAS,2BAAT,CAAqC,CAArC,EAAwC,MAAxC,EAAgD;AAC7D,MAAI,CAAC,CAAL,EAAQ;AACR,MAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B,OAAOA,iBAAgB,CAAC,CAAD,EAAI,MAAJ,CAAvB;AAC3B,MAAI,CAAC,GAAG,MAAM,CAAC,SAAP,CAAiB,QAAjB,CAA0B,IAA1B,CAA+B,CAA/B,EAAkC,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;AACA,MAAI,CAAC,KAAK,QAAN,IAAkB,CAAC,CAAC,WAAxB,EAAqC,CAAC,GAAG,CAAC,CAAC,WAAF,CAAc,IAAlB;AACrC,MAAI,CAAC,KAAK,KAAN,IAAe,CAAC,KAAK,KAAzB,EAAgC,OAAO,KAAK,CAAC,IAAN,CAAW,CAAX,CAAP;AAChC,MAAI,CAAC,KAAK,WAAN,IAAqB,2CAA2C,IAA3C,CAAgD,CAAhD,CAAzB,EAA6E,OAAOA,iBAAgB,CAAC,CAAD,EAAI,MAAJ,CAAvB;AAC/E;;ACRe,SAAS,kBAAT,GAA8B;AAC3C,QAAM,IAAI,SAAJ,CAAc,sIAAd,CAAN;AACF;;ACEe,SAAS,kBAAT,CAA4B,GAA5B,EAAiC;AAC9C,SAAOC,kBAAiB,CAAC,GAAD,CAAjBA,IAA0BC,gBAAe,CAAC,GAAD,CAAzCD,IAAkDE,2BAA0B,CAAC,GAAD,CAA5EF,IAAqFG,kBAAiB,EAA7G;AACF;;ACJA,SAAS,OAAT,CAAiB,MAAjB,EAAyB,cAAzB,EAAyC;AACvC,MAAI,IAAI,GAAG,MAAM,CAAC,IAAP,CAAY,MAAZ,CAAX;;AAEA,MAAI,MAAM,CAAC,qBAAX,EAAkC;AAChC,QAAI,OAAO,GAAG,MAAM,CAAC,qBAAP,CAA6B,MAA7B,CAAd;AACA,QAAI,cAAJ,EAAoB,OAAO,GAAG,OAAO,CAAC,MAAR,CAAe,UAAU,GAAV,EAAe;AAC1D,aAAO,MAAM,CAAC,wBAAP,CAAgC,MAAhC,EAAwC,GAAxC,EAA6C,UAApD;AACD,KAF6B,CAAV;AAGpB,IAAA,IAAI,CAAC,IAAL,CAAU,KAAV,CAAgB,IAAhB,EAAsB,OAAtB;AACD;;AAED,SAAO,IAAP;AACD;;AAEc,SAAS,cAAT,CAAwB,MAAxB,EAAgC;AAC7C,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,SAAS,CAAC,MAA9B,EAAsC,CAAC,EAAvC,EAA2C;AACzC,QAAI,MAAM,GAAG,SAAS,CAAC,CAAD,CAAT,IAAgB,IAAhB,GAAuB,SAAS,CAAC,CAAD,CAAhC,GAAsC,EAAnD;;AAEA,QAAI,CAAC,GAAG,CAAR,EAAW;AACT,MAAA,OAAO,CAAC,MAAM,CAAC,MAAD,CAAP,EAAiB,IAAjB,CAAP,CAA8B,OAA9B,CAAsC,UAAU,GAAV,EAAe;AACnDC,QAAAA,eAAc,CAAC,MAAD,EAAS,GAAT,EAAc,MAAM,CAAC,GAAD,CAApB,CAAdA;AACD,OAFD;AAGD,KAJD,MAIO,IAAI,MAAM,CAAC,yBAAX,EAAsC;AAC3C,MAAA,MAAM,CAAC,gBAAP,CAAwB,MAAxB,EAAgC,MAAM,CAAC,yBAAP,CAAiC,MAAjC,CAAhC;AACD,KAFM,MAEA;AACL,MAAA,OAAO,CAAC,MAAM,CAAC,MAAD,CAAP,CAAP,CAAwB,OAAxB,CAAgC,UAAU,GAAV,EAAe;AAC7C,QAAA,MAAM,CAAC,cAAP,CAAsB,MAAtB,EAA8B,GAA9B,EAAmC,MAAM,CAAC,wBAAP,CAAgC,MAAhC,EAAwC,GAAxC,CAAnC;AACD,OAFD;AAGD;AACF;;AAED,SAAO,MAAP;AACF;;ICdaC,YAAY,GAAG,SAAfA,YAAe,CAAA,IAAA,EAAI;AAAA,SAAKnE,IAAI,KAAJA,GAAAA,GAAAA,GAAAA,GAAL,GAAA;AAAA,C;;IAEnBoE,aAAa,GAAG,SAAhBA,aAAgB,CAAA,CAAA,EAAA,CAAA,EAAA;AAAA,SAAUC,CAAC,KAAX,CAAA;AAAA,C;;IAChBC,iBAAiB,GAAG,SAApBA,iBAAoB,CAAA,CAAA,EAAA,CAAA,EAAA;AAAA,SAAUD,CAAC,CAADA,OAAAA,OAAgBE,CAAC,CAA3B,OAA0BA,EAA1B;AAAA,C;;IAEpBC,wBAAwB,GAAG,SAA3BA,wBAA2B,CAAA,OAAA,EAAA,UAAA,EAAA,UAAA,EAAA,KAAA,EAAA,MAAA,EAAoD;AACxF,MAAMC,MAAM,GAAG,OAAO,CAAP,GAAA,CAAY,UAAA,KAAA,EAAK;AAAA,WAAA,cAAA,CAAA,cAAA,CAAA,EAAA,EAAA,KAAA,CAAA,EAAA,EAAA,EAAA;AAE5BC,MAAAA,IAAI,EAAE,KAAK,CAAL,IAAA,CAAA,GAAA,CAAe,UAAA,CAAA,EAAC;AAAA,eAAK;AAAEA,UAAAA,IAAI,EAAA,cAAA,CAAA,EAAA,EAAA,CAAA;AAAN,SAAL;AAAhB,OAAA;AAFsB,KAAA,CAAA;AAAhC,GAAe,CAAf;;AAKA,MAAIpE,EAAE,GAAGqE,gBAAgB,CAAA,MAAA,EAAA,UAAA,EAAzB,UAAyB,CAAzB;;AACA,MAAIC,UAAU,CAAVA,OAAAA,KAAJ,IAAA,EAAiC;AAC7BC,IAAAA,MAAM,CAACC,UAAU,CAAX,IAAA,EAAA,EAAA,EAAND,MAAM,CAANA;AACH;;AACD,MAAIC,UAAU,CAAVA,OAAAA,KAAJ,IAAA,EAAiC;AAC7BC,IAAAA,MAAM,CAACH,UAAU,CAAX,IAAA,EAAA,EAAA,EAANG,MAAM,CAANA;AACH;;AAED,MAAMC,MAAM,GAAGC,YAAY,CAAA,cAAA,CAAA,cAAA,CAAA,EAAA,EAAA,UAAA,CAAA,EAAA,EAAA,EAAA;AAAkBjF,IAAAA,IAAI,EAAE;AAAxB,GAAA,CAAA,EAAA,EAAA,EAAA,KAAA,EAA3B,MAA2B,CAA3B;AACA,MAAMkF,MAAM,GAAGD,YAAY,CAAA,cAAA,CAAA,cAAA,CAAA,EAAA,EAAA,UAAA,CAAA,EAAA,EAAA,EAAA;AAAkBjF,IAAAA,IAAI,EAAE;AAAxB,GAAA,CAAA,EAAA,EAAA,EAAA,KAAA,EAA3B,MAA2B,CAA3B;AAEAyE,EAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAS;AACpBU,IAAAA,KAAK,CAALA,IAAAA,CAAAA,OAAAA,CAAmB,UAAA,CAAA,EAAK;AACpBC,MAAAA,CAAC,CAADA,QAAAA,GAAa;AACTC,QAAAA,CAAC,EACGL,MAAM,CAANA,OAAAA,KAAAA,IAAAA,GACMI,CAAC,CAADA,IAAAA,CAAAA,QAAAA,KAAAA,IAAAA,GAAAA,IAAAA,GAEIJ,MAAM,CAACI,CAAC,CAADA,IAAAA,CAHjBJ,QAGgB,CAHhBA,GAIMI,CAAC,CAADA,IAAAA,CAAAA,CAAAA,KAAAA,IAAAA,GAAAA,IAAAA,GAEAJ,MAAM,CAACI,CAAC,CAADA,IAAAA,CARR,CAQO,CARP;AASTE,QAAAA,CAAC,EACGJ,MAAM,CAANA,OAAAA,KAAAA,IAAAA,GACME,CAAC,CAADA,IAAAA,CAAAA,QAAAA,KAAAA,IAAAA,GAAAA,IAAAA,GAEIF,MAAM,CAACE,CAAC,CAADA,IAAAA,CAHjBF,QAGgB,CAHhBA,GAIME,CAAC,CAADA,IAAAA,CAAAA,CAAAA,KAAAA,IAAAA,GAAAA,IAAAA,GAEAF,MAAM,CAACE,CAAC,CAADA,IAAAA,CAAD,CAAA;AAhBP,OAAbA;AADJD,KAAAA;AADJV,GAAAA;AAuBA,SAAA,cAAA,CAAA,cAAA,CAAA,EAAA,EAAA,EAAA,CAAA,EAAA,EAAA,EAAA;AAEIA,IAAAA,MAAM,EAFV,MAAA;AAGIO,IAAAA,MAAM,EAHV,MAAA;AAIIE,IAAAA,MAAM,EAANA;AAJJ,GAAA,CAAA;AAMH,C;;IAEYD,YAAY,GAAG,SAAfA,YAAe,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAA,MAAA,EAA6B;AACrD,MAAIM,IAAI,CAAJA,IAAAA,KAAJ,QAAA,EAA4B,OAAOxF,WAAW,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAA9C,MAA8C,CAAlB,CAA5B,KACK,IAAIwF,IAAI,CAAJA,IAAAA,KAAJ,OAAA,EAA2B,OAAO1D,UAAU,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAA5C,MAA4C,CAAjB,CAA3B,KACA,IAAI0D,IAAI,CAAJA,IAAAA,KAAJ,MAAA,EAA0B,OAAOjC,SAAS,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAA1C,MAA0C,CAAhB,CAA1B,KACA,IAAIiC,IAAI,CAAJA,IAAAA,KAAJ,KAAA,EAAyB,OAAOvE,QAAQ,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAxC,MAAwC,CAAf,CAAzB,KACA,IAAIuE,IAAI,CAAJA,IAAAA,KAAJ,QAAA,EAA4B,OAAO9D,WAAW,CAAA,IAAA,EAAA,EAAA,EAAA,KAAA,EAAlB,MAAkB,CAAlB;AACpC,C;;IAEYkD,gBAAgB,GAAG,SAAnBA,gBAAmB,CAAA,MAAA,EAAA,UAAA,EAAA,UAAA,EAAA;AAAA,SAAqC;AACjEU,IAAAA,CAAC,EAAEG,kBAAkB,CAAA,MAAA,EAAA,GAAA,EAD4C,UAC5C,CAD4C;AAEjEF,IAAAA,CAAC,EAAEE,kBAAkB,CAAA,MAAA,EAAA,GAAA,EAAA,UAAA;AAF4C,GAArC;AAAA,C;;IASnBA,kBAAkB,GAAG,SAArBA,kBAAqB,CAAA,MAAA,EAAA,IAAA,EAAA,SAAA,EAU7B;AAAA,MAAA,IAAA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GADG,EACH;AAAA,MAAA,aAAA,GAAA,IAAA,CALGC,QAKH;AAAA,MALGA,QAKH,GAAA,aAAA,KAAA,KAAA,CAAA,GALc,UAAA,CAAA,EAAC;AAAA,WAAIL,CAAC,CAADA,IAAAA,CAAJ,IAAIA,CAAJ;AAKf,GAAA,GAAA,aAAA;AAAA,MAAA,aAAA,GAAA,IAAA,CAJGM,QAIH;AAAA,MAJGA,QAIH,GAAA,aAAA,KAAA,KAAA,CAAA,GAJc,UAAA,CAAA,EAAA,CAAA,EAAU;AACjBN,IAAAA,CAAC,CAADA,IAAAA,CAAAA,IAAAA,IAAAA,CAAAA;AAGP,GAAA,GAAA,aAAA;;AACD,MAAIO,SAAS,CAATA,IAAAA,KAAJ,QAAA,EAAiC;AAC7BlB,IAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAS;AACpBU,MAAAA,KAAK,CAALA,IAAAA,CAAAA,OAAAA,CAAmB,UAAA,CAAA,EAAK;AACpBO,QAAAA,QAAQ,CAAA,CAAA,EAAID,QAAQ,CAARA,CAAQ,CAARA,KAAAA,IAAAA,GAAAA,IAAAA,GAA8BG,UAAU,CAACH,QAAQ,CAA7DC,CAA6D,CAAT,CAA5C,CAARA;AADJP,OAAAA;AADJV,KAAAA;AADJ,GAAA,MAMO,IAAIkB,SAAS,CAATA,IAAAA,KAAAA,MAAAA,IAA6BA,SAAS,CAATA,MAAAA,KAAjC,QAAA,EAAgE;AACnE,QAAMxC,SAAS,GAAGL,oBAAoB,CAAtC,SAAsC,CAAtC;AACA2B,IAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAS;AACpBU,MAAAA,KAAK,CAALA,IAAAA,CAAAA,OAAAA,CAAmB,UAAA,CAAA,EAAK;AACpBO,QAAAA,QAAQ,CAAA,CAAA,EAAID,QAAQ,CAARA,CAAQ,CAARA,KAAAA,IAAAA,GAAAA,IAAAA,GAA8BtC,SAAS,CAACsC,QAAQ,CAA5DC,CAA4D,CAAT,CAA3C,CAARA;AADJP,OAAAA;AADJV,KAAAA;AAKH;;AAED,MAAIoB,GAAG,GAAP,EAAA;AACApB,EAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAS;AACpBU,IAAAA,KAAK,CAALA,IAAAA,CAAAA,OAAAA,CAAmB,UAAA,CAAA,EAAK;AACpBU,MAAAA,GAAG,CAAHA,IAAAA,CAASJ,QAAQ,CAAjBI,CAAiB,CAAjBA;AADJV,KAAAA;AADJV,GAAAA;AAMA,MAAA,GAAA,EAAA,GAAA;;AACA,MAAIkB,SAAS,CAATA,IAAAA,KAAJ,QAAA,EAAiC;AAC7BE,IAAAA,GAAG,GAAGC,IAAI,CAAVD,GAAU,CAAVA;AACAA,IAAAA,GAAG,GAAGE,MAAM,CAAA,GAAA,EAAM,UAAA,CAAA,EAAC;AAAA,aAAA,CAAA;AAAnBF,KAAY,CAAZA;AACA5F,IAAAA,GAAG,GAAGqB,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAI,kBAAA,CAAVrB,GAAU,CAAJqB,CAANrB;AACAC,IAAAA,GAAG,GAAGoB,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAI,kBAAA,CAAVpB,GAAU,CAAJoB,CAANpB;AAJJ,GAAA,MAKO,IAAIyF,SAAS,CAATA,IAAAA,KAAJ,MAAA,EAA+B;AAClCE,IAAAA,GAAG,GAAGG,MAAM,CAAA,GAAA,EAAM,UAAA,CAAA,EAAC;AAAA,aAAI7E,CAAC,CAAL,OAAIA,EAAJ;AAAnB0E,KAAY,CAAZA;AACAA,IAAAA,GAAG,GAAG,GAAG,CAAH,KAAA,CAAA,CAAA,EAAA,IAAA,CAEI,UAAA,CAAA,EAAA,CAAA,EAAA;AAAA,aAAUtB,CAAC,GAAX,CAAA;AAFJ,KAAA,EAANsB,OAAM,EAANA;AAIA5F,IAAAA,GAAG,GAAG4F,GAAG,CAAT5F,CAAS,CAATA;AACAC,IAAAA,GAAG,GAAG+F,IAAI,CAAV/F,GAAU,CAAVA;AAPG,GAAA,MAQA;AACH2F,IAAAA,GAAG,GAAGC,IAAI,CAAVD,GAAU,CAAVA;AACA5F,IAAAA,GAAG,GAAG4F,GAAG,CAAT5F,CAAS,CAATA;AACAC,IAAAA,GAAG,GAAG+F,IAAI,CAAV/F,GAAU,CAAVA;AACH;;AAED,SAAO;AAAE2F,IAAAA,GAAG,EAAL,GAAA;AAAO5F,IAAAA,GAAG,EAAV,GAAA;AAAYC,IAAAA,GAAG,EAAHA;AAAZ,GAAP;AACH,C;;IAEYgG,SAAS,GAAG,SAAZA,SAAY,CAAA,IAAA,EAAA,SAAA,EAAA,EAAA,EAAA,MAAA,EAAiC;AACtD,MAAMC,SAAS,GAAGhC,YAAY,CAA9B,IAA8B,CAA9B;AAEA,MAAI0B,GAAG,GAAP,EAAA;AACAvF,EAAAA,EAAE,CAAFA,SAAE,CAAFA,CAAAA,GAAAA,CAAAA,OAAAA,CAA0B,UAAA,CAAA,EAAK;AAC3B,QAAM8F,OAAO,GAAGC,MAAM,CAANA,CAAM,CAANA,GAAAA,iBAAAA,GAAhB,aAAA;AACA,QAAMC,KAAK,GAAX,EAAA;AACA7B,IAAAA,MAAM,CAANA,OAAAA,CAAe,UAAA,KAAA,EAAS;AACpB,UAAM8B,KAAK,GAAG,KAAK,CAAL,IAAA,CAAA,IAAA,CAAgB,UAAA,CAAA,EAAC;AAAA,eAAIH,OAAO,CAAChB,CAAC,CAADA,IAAAA,CAAD,SAACA,CAAD,EAAX,CAAW,CAAX;AAA/B,OAAc,CAAd;AACA,UAAIoB,KAAK,GAAT,IAAA;AACA,UAAIC,UAAU,GAAd,IAAA;;AACA,UAAIF,KAAK,KAAT,SAAA,EAAyB;AACrBC,QAAAA,KAAK,GAAGD,KAAK,CAALA,IAAAA,CAARC,IAAQD,CAARC;;AACA,YAAIA,KAAK,KAAT,IAAA,EAAoB;AAChB,cAAME,IAAI,GAAGT,IAAI,CAAjB,KAAiB,CAAjB;;AACA,cAAIS,IAAI,KAAR,SAAA,EAAwB;AACpBD,YAAAA,UAAU,GAAVA,KAAAA;AADJ,WAAA,MAEO,IAAIC,IAAI,KAAR,IAAA,EAAmB;AACtBD,YAAAA,UAAU,GAAGC,IAAI,GAAjBD,KAAAA;AACH;AACJ;;AACDF,QAAAA,KAAK,CAALA,IAAAA,CAAAA,GAAAA,MAAAA,CAAAA,IAAAA,EAAAA,SAAAA,CAAAA,IAAAA,UAAAA;AACH;;AACDD,MAAAA,KAAK,CAALA,IAAAA,CAAAA,UAAAA;AACAT,MAAAA,GAAG,CAAHA,IAAAA,CAAAA,UAAAA;AAjBJpB,KAAAA;AAHJnE,GAAAA;AAuBAuF,EAAAA,GAAG,GAAG,GAAG,CAAH,MAAA,CAAW,UAAA,CAAA,EAAC;AAAA,WAAI1E,CAAC,KAAL,IAAA;AAAlB0E,GAAM,CAANA;AAEAvF,EAAAA,EAAE,CAAFA,IAAE,CAAFA,CAAAA,UAAAA,GAAsBgB,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAI,kBAAA,CAA1BhB,GAA0B,CAAJgB,CAAtBhB;AACAA,EAAAA,EAAE,CAAFA,IAAE,CAAFA,CAAAA,UAAAA,GAAsBgB,IAAI,CAAJA,GAAAA,CAAAA,KAAAA,CAAAA,IAAAA,EAAI,kBAAA,CAA1BhB,GAA0B,CAAJgB,CAAtBhB;AACH,C;;IAEYuE,MAAM,GAAG,SAATA,MAAS,CAAA,EAAA,EAAA,SAAA,EAAA,MAAA,EAAA;AAAA,SAA2BqB,SAAS,CAAA,GAAA,EAAA,EAAA,EAAA,SAAA,EAApC,MAAoC,CAApC;AAAA,C;;IACTnB,MAAM,GAAG,SAATA,MAAS,CAAA,EAAA,EAAA,SAAA,EAAA,MAAA,EAAA;AAAA,SAA2BmB,SAAS,CAAA,GAAA,EAAA,EAAA,EAAA,SAAA,EAApC,MAAoC,CAApC;AAAA,C;;IAETS,iBAAiB,GAAG,SAApBA,iBAAoB,CAAA,IAAA,EAAA,IAAA,EAAgB;AAC7C,MAAMR,SAAS,GAAGhC,YAAY,CAA9B,IAA8B,CAA9B;AAEA,SAAO,IAAI,CAAJ,SAAI,CAAJ,CAAA,GAAA,CAAA,GAAA,CAAwB,UAAA,CAAA,EAAK;AAAA,QAAA,MAAA;;AAChC,QAAMyC,KAAK,IAAA,MAAA,GAAA;AACPC,MAAAA,EAAE,EAAE1F;AADG,KAAA,EAAA,eAAA,CAAA,MAAA,EAAA,SAAA,EAEMuD,IAAI,CAAA,GAAA,MAAA,CAAA,SAAA,EAAJA,OAAI,CAAA,CAAJA,CAFN,CAEMA,CAFN,CAAA,EAAA,eAAA,CAAA,MAAA,EAAA,MAAA,EAAA,EAAA,CAAA,EAAX,MAAW,CAAX;AAKA,QAAM0B,OAAO,GAAGC,MAAM,CAANA,CAAM,CAANA,GAAAA,iBAAAA,GAAhB,aAAA;AACA3B,IAAAA,IAAI,CAAJA,MAAAA,CAAAA,OAAAA,CAAoB,UAAA,KAAA,EAAS;AACzB,UAAM6B,KAAK,GAAG,KAAK,CAAL,IAAA,CAAA,IAAA,CAAgB,UAAA,CAAA,EAAC;AAAA,eAAIH,OAAO,CAAChB,CAAC,CAADA,IAAAA,CAAD,SAACA,CAAD,EAAX,CAAW,CAAX;AAA/B,OAAc,CAAd;;AACA,UAAImB,KAAK,KAAT,SAAA,EAAyB;AACrBK,QAAAA,KAAK,CAALA,IAAAA,CAAAA,IAAAA,CAAAA,cAAAA,CAAAA,cAAAA,CAAAA,EAAAA,EAAAA,KAAAA,CAAAA,EAAAA,EAAAA,EAAAA;AAEIzB,UAAAA,KAAK,EAALA;AAFJyB,SAAAA,CAAAA;AAIH;AAPLlC,KAAAA;AASAkC,IAAAA,KAAK,CAALA,IAAAA,CAAAA,OAAAA;AAEA,WAAA,KAAA;AAlBJ,GAAO,CAAP;AAoBH,C;;IAEYE,cAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAA,EAAI;AAAA,SAAIH,iBAAiB,CAAA,GAAA,EAArB,IAAqB,CAArB;AAAA,C;;IACrBI,cAAc,GAAG,SAAjBA,cAAiB,CAAA,IAAA,EAAI;AAAA,SAAIJ,iBAAiB,CAAA,GAAA,EAArB,IAAqB,CAArB;AAAA,C;;ICvLrBK,aAAa,GAAGlG,SAAS,CAATA,SAAAA,CAAoB,CAC7CA,SAAS,CAATA,KAAAA,CAD6C,oBAC7CA,CAD6C,EAE7CA,SAAS,CAATA,KAAAA,CAF6C,mBAE7CA,CAF6C,EAG7CA,SAAS,CAATA,KAAAA,CAH6C,kBAG7CA,CAH6C,EAI7CA,SAAS,CAATA,KAAAA,CAJ6C,iBAI7CA,CAJ6C,EAK7CA,SAAS,CAATA,KAAAA,CAL6C,oBAK7CA,CAL6C,EAM7CA,SAAS,CAATA,KAAAA,CANyBA,kBAMzBA,CAN6C,CAApBA,C","sourcesContent":["/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLinear } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const linearScale = (\n    { axis, min = 0, max = 'auto', stacked = false, reverse = false },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = stacked === true ? values.minStacked : values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = stacked === true ? values.maxStacked : values.max\n    }\n\n    const scale = scaleLinear().rangeRound(axis === 'x' ? [0, size] : [size, 0])\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    scale.type = 'linear'\n    scale.stacked = stacked\n\n    return scale\n}\n\nexport const linearScalePropTypes = {\n    type: PropTypes.oneOf(['linear']).isRequired,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    stacked: PropTypes.bool,\n    reverse: PropTypes.bool,\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleLog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const logScale = ({ axis, base = 10, min = 'auto', max = 'auto' }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const hasZero = values.all.some(v => v === 0)\n    let sign\n    let hasMixedSign = false\n    values.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign === true) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasZero || hasMixedSign) {\n        throw new Error(\n            [\n                `a log scale domain must be strictly-positive or strictly-negative,`,\n                `and must not include or cross zero.`,\n            ].join('\\n')\n        )\n    }\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleLog()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    scale.type = 'log'\n\n    return scale\n}\n\nexport const logScalePropTypes = {\n    type: PropTypes.oneOf(['log']).isRequired,\n    base: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleSymlog } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const symlogScale = (\n    { axis, constant = 1, min = 'auto', max = 'auto' },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    }\n\n    const scale = scaleSymlog()\n        .domain([minValue, maxValue])\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    scale.type = 'symlog'\n\n    return scale\n}\n\nexport const symLogScalePropTypes = {\n    type: PropTypes.oneOf(['symlog']).isRequired,\n    constant: PropTypes.number,\n    min: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n    max: PropTypes.oneOfType([PropTypes.oneOf(['auto']), PropTypes.number]),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scalePoint } from 'd3-scale'\nimport PropTypes from 'prop-types'\n\nexport const pointScale = ({ axis }, xy, width, height) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const scale = scalePoint().range([0, size]).domain(values.all)\n\n    scale.type = 'point'\n\n    return scale\n}\n\nexport const pointScalePropTypes = {\n    type: PropTypes.oneOf(['point']).isRequired,\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { timeParse, utcParse } from 'd3-time-format'\n\nexport const TIME_PRECISION_MILLISECOND = 'millisecond'\nexport const TIME_PRECISION_SECOND = 'second'\nexport const TIME_PRECISION_MINUTE = 'minute'\nexport const TIME_PRECISION_HOUR = 'hour'\nexport const TIME_PRECISION_DAY = 'day'\nexport const TIME_PRECISION_MONTH = 'month'\nexport const TIME_PRECISION_YEAR = 'year'\n\nexport const timePrecisions = [\n    TIME_PRECISION_MILLISECOND,\n    TIME_PRECISION_SECOND,\n    TIME_PRECISION_MINUTE,\n    TIME_PRECISION_HOUR,\n    TIME_PRECISION_DAY,\n    TIME_PRECISION_MONTH,\n    TIME_PRECISION_YEAR,\n]\n\nexport const precisionCutOffs = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType = {\n    [TIME_PRECISION_MILLISECOND]: [],\n    [TIME_PRECISION_SECOND]: precisionCutOffs.slice(0, 1),\n    [TIME_PRECISION_MINUTE]: precisionCutOffs.slice(0, 2),\n    [TIME_PRECISION_HOUR]: precisionCutOffs.slice(0, 3),\n    [TIME_PRECISION_DAY]: precisionCutOffs.slice(0, 4),\n    [TIME_PRECISION_MONTH]: precisionCutOffs.slice(0, 5),\n    [TIME_PRECISION_YEAR]: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = precision => date => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n    if (format === 'native') return v => precisionFn(v)\n\n    const parseTime = useUTC ? utcParse(format) : timeParse(format)\n    return v => precisionFn(parseTime(v))\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport { scaleTime, scaleUtc } from 'd3-scale'\nimport PropTypes from 'prop-types'\nimport { createDateNormalizer, timePrecisions, TIME_PRECISION_MILLISECOND } from './timeHelpers'\n\nexport const timeScale = (\n    {\n        axis,\n        format = 'native',\n        precision = TIME_PRECISION_MILLISECOND,\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n    },\n    xy,\n    width,\n    height\n) => {\n    const values = xy[axis]\n    const size = axis === 'x' ? width : height\n\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue = min\n    if (min === 'auto') {\n        minValue = values.min\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    }\n\n    let maxValue = max\n    if (max === 'auto') {\n        maxValue = values.max\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n    scale.domain([minValue, maxValue]).range([0, size])\n\n    scale.type = 'time'\n    scale.useUTC = useUTC\n\n    return scale\n}\n\nexport const timeScalePropTypes = {\n    type: PropTypes.oneOf(['time']).isRequired,\n    format: PropTypes.string,\n    precision: PropTypes.oneOf(timePrecisions),\n}\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\n\nexport const bandScalePropTypes = {\n    type: PropTypes.oneOf(['band']).isRequired,\n    round: PropTypes.bool,\n}\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(n);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import defineProperty from \"./defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { linearScale } from './linearScale'\nimport { logScale } from './logScale'\nimport { symlogScale } from './symlogScale'\nimport { pointScale } from './pointScale'\nimport { timeScale } from './timeScale'\nimport { createDateNormalizer } from './timeHelpers'\n\nexport const getOtherAxis = axis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a, b) => a === b\nexport const compareDateValues = (a, b) => a.getTime() === b.getTime()\n\nexport const computeXYScalesForSeries = (_series, xScaleSpec, yScaleSpec, width, height) => {\n    const series = _series.map(serie => ({\n        ...serie,\n        data: serie.data.map(d => ({ data: { ...d } })),\n    }))\n\n    let xy = generateSeriesXY(series, xScaleSpec, yScaleSpec)\n    if (xScaleSpec.stacked === true) {\n        stackX(yScaleSpec.type, xy, series)\n    }\n    if (yScaleSpec.stacked === true) {\n        stackY(xScaleSpec.type, xy, series)\n    }\n\n    const xScale = computeScale({ ...xScaleSpec, axis: 'x' }, xy, width, height)\n    const yScale = computeScale({ ...yScaleSpec, axis: 'y' }, xy, width, height)\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            d.position = {\n                x:\n                    xScale.stacked === true\n                        ? d.data.xStacked === null\n                            ? null\n                            : xScale(d.data.xStacked)\n                        : d.data.x === null\n                        ? null\n                        : xScale(d.data.x),\n                y:\n                    yScale.stacked === true\n                        ? d.data.yStacked === null\n                            ? null\n                            : yScale(d.data.yStacked)\n                        : d.data.y === null\n                        ? null\n                        : yScale(d.data.y),\n            }\n        })\n    })\n\n    return {\n        ...xy,\n        series,\n        xScale,\n        yScale,\n    }\n}\n\nexport const computeScale = (spec, xy, width, height) => {\n    if (spec.type === 'linear') return linearScale(spec, xy, width, height)\n    else if (spec.type === 'point') return pointScale(spec, xy, width, height)\n    else if (spec.type === 'time') return timeScale(spec, xy, width, height)\n    else if (spec.type === 'log') return logScale(spec, xy, width, height)\n    else if (spec.type === 'symlog') return symlogScale(spec, xy, width, height)\n}\n\nexport const generateSeriesXY = (series, xScaleSpec, yScaleSpec) => ({\n    x: generateSeriesAxis(series, 'x', xScaleSpec),\n    y: generateSeriesAxis(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = (\n    series,\n    axis,\n    scaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseFloat(getValue(d)))\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        const parseTime = createDateNormalizer(scaleSpec)\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                setValue(d, getValue(d) === null ? null : parseTime(getValue(d)))\n            })\n        })\n    }\n\n    let all = []\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            all.push(getValue(d))\n        })\n    })\n\n    let min, max\n    if (scaleSpec.type === 'linear') {\n        all = uniq(all)\n        all = sortBy(all, v => v)\n        min = Math.min(...all)\n        max = Math.max(...all)\n    } else if (scaleSpec.type === 'time') {\n        all = uniqBy(all, v => v.getTime())\n        all = all\n            .slice(0)\n            .sort((a, b) => b - a)\n            .reverse()\n        min = all[0]\n        max = last(all)\n    } else {\n        all = uniq(all)\n        min = all[0]\n        max = last(all)\n    }\n\n    return { all, min, max }\n}\n\nexport const stackAxis = (axis, otherType, xy, series) => {\n    const otherAxis = getOtherAxis(axis)\n\n    let all = []\n    xy[otherAxis].all.forEach(v => {\n        const compare = isDate(v) ? compareDateValues : compareValues\n        const stack = []\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n            if (datum !== undefined) {\n                value = datum.data[axis]\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n                datum.data[`${axis}Stacked`] = stackValue\n            }\n            stack.push(stackValue)\n            all.push(stackValue)\n        })\n    })\n    all = all.filter(v => v !== null)\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nexport const stackX = (xy, otherType, series) => stackAxis('x', xy, otherType, series)\nexport const stackY = (xy, otherType, series) => stackAxis('y', xy, otherType, series)\n\nexport const computeAxisSlices = (axis, data) => {\n    const otherAxis = getOtherAxis(axis)\n\n    return data[otherAxis].all.map(v => {\n        const slice = {\n            id: v,\n            [otherAxis]: data[`${otherAxis}Scale`](v),\n            data: [],\n        }\n        const compare = isDate(v) ? compareDateValues : compareValues\n        data.series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            if (datum !== undefined) {\n                slice.data.push({\n                    ...datum,\n                    serie,\n                })\n            }\n        })\n        slice.data.reverse()\n\n        return slice\n    })\n}\n\nexport const computeXSlices = data => computeAxisSlices('x', data)\nexport const computeYSlices = data => computeAxisSlices('y', data)\n","/*\n * This file is part of the nivo project.\n *\n * Copyright 2016-present, Raphaël Benitte.\n *\n * For the full copyright and license information, please view the LICENSE\n * file that was distributed with this source code.\n */\nimport PropTypes from 'prop-types'\nimport { linearScalePropTypes } from './linearScale'\nimport { logScalePropTypes } from './logScale'\nimport { symLogScalePropTypes } from './symlogScale'\nimport { pointScalePropTypes } from './pointScale'\nimport { timeScalePropTypes } from './timeScale'\nimport { bandScalePropTypes } from './bandScale'\n\nexport * from './compute'\nexport * from './linearScale'\nexport * from './logScale'\nexport * from './symlogScale'\nexport * from './pointScale'\nexport * from './timeScale'\nexport * from './timeHelpers'\nexport * from './bandScale'\n\nexport const scalePropType = PropTypes.oneOfType([\n    PropTypes.shape(linearScalePropTypes),\n    PropTypes.shape(pointScalePropTypes),\n    PropTypes.shape(timeScalePropTypes),\n    PropTypes.shape(logScalePropTypes),\n    PropTypes.shape(symLogScalePropTypes),\n    PropTypes.shape(bandScalePropTypes),\n])\n"]},"metadata":{},"sourceType":"module"}