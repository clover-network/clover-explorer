{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar imageHelper = require(\"../helper/image\");\n\nvar util_1 = require(\"../../core/util\");\n\nvar text_1 = require(\"../../contain/text\");\n\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nexports.truncateText = truncateText;\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = options || {};\n  var preparedOpts = util_1.extend({}, options);\n  preparedOpts.font = font;\n  ellipsis = util_1.retrieve2(ellipsis, '...');\n  preparedOpts.maxIterations = util_1.retrieve2(options.maxIterations, 2);\n  var minChar = preparedOpts.minChar = util_1.retrieve2(options.minChar, 0);\n  preparedOpts.cnCharWidth = text_1.getWidth('国', font);\n  var ascCharWidth = preparedOpts.ascCharWidth = text_1.getWidth('a', font);\n  preparedOpts.placeholder = util_1.retrieve2(options.placeholder, '');\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = text_1.getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  preparedOpts.ellipsis = ellipsis;\n  preparedOpts.ellipsisWidth = ellipsisWidth;\n  preparedOpts.contentWidth = contentWidth;\n  preparedOpts.containerWidth = containerWidth;\n  return preparedOpts;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = text_1.getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = text_1.getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n\nfunction parsePlainText(text, style) {\n  text != null && (text += '');\n  var overflow = style.overflow;\n  var padding = style.padding;\n  var font = style.font;\n  var truncate = overflow === 'truncate';\n  var calculatedLineHeight = text_1.getLineHeight(font);\n  var lineHeight = util_1.retrieve2(style.lineHeight, calculatedLineHeight);\n  var truncateLineOverflow = style.lineOverflow === 'truncate';\n  var width = style.width;\n  var lines;\n\n  if (width != null && overflow === 'break' || overflow === 'breakAll') {\n    lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];\n  } else {\n    lines = text ? text.split('\\n') : [];\n  }\n\n  var contentHeight = lines.length * lineHeight;\n  var height = util_1.retrieve2(style.height, contentHeight);\n\n  if (contentHeight > height && truncateLineOverflow) {\n    var lineCount = Math.floor(height / lineHeight);\n    lines = lines.slice(0, lineCount);\n  }\n\n  var outerHeight = height;\n  var outerWidth = width;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n\n    if (outerWidth != null) {\n      outerWidth += padding[1] + padding[3];\n    }\n  }\n\n  if (text && truncate && outerWidth != null) {\n    var options = prepareTruncateOptions(width, font, style.ellipsis, {\n      minChar: style.truncateMinChar,\n      placeholder: style.placeholder\n    });\n\n    for (var i = 0; i < lines.length; i++) {\n      lines[i] = truncateSingleLine(lines[i], options);\n    }\n  }\n\n  if (width == null) {\n    var maxWidth = 0;\n\n    for (var i = 0; i < lines.length; i++) {\n      maxWidth = Math.max(text_1.getWidth(lines[i], font), maxWidth);\n    }\n\n    width = maxWidth;\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    calculatedLineHeight: calculatedLineHeight,\n    contentHeight: contentHeight,\n    width: width\n  };\n}\n\nexports.parsePlainText = parsePlainText;\n\nvar RichTextToken = function () {\n  function RichTextToken() {}\n\n  return RichTextToken;\n}();\n\nvar RichTextLine = function () {\n  function RichTextLine(tokens) {\n    this.tokens = [];\n\n    if (tokens) {\n      this.tokens = tokens;\n    }\n  }\n\n  return RichTextLine;\n}();\n\nvar RichTextContentBlock = function () {\n  function RichTextContentBlock() {\n    this.width = 0;\n    this.height = 0;\n    this.contentWidth = 0;\n    this.contentHeight = 0;\n    this.outerWidth = 0;\n    this.outerHeight = 0;\n    this.lines = [];\n  }\n\n  return RichTextContentBlock;\n}();\n\nexports.RichTextContentBlock = RichTextContentBlock;\n\nfunction parseRichText(text, style) {\n  var contentBlock = new RichTextContentBlock();\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var topWidth = style.width;\n  var topHeight = style.height;\n  var overflow = style.overflow;\n  var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null ? {\n    width: topWidth,\n    accumWidth: 0,\n    breakAll: overflow === 'breakAll'\n  } : null;\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);\n    }\n\n    pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);\n  }\n\n  var pendingList = [];\n  var calculatedHeight = 0;\n  var calculatedWidth = 0;\n  var stlPadding = style.padding;\n  var truncate = overflow === 'truncate';\n  var truncateLine = style.lineOverflow === 'truncate';\n  var prevToken;\n\n  function finishLine(line, lineWidth, lineHeight) {\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    calculatedHeight += lineHeight;\n    calculatedWidth = Math.max(calculatedWidth, lineWidth);\n  }\n\n  outer: for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n      var textPadding = token.textPadding = tokenStyle.padding;\n      var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;\n      var font = token.font = tokenStyle.font || style.font;\n      token.contentHeight = text_1.getLineHeight(font);\n      var tokenHeight = util_1.retrieve2(tokenStyle.height, token.contentHeight);\n      token.innerHeight = tokenHeight;\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = util_1.retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);\n      token.align = tokenStyle && tokenStyle.align || style.align;\n      token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';\n\n      if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {\n        if (j > 0) {\n          line.tokens = line.tokens.slice(0, j);\n          finishLine(line, lineWidth, lineHeight);\n          contentBlock.lines = contentBlock.lines.slice(0, i + 1);\n        } else {\n          contentBlock.lines = contentBlock.lines.slice(0, i);\n        }\n\n        break outer;\n      }\n\n      var styleTokenWidth = tokenStyle.width;\n      var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';\n\n      if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {\n        token.percentWidth = styleTokenWidth;\n        pendingList.push(token);\n        token.contentWidth = text_1.getWidth(token.text, font);\n      } else {\n        if (tokenWidthNotSpecified) {\n          var textBackgroundColor = tokenStyle.backgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image;\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var remainTruncWidth = truncate && topWidth != null ? topWidth - lineWidth : null;\n\n        if (remainTruncWidth != null && remainTruncWidth < token.width) {\n          if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {\n            token.text = '';\n            token.width = token.contentWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, {\n              minChar: style.truncateMinChar\n            });\n            token.width = token.contentWidth = text_1.getWidth(token.text, font);\n          }\n        } else {\n          token.contentWidth = text_1.getWidth(token.text, font);\n        }\n      }\n\n      token.width += paddingH;\n      lineWidth += token.width;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n      prevToken = token;\n    }\n\n    finishLine(line, lineWidth, lineHeight);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = util_1.retrieve2(topWidth, calculatedWidth);\n  contentBlock.outerHeight = contentBlock.height = util_1.retrieve2(topHeight, calculatedHeight);\n  contentBlock.contentHeight = calculatedHeight;\n  contentBlock.contentWidth = calculatedWidth;\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth;\n    token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;\n  }\n\n  return contentBlock;\n}\n\nexports.parseRichText = parseRichText;\n\nfunction pushTokens(block, str, style, wrapInfo, styleName) {\n  var isEmptyStr = str === '';\n  var tokenStyle = styleName && style.rich[styleName] || {};\n  var lines = block.lines;\n  var font = tokenStyle.font || style.font;\n  var newLine = false;\n  var strLines;\n  var linesWidths;\n\n  if (wrapInfo) {\n    var tokenPadding = tokenStyle.padding;\n    var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;\n\n    if (tokenStyle.width != null && tokenStyle.width !== 'auto') {\n      var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;\n\n      if (lines.length > 0) {\n        if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {\n          strLines = str.split('\\n');\n          newLine = true;\n        }\n      }\n\n      wrapInfo.accumWidth = outerWidth_1;\n    } else {\n      var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);\n      wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;\n      linesWidths = res.linesWidths;\n      strLines = res.lines;\n    }\n  } else {\n    strLines = str.split('\\n');\n  }\n\n  for (var i = 0; i < strLines.length; i++) {\n    var text = strLines[i];\n    var token = new RichTextToken();\n    token.styleName = styleName;\n    token.text = text;\n    token.isLineHolder = !text && !isEmptyStr;\n\n    if (typeof tokenStyle.width === 'number') {\n      token.width = tokenStyle.width;\n    } else {\n      token.width = linesWidths ? linesWidths[i] : text_1.getWidth(text, font);\n    }\n\n    if (!i && !newLine) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } else {\n      lines.push(new RichTextLine([token]));\n    }\n  }\n}\n\nfunction isLatin(ch) {\n  var code = ch.charCodeAt(0);\n  return code >= 0x21 && code <= 0xFF;\n}\n\nvar breakCharMap = util_1.reduce(',&?/;] '.split(''), function (obj, ch) {\n  obj[ch] = true;\n  return obj;\n}, {});\n\nfunction isWordBreakChar(ch) {\n  if (isLatin(ch)) {\n    if (breakCharMap[ch]) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return true;\n}\n\nfunction wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {\n  var lines = [];\n  var linesWidths = [];\n  var line = '';\n  var currentWord = '';\n  var currentWordWidth = 0;\n  var accumWidth = 0;\n\n  for (var i = 0; i < text.length; i++) {\n    var ch = text.charAt(i);\n\n    if (ch === '\\n') {\n      if (currentWord) {\n        line += currentWord;\n        accumWidth += currentWordWidth;\n      }\n\n      lines.push(line);\n      linesWidths.push(accumWidth);\n      line = '';\n      currentWord = '';\n      currentWordWidth = 0;\n      accumWidth = 0;\n      continue;\n    }\n\n    var chWidth = text_1.getWidth(ch, font);\n    var inWord = isBreakAll ? false : !isWordBreakChar(ch);\n\n    if (!lines.length ? lastAccumWidth + accumWidth + chWidth > lineWidth : accumWidth + chWidth > lineWidth) {\n      if (!accumWidth) {\n        if (inWord) {\n          lines.push(currentWord);\n          linesWidths.push(currentWordWidth);\n          currentWord = ch;\n          currentWordWidth = chWidth;\n        } else {\n          lines.push(ch);\n          linesWidths.push(chWidth);\n        }\n      } else if (line || currentWord) {\n        if (inWord) {\n          if (!line) {\n            line = currentWord;\n            currentWord = '';\n            currentWordWidth = 0;\n            accumWidth = currentWordWidth;\n          }\n\n          lines.push(line);\n          linesWidths.push(accumWidth - currentWordWidth);\n          currentWord += ch;\n          currentWordWidth += chWidth;\n          line = '';\n          accumWidth = currentWordWidth;\n        } else {\n          if (currentWord) {\n            line += currentWord;\n            accumWidth += currentWordWidth;\n            currentWord = '';\n            currentWordWidth = 0;\n          }\n\n          lines.push(line);\n          linesWidths.push(accumWidth);\n          line = ch;\n          accumWidth = chWidth;\n        }\n      }\n\n      continue;\n    }\n\n    accumWidth += chWidth;\n\n    if (inWord) {\n      currentWord += ch;\n      currentWordWidth += chWidth;\n    } else {\n      if (currentWord) {\n        line += currentWord;\n        currentWord = '';\n        currentWordWidth = 0;\n      }\n\n      line += ch;\n    }\n  }\n\n  if (!lines.length && !line) {\n    line = text;\n    currentWord = '';\n    currentWordWidth = 0;\n  }\n\n  if (currentWord) {\n    line += currentWord;\n  }\n\n  if (line) {\n    lines.push(line);\n    linesWidths.push(accumWidth);\n  }\n\n  if (lines.length === 1) {\n    accumWidth += lastAccumWidth;\n  }\n\n  return {\n    accumWidth: accumWidth,\n    lines: lines,\n    linesWidths: linesWidths\n  };\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/zrender/lib/graphic/helper/parseText.js"],"names":["exports","__esModule","imageHelper","require","util_1","text_1","STYLE_REG","truncateText","text","containerWidth","font","ellipsis","options","textLines","split","prepareTruncateOptions","i","len","length","truncateSingleLine","join","preparedOpts","extend","retrieve2","maxIterations","minChar","cnCharWidth","getWidth","ascCharWidth","placeholder","contentWidth","Math","max","ellipsisWidth","textLine","lineWidth","j","subLength","estimateLength","floor","substr","width","charCode","charCodeAt","parsePlainText","style","overflow","padding","truncate","calculatedLineHeight","getLineHeight","lineHeight","truncateLineOverflow","lineOverflow","lines","wrapText","contentHeight","height","lineCount","slice","outerHeight","outerWidth","truncateMinChar","maxWidth","RichTextToken","RichTextLine","tokens","RichTextContentBlock","parseRichText","contentBlock","topWidth","topHeight","wrapInfo","accumWidth","breakAll","lastIndex","result","exec","matchedIndex","index","pushTokens","substring","pendingList","calculatedHeight","calculatedWidth","stlPadding","truncateLine","prevToken","finishLine","line","outer","token","tokenStyle","styleName","rich","textPadding","paddingH","tokenHeight","innerHeight","retrieve3","align","verticalAlign","styleTokenWidth","tokenWidthNotSpecified","charAt","percentWidth","push","textBackgroundColor","backgroundColor","bgImg","image","findExistImage","isImageReady","remainTruncWidth","parseInt","block","str","isEmptyStr","newLine","strLines","linesWidths","tokenPadding","tokenPaddingH","outerWidth_1","parsePercent","res","isLineHolder","tokensLen","isLatin","ch","code","breakCharMap","reduce","obj","isWordBreakChar","isBreakAll","lastAccumWidth","currentWord","currentWordWidth","chWidth","inWord","value","maxValue","lastIndexOf","parseFloat"],"mappings":"AAAA;;AACAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AACA,IAAIC,WAAW,GAAGC,OAAO,CAAC,iBAAD,CAAzB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,iBAAD,CAApB;;AACA,IAAIE,MAAM,GAAGF,OAAO,CAAC,oBAAD,CAApB;;AACA,IAAIG,SAAS,GAAG,+BAAhB;;AACA,SAASC,YAAT,CAAsBC,IAAtB,EAA4BC,cAA5B,EAA4CC,IAA5C,EAAkDC,QAAlD,EAA4DC,OAA5D,EAAqE;AACjE,MAAI,CAACH,cAAL,EAAqB;AACjB,WAAO,EAAP;AACH;;AACD,MAAII,SAAS,GAAG,CAACL,IAAI,GAAG,EAAR,EAAYM,KAAZ,CAAkB,IAAlB,CAAhB;AACAF,EAAAA,OAAO,GAAGG,sBAAsB,CAACN,cAAD,EAAiBC,IAAjB,EAAuBC,QAAvB,EAAiCC,OAAjC,CAAhC;;AACA,OAAK,IAAII,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGJ,SAAS,CAACK,MAAhC,EAAwCF,CAAC,GAAGC,GAA5C,EAAiDD,CAAC,EAAlD,EAAsD;AAClDH,IAAAA,SAAS,CAACG,CAAD,CAAT,GAAeG,kBAAkB,CAACN,SAAS,CAACG,CAAD,CAAV,EAAeJ,OAAf,CAAjC;AACH;;AACD,SAAOC,SAAS,CAACO,IAAV,CAAe,IAAf,CAAP;AACH;;AACDpB,OAAO,CAACO,YAAR,GAAuBA,YAAvB;;AACA,SAASQ,sBAAT,CAAgCN,cAAhC,EAAgDC,IAAhD,EAAsDC,QAAtD,EAAgEC,OAAhE,EAAyE;AACrEA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,MAAIS,YAAY,GAAGjB,MAAM,CAACkB,MAAP,CAAc,EAAd,EAAkBV,OAAlB,CAAnB;AACAS,EAAAA,YAAY,CAACX,IAAb,GAAoBA,IAApB;AACAC,EAAAA,QAAQ,GAAGP,MAAM,CAACmB,SAAP,CAAiBZ,QAAjB,EAA2B,KAA3B,CAAX;AACAU,EAAAA,YAAY,CAACG,aAAb,GAA6BpB,MAAM,CAACmB,SAAP,CAAiBX,OAAO,CAACY,aAAzB,EAAwC,CAAxC,CAA7B;AACA,MAAIC,OAAO,GAAGJ,YAAY,CAACI,OAAb,GAAuBrB,MAAM,CAACmB,SAAP,CAAiBX,OAAO,CAACa,OAAzB,EAAkC,CAAlC,CAArC;AACAJ,EAAAA,YAAY,CAACK,WAAb,GAA2BrB,MAAM,CAACsB,QAAP,CAAgB,GAAhB,EAAqBjB,IAArB,CAA3B;AACA,MAAIkB,YAAY,GAAGP,YAAY,CAACO,YAAb,GAA4BvB,MAAM,CAACsB,QAAP,CAAgB,GAAhB,EAAqBjB,IAArB,CAA/C;AACAW,EAAAA,YAAY,CAACQ,WAAb,GAA2BzB,MAAM,CAACmB,SAAP,CAAiBX,OAAO,CAACiB,WAAzB,EAAsC,EAAtC,CAA3B;AACA,MAAIC,YAAY,GAAGrB,cAAc,GAAGsB,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYvB,cAAc,GAAG,CAA7B,CAApC;;AACA,OAAK,IAAIO,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,OAAJ,IAAeK,YAAY,IAAIF,YAA/C,EAA6DZ,CAAC,EAA9D,EAAkE;AAC9Dc,IAAAA,YAAY,IAAIF,YAAhB;AACH;;AACD,MAAIK,aAAa,GAAG5B,MAAM,CAACsB,QAAP,CAAgBhB,QAAhB,EAA0BD,IAA1B,CAApB;;AACA,MAAIuB,aAAa,GAAGH,YAApB,EAAkC;AAC9BnB,IAAAA,QAAQ,GAAG,EAAX;AACAsB,IAAAA,aAAa,GAAG,CAAhB;AACH;;AACDH,EAAAA,YAAY,GAAGrB,cAAc,GAAGwB,aAAhC;AACAZ,EAAAA,YAAY,CAACV,QAAb,GAAwBA,QAAxB;AACAU,EAAAA,YAAY,CAACY,aAAb,GAA6BA,aAA7B;AACAZ,EAAAA,YAAY,CAACS,YAAb,GAA4BA,YAA5B;AACAT,EAAAA,YAAY,CAACZ,cAAb,GAA8BA,cAA9B;AACA,SAAOY,YAAP;AACH;;AACD,SAASF,kBAAT,CAA4Be,QAA5B,EAAsCtB,OAAtC,EAA+C;AAC3C,MAAIH,cAAc,GAAGG,OAAO,CAACH,cAA7B;AACA,MAAIC,IAAI,GAAGE,OAAO,CAACF,IAAnB;AACA,MAAIoB,YAAY,GAAGlB,OAAO,CAACkB,YAA3B;;AACA,MAAI,CAACrB,cAAL,EAAqB;AACjB,WAAO,EAAP;AACH;;AACD,MAAI0B,SAAS,GAAG9B,MAAM,CAACsB,QAAP,CAAgBO,QAAhB,EAA0BxB,IAA1B,CAAhB;;AACA,MAAIyB,SAAS,IAAI1B,cAAjB,EAAiC;AAC7B,WAAOyB,QAAP;AACH;;AACD,OAAK,IAAIE,CAAC,GAAG,CAAb,GAAiBA,CAAC,EAAlB,EAAsB;AAClB,QAAID,SAAS,IAAIL,YAAb,IAA6BM,CAAC,IAAIxB,OAAO,CAACY,aAA9C,EAA6D;AACzDU,MAAAA,QAAQ,IAAItB,OAAO,CAACD,QAApB;AACA;AACH;;AACD,QAAI0B,SAAS,GAAGD,CAAC,KAAK,CAAN,GACVE,cAAc,CAACJ,QAAD,EAAWJ,YAAX,EAAyBlB,OAAO,CAACgB,YAAjC,EAA+ChB,OAAO,CAACc,WAAvD,CADJ,GAEVS,SAAS,GAAG,CAAZ,GACIJ,IAAI,CAACQ,KAAL,CAAWL,QAAQ,CAAChB,MAAT,GAAkBY,YAAlB,GAAiCK,SAA5C,CADJ,GAEI,CAJV;AAKAD,IAAAA,QAAQ,GAAGA,QAAQ,CAACM,MAAT,CAAgB,CAAhB,EAAmBH,SAAnB,CAAX;AACAF,IAAAA,SAAS,GAAG9B,MAAM,CAACsB,QAAP,CAAgBO,QAAhB,EAA0BxB,IAA1B,CAAZ;AACH;;AACD,MAAIwB,QAAQ,KAAK,EAAjB,EAAqB;AACjBA,IAAAA,QAAQ,GAAGtB,OAAO,CAACiB,WAAnB;AACH;;AACD,SAAOK,QAAP;AACH;;AACD,SAASI,cAAT,CAAwB9B,IAAxB,EAA8BsB,YAA9B,EAA4CF,YAA5C,EAA0DF,WAA1D,EAAuE;AACnE,MAAIe,KAAK,GAAG,CAAZ;AACA,MAAIzB,CAAC,GAAG,CAAR;;AACA,OAAK,IAAIC,GAAG,GAAGT,IAAI,CAACU,MAApB,EAA4BF,CAAC,GAAGC,GAAJ,IAAWwB,KAAK,GAAGX,YAA/C,EAA6Dd,CAAC,EAA9D,EAAkE;AAC9D,QAAI0B,QAAQ,GAAGlC,IAAI,CAACmC,UAAL,CAAgB3B,CAAhB,CAAf;AACAyB,IAAAA,KAAK,IAAK,KAAKC,QAAL,IAAiBA,QAAQ,IAAI,GAA9B,GAAqCd,YAArC,GAAoDF,WAA7D;AACH;;AACD,SAAOV,CAAP;AACH;;AACD,SAAS4B,cAAT,CAAwBpC,IAAxB,EAA8BqC,KAA9B,EAAqC;AACjCrC,EAAAA,IAAI,IAAI,IAAR,KAAiBA,IAAI,IAAI,EAAzB;AACA,MAAIsC,QAAQ,GAAGD,KAAK,CAACC,QAArB;AACA,MAAIC,OAAO,GAAGF,KAAK,CAACE,OAApB;AACA,MAAIrC,IAAI,GAAGmC,KAAK,CAACnC,IAAjB;AACA,MAAIsC,QAAQ,GAAGF,QAAQ,KAAK,UAA5B;AACA,MAAIG,oBAAoB,GAAG5C,MAAM,CAAC6C,aAAP,CAAqBxC,IAArB,CAA3B;AACA,MAAIyC,UAAU,GAAG/C,MAAM,CAACmB,SAAP,CAAiBsB,KAAK,CAACM,UAAvB,EAAmCF,oBAAnC,CAAjB;AACA,MAAIG,oBAAoB,GAAGP,KAAK,CAACQ,YAAN,KAAuB,UAAlD;AACA,MAAIZ,KAAK,GAAGI,KAAK,CAACJ,KAAlB;AACA,MAAIa,KAAJ;;AACA,MAAIb,KAAK,IAAI,IAAT,IAAiBK,QAAQ,KAAK,OAA9B,IAAyCA,QAAQ,KAAK,UAA1D,EAAsE;AAClEQ,IAAAA,KAAK,GAAG9C,IAAI,GAAG+C,QAAQ,CAAC/C,IAAD,EAAOqC,KAAK,CAACnC,IAAb,EAAmB+B,KAAnB,EAA0BK,QAAQ,KAAK,UAAvC,EAAmD,CAAnD,CAAR,CAA8DQ,KAAjE,GAAyE,EAArF;AACH,GAFD,MAGK;AACDA,IAAAA,KAAK,GAAG9C,IAAI,GAAGA,IAAI,CAACM,KAAL,CAAW,IAAX,CAAH,GAAsB,EAAlC;AACH;;AACD,MAAI0C,aAAa,GAAGF,KAAK,CAACpC,MAAN,GAAeiC,UAAnC;AACA,MAAIM,MAAM,GAAGrD,MAAM,CAACmB,SAAP,CAAiBsB,KAAK,CAACY,MAAvB,EAA+BD,aAA/B,CAAb;;AACA,MAAIA,aAAa,GAAGC,MAAhB,IAA0BL,oBAA9B,EAAoD;AAChD,QAAIM,SAAS,GAAG3B,IAAI,CAACQ,KAAL,CAAWkB,MAAM,GAAGN,UAApB,CAAhB;AACAG,IAAAA,KAAK,GAAGA,KAAK,CAACK,KAAN,CAAY,CAAZ,EAAeD,SAAf,CAAR;AACH;;AACD,MAAIE,WAAW,GAAGH,MAAlB;AACA,MAAII,UAAU,GAAGpB,KAAjB;;AACA,MAAIM,OAAJ,EAAa;AACTa,IAAAA,WAAW,IAAIb,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAAnC;;AACA,QAAIc,UAAU,IAAI,IAAlB,EAAwB;AACpBA,MAAAA,UAAU,IAAId,OAAO,CAAC,CAAD,CAAP,GAAaA,OAAO,CAAC,CAAD,CAAlC;AACH;AACJ;;AACD,MAAIvC,IAAI,IAAIwC,QAAR,IAAoBa,UAAU,IAAI,IAAtC,EAA4C;AACxC,QAAIjD,OAAO,GAAGG,sBAAsB,CAAC0B,KAAD,EAAQ/B,IAAR,EAAcmC,KAAK,CAAClC,QAApB,EAA8B;AAC9Dc,MAAAA,OAAO,EAAEoB,KAAK,CAACiB,eAD+C;AAE9DjC,MAAAA,WAAW,EAAEgB,KAAK,CAAChB;AAF2C,KAA9B,CAApC;;AAIA,SAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,KAAK,CAACpC,MAA1B,EAAkCF,CAAC,EAAnC,EAAuC;AACnCsC,MAAAA,KAAK,CAACtC,CAAD,CAAL,GAAWG,kBAAkB,CAACmC,KAAK,CAACtC,CAAD,CAAN,EAAWJ,OAAX,CAA7B;AACH;AACJ;;AACD,MAAI6B,KAAK,IAAI,IAAb,EAAmB;AACf,QAAIsB,QAAQ,GAAG,CAAf;;AACA,SAAK,IAAI/C,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsC,KAAK,CAACpC,MAA1B,EAAkCF,CAAC,EAAnC,EAAuC;AACnC+C,MAAAA,QAAQ,GAAGhC,IAAI,CAACC,GAAL,CAAS3B,MAAM,CAACsB,QAAP,CAAgB2B,KAAK,CAACtC,CAAD,CAArB,EAA0BN,IAA1B,CAAT,EAA0CqD,QAA1C,CAAX;AACH;;AACDtB,IAAAA,KAAK,GAAGsB,QAAR;AACH;;AACD,SAAO;AACHT,IAAAA,KAAK,EAAEA,KADJ;AAEHG,IAAAA,MAAM,EAAEA,MAFL;AAGHG,IAAAA,WAAW,EAAEA,WAHV;AAIHT,IAAAA,UAAU,EAAEA,UAJT;AAKHF,IAAAA,oBAAoB,EAAEA,oBALnB;AAMHO,IAAAA,aAAa,EAAEA,aANZ;AAOHf,IAAAA,KAAK,EAAEA;AAPJ,GAAP;AASH;;AACDzC,OAAO,CAAC4C,cAAR,GAAyBA,cAAzB;;AACA,IAAIoB,aAAa,GAAI,YAAY;AAC7B,WAASA,aAAT,GAAyB,CACxB;;AACD,SAAOA,aAAP;AACH,CAJoB,EAArB;;AAKA,IAAIC,YAAY,GAAI,YAAY;AAC5B,WAASA,YAAT,CAAsBC,MAAtB,EAA8B;AAC1B,SAAKA,MAAL,GAAc,EAAd;;AACA,QAAIA,MAAJ,EAAY;AACR,WAAKA,MAAL,GAAcA,MAAd;AACH;AACJ;;AACD,SAAOD,YAAP;AACH,CARmB,EAApB;;AASA,IAAIE,oBAAoB,GAAI,YAAY;AACpC,WAASA,oBAAT,GAAgC;AAC5B,SAAK1B,KAAL,GAAa,CAAb;AACA,SAAKgB,MAAL,GAAc,CAAd;AACA,SAAK3B,YAAL,GAAoB,CAApB;AACA,SAAK0B,aAAL,GAAqB,CAArB;AACA,SAAKK,UAAL,GAAkB,CAAlB;AACA,SAAKD,WAAL,GAAmB,CAAnB;AACA,SAAKN,KAAL,GAAa,EAAb;AACH;;AACD,SAAOa,oBAAP;AACH,CAX2B,EAA5B;;AAYAnE,OAAO,CAACmE,oBAAR,GAA+BA,oBAA/B;;AACA,SAASC,aAAT,CAAuB5D,IAAvB,EAA6BqC,KAA7B,EAAoC;AAChC,MAAIwB,YAAY,GAAG,IAAIF,oBAAJ,EAAnB;AACA3D,EAAAA,IAAI,IAAI,IAAR,KAAiBA,IAAI,IAAI,EAAzB;;AACA,MAAI,CAACA,IAAL,EAAW;AACP,WAAO6D,YAAP;AACH;;AACD,MAAIC,QAAQ,GAAGzB,KAAK,CAACJ,KAArB;AACA,MAAI8B,SAAS,GAAG1B,KAAK,CAACY,MAAtB;AACA,MAAIX,QAAQ,GAAGD,KAAK,CAACC,QAArB;AACA,MAAI0B,QAAQ,GAAG,CAAC1B,QAAQ,KAAK,OAAb,IAAwBA,QAAQ,KAAK,UAAtC,KAAqDwB,QAAQ,IAAI,IAAjE,GACT;AAAE7B,IAAAA,KAAK,EAAE6B,QAAT;AAAmBG,IAAAA,UAAU,EAAE,CAA/B;AAAkCC,IAAAA,QAAQ,EAAE5B,QAAQ,KAAK;AAAzD,GADS,GAET,IAFN;AAGA,MAAI6B,SAAS,GAAGrE,SAAS,CAACqE,SAAV,GAAsB,CAAtC;AACA,MAAIC,MAAJ;;AACA,SAAO,CAACA,MAAM,GAAGtE,SAAS,CAACuE,IAAV,CAAerE,IAAf,CAAV,KAAmC,IAA1C,EAAgD;AAC5C,QAAIsE,YAAY,GAAGF,MAAM,CAACG,KAA1B;;AACA,QAAID,YAAY,GAAGH,SAAnB,EAA8B;AAC1BK,MAAAA,UAAU,CAACX,YAAD,EAAe7D,IAAI,CAACyE,SAAL,CAAeN,SAAf,EAA0BG,YAA1B,CAAf,EAAwDjC,KAAxD,EAA+D2B,QAA/D,CAAV;AACH;;AACDQ,IAAAA,UAAU,CAACX,YAAD,EAAeO,MAAM,CAAC,CAAD,CAArB,EAA0B/B,KAA1B,EAAiC2B,QAAjC,EAA2CI,MAAM,CAAC,CAAD,CAAjD,CAAV;AACAD,IAAAA,SAAS,GAAGrE,SAAS,CAACqE,SAAtB;AACH;;AACD,MAAIA,SAAS,GAAGnE,IAAI,CAACU,MAArB,EAA6B;AACzB8D,IAAAA,UAAU,CAACX,YAAD,EAAe7D,IAAI,CAACyE,SAAL,CAAeN,SAAf,EAA0BnE,IAAI,CAACU,MAA/B,CAAf,EAAuD2B,KAAvD,EAA8D2B,QAA9D,CAAV;AACH;;AACD,MAAIU,WAAW,GAAG,EAAlB;AACA,MAAIC,gBAAgB,GAAG,CAAvB;AACA,MAAIC,eAAe,GAAG,CAAtB;AACA,MAAIC,UAAU,GAAGxC,KAAK,CAACE,OAAvB;AACA,MAAIC,QAAQ,GAAGF,QAAQ,KAAK,UAA5B;AACA,MAAIwC,YAAY,GAAGzC,KAAK,CAACQ,YAAN,KAAuB,UAA1C;AACA,MAAIkC,SAAJ;;AACA,WAASC,UAAT,CAAoBC,IAApB,EAA0BtD,SAA1B,EAAqCgB,UAArC,EAAiD;AAC7CsC,IAAAA,IAAI,CAAChD,KAAL,GAAaN,SAAb;AACAsD,IAAAA,IAAI,CAACtC,UAAL,GAAkBA,UAAlB;AACAgC,IAAAA,gBAAgB,IAAIhC,UAApB;AACAiC,IAAAA,eAAe,GAAGrD,IAAI,CAACC,GAAL,CAASoD,eAAT,EAA0BjD,SAA1B,CAAlB;AACH;;AACDuD,EAAAA,KAAK,EAAE,KAAK,IAAI1E,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,YAAY,CAACf,KAAb,CAAmBpC,MAAvC,EAA+CF,CAAC,EAAhD,EAAoD;AACvD,QAAIyE,IAAI,GAAGpB,YAAY,CAACf,KAAb,CAAmBtC,CAAnB,CAAX;AACA,QAAImC,UAAU,GAAG,CAAjB;AACA,QAAIhB,SAAS,GAAG,CAAhB;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqD,IAAI,CAACvB,MAAL,CAAYhD,MAAhC,EAAwCkB,CAAC,EAAzC,EAA6C;AACzC,UAAIuD,KAAK,GAAGF,IAAI,CAACvB,MAAL,CAAY9B,CAAZ,CAAZ;AACA,UAAIwD,UAAU,GAAGD,KAAK,CAACE,SAAN,IAAmBhD,KAAK,CAACiD,IAAN,CAAWH,KAAK,CAACE,SAAjB,CAAnB,IAAkD,EAAnE;AACA,UAAIE,WAAW,GAAGJ,KAAK,CAACI,WAAN,GAAoBH,UAAU,CAAC7C,OAAjD;AACA,UAAIiD,QAAQ,GAAGD,WAAW,GAAGA,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA/B,GAAqC,CAA/D;AACA,UAAIrF,IAAI,GAAGiF,KAAK,CAACjF,IAAN,GAAakF,UAAU,CAAClF,IAAX,IAAmBmC,KAAK,CAACnC,IAAjD;AACAiF,MAAAA,KAAK,CAACnC,aAAN,GAAsBnD,MAAM,CAAC6C,aAAP,CAAqBxC,IAArB,CAAtB;AACA,UAAIuF,WAAW,GAAG7F,MAAM,CAACmB,SAAP,CAAiBqE,UAAU,CAACnC,MAA5B,EAAoCkC,KAAK,CAACnC,aAA1C,CAAlB;AACAmC,MAAAA,KAAK,CAACO,WAAN,GAAoBD,WAApB;AACAF,MAAAA,WAAW,KAAKE,WAAW,IAAIF,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAAhD,CAAX;AACAJ,MAAAA,KAAK,CAAClC,MAAN,GAAewC,WAAf;AACAN,MAAAA,KAAK,CAACxC,UAAN,GAAmB/C,MAAM,CAAC+F,SAAP,CAAiBP,UAAU,CAACzC,UAA5B,EAAwCN,KAAK,CAACM,UAA9C,EAA0D8C,WAA1D,CAAnB;AACAN,MAAAA,KAAK,CAACS,KAAN,GAAcR,UAAU,IAAIA,UAAU,CAACQ,KAAzB,IAAkCvD,KAAK,CAACuD,KAAtD;AACAT,MAAAA,KAAK,CAACU,aAAN,GAAsBT,UAAU,IAAIA,UAAU,CAACS,aAAzB,IAA0C,QAAhE;;AACA,UAAIf,YAAY,IAAIf,SAAS,IAAI,IAA7B,IAAqCY,gBAAgB,GAAGQ,KAAK,CAACxC,UAAzB,GAAsCoB,SAA/E,EAA0F;AACtF,YAAInC,CAAC,GAAG,CAAR,EAAW;AACPqD,UAAAA,IAAI,CAACvB,MAAL,GAAcuB,IAAI,CAACvB,MAAL,CAAYP,KAAZ,CAAkB,CAAlB,EAAqBvB,CAArB,CAAd;AACAoD,UAAAA,UAAU,CAACC,IAAD,EAAOtD,SAAP,EAAkBgB,UAAlB,CAAV;AACAkB,UAAAA,YAAY,CAACf,KAAb,GAAqBe,YAAY,CAACf,KAAb,CAAmBK,KAAnB,CAAyB,CAAzB,EAA4B3C,CAAC,GAAG,CAAhC,CAArB;AACH,SAJD,MAKK;AACDqD,UAAAA,YAAY,CAACf,KAAb,GAAqBe,YAAY,CAACf,KAAb,CAAmBK,KAAnB,CAAyB,CAAzB,EAA4B3C,CAA5B,CAArB;AACH;;AACD,cAAM0E,KAAN;AACH;;AACD,UAAIY,eAAe,GAAGV,UAAU,CAACnD,KAAjC;AACA,UAAI8D,sBAAsB,GAAGD,eAAe,IAAI,IAAnB,IAA2BA,eAAe,KAAK,MAA5E;;AACA,UAAI,OAAOA,eAAP,KAA2B,QAA3B,IAAuCA,eAAe,CAACE,MAAhB,CAAuBF,eAAe,CAACpF,MAAhB,GAAyB,CAAhD,MAAuD,GAAlG,EAAuG;AACnGyE,QAAAA,KAAK,CAACc,YAAN,GAAqBH,eAArB;AACApB,QAAAA,WAAW,CAACwB,IAAZ,CAAiBf,KAAjB;AACAA,QAAAA,KAAK,CAAC7D,YAAN,GAAqBzB,MAAM,CAACsB,QAAP,CAAgBgE,KAAK,CAACnF,IAAtB,EAA4BE,IAA5B,CAArB;AACH,OAJD,MAKK;AACD,YAAI6F,sBAAJ,EAA4B;AACxB,cAAII,mBAAmB,GAAGf,UAAU,CAACgB,eAArC;AACA,cAAIC,KAAK,GAAGF,mBAAmB,IAAIA,mBAAmB,CAACG,KAAvD;;AACA,cAAID,KAAJ,EAAW;AACPA,YAAAA,KAAK,GAAG3G,WAAW,CAAC6G,cAAZ,CAA2BF,KAA3B,CAAR;;AACA,gBAAI3G,WAAW,CAAC8G,YAAZ,CAAyBH,KAAzB,CAAJ,EAAqC;AACjClB,cAAAA,KAAK,CAAClD,KAAN,GAAcV,IAAI,CAACC,GAAL,CAAS2D,KAAK,CAAClD,KAAf,EAAsBoE,KAAK,CAACpE,KAAN,GAAcwD,WAAd,GAA4BY,KAAK,CAACpD,MAAxD,CAAd;AACH;AACJ;AACJ;;AACD,YAAIwD,gBAAgB,GAAGjE,QAAQ,IAAIsB,QAAQ,IAAI,IAAxB,GACjBA,QAAQ,GAAGnC,SADM,GACM,IAD7B;;AAEA,YAAI8E,gBAAgB,IAAI,IAApB,IAA4BA,gBAAgB,GAAGtB,KAAK,CAAClD,KAAzD,EAAgE;AAC5D,cAAI,CAAC8D,sBAAD,IAA2BU,gBAAgB,GAAGjB,QAAlD,EAA4D;AACxDL,YAAAA,KAAK,CAACnF,IAAN,GAAa,EAAb;AACAmF,YAAAA,KAAK,CAAClD,KAAN,GAAckD,KAAK,CAAC7D,YAAN,GAAqB,CAAnC;AACH,WAHD,MAIK;AACD6D,YAAAA,KAAK,CAACnF,IAAN,GAAaD,YAAY,CAACoF,KAAK,CAACnF,IAAP,EAAayG,gBAAgB,GAAGjB,QAAhC,EAA0CtF,IAA1C,EAAgDmC,KAAK,CAAClC,QAAtD,EAAgE;AAAEc,cAAAA,OAAO,EAAEoB,KAAK,CAACiB;AAAjB,aAAhE,CAAzB;AACA6B,YAAAA,KAAK,CAAClD,KAAN,GAAckD,KAAK,CAAC7D,YAAN,GAAqBzB,MAAM,CAACsB,QAAP,CAAgBgE,KAAK,CAACnF,IAAtB,EAA4BE,IAA5B,CAAnC;AACH;AACJ,SATD,MAUK;AACDiF,UAAAA,KAAK,CAAC7D,YAAN,GAAqBzB,MAAM,CAACsB,QAAP,CAAgBgE,KAAK,CAACnF,IAAtB,EAA4BE,IAA5B,CAArB;AACH;AACJ;;AACDiF,MAAAA,KAAK,CAAClD,KAAN,IAAeuD,QAAf;AACA7D,MAAAA,SAAS,IAAIwD,KAAK,CAAClD,KAAnB;AACAmD,MAAAA,UAAU,KAAKzC,UAAU,GAAGpB,IAAI,CAACC,GAAL,CAASmB,UAAT,EAAqBwC,KAAK,CAACxC,UAA3B,CAAlB,CAAV;AACAoC,MAAAA,SAAS,GAAGI,KAAZ;AACH;;AACDH,IAAAA,UAAU,CAACC,IAAD,EAAOtD,SAAP,EAAkBgB,UAAlB,CAAV;AACH;;AACDkB,EAAAA,YAAY,CAACR,UAAb,GAA0BQ,YAAY,CAAC5B,KAAb,GAAqBrC,MAAM,CAACmB,SAAP,CAAiB+C,QAAjB,EAA2Bc,eAA3B,CAA/C;AACAf,EAAAA,YAAY,CAACT,WAAb,GAA2BS,YAAY,CAACZ,MAAb,GAAsBrD,MAAM,CAACmB,SAAP,CAAiBgD,SAAjB,EAA4BY,gBAA5B,CAAjD;AACAd,EAAAA,YAAY,CAACb,aAAb,GAA6B2B,gBAA7B;AACAd,EAAAA,YAAY,CAACvC,YAAb,GAA4BsD,eAA5B;;AACA,MAAIC,UAAJ,EAAgB;AACZhB,IAAAA,YAAY,CAACR,UAAb,IAA2BwB,UAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAArD;AACAhB,IAAAA,YAAY,CAACT,WAAb,IAA4ByB,UAAU,CAAC,CAAD,CAAV,GAAgBA,UAAU,CAAC,CAAD,CAAtD;AACH;;AACD,OAAK,IAAIrE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkE,WAAW,CAAChE,MAAhC,EAAwCF,CAAC,EAAzC,EAA6C;AACzC,QAAI2E,KAAK,GAAGT,WAAW,CAAClE,CAAD,CAAvB;AACA,QAAIyF,YAAY,GAAGd,KAAK,CAACc,YAAzB;AACAd,IAAAA,KAAK,CAAClD,KAAN,GAAcyE,QAAQ,CAACT,YAAD,EAAe,EAAf,CAAR,GAA6B,GAA7B,GAAmCpC,YAAY,CAAC5B,KAA9D;AACH;;AACD,SAAO4B,YAAP;AACH;;AACDrE,OAAO,CAACoE,aAAR,GAAwBA,aAAxB;;AACA,SAASY,UAAT,CAAoBmC,KAApB,EAA2BC,GAA3B,EAAgCvE,KAAhC,EAAuC2B,QAAvC,EAAiDqB,SAAjD,EAA4D;AACxD,MAAIwB,UAAU,GAAGD,GAAG,KAAK,EAAzB;AACA,MAAIxB,UAAU,GAAGC,SAAS,IAAIhD,KAAK,CAACiD,IAAN,CAAWD,SAAX,CAAb,IAAsC,EAAvD;AACA,MAAIvC,KAAK,GAAG6D,KAAK,CAAC7D,KAAlB;AACA,MAAI5C,IAAI,GAAGkF,UAAU,CAAClF,IAAX,IAAmBmC,KAAK,CAACnC,IAApC;AACA,MAAI4G,OAAO,GAAG,KAAd;AACA,MAAIC,QAAJ;AACA,MAAIC,WAAJ;;AACA,MAAIhD,QAAJ,EAAc;AACV,QAAIiD,YAAY,GAAG7B,UAAU,CAAC7C,OAA9B;AACA,QAAI2E,aAAa,GAAGD,YAAY,GAAGA,YAAY,CAAC,CAAD,CAAZ,GAAkBA,YAAY,CAAC,CAAD,CAAjC,GAAuC,CAAvE;;AACA,QAAI7B,UAAU,CAACnD,KAAX,IAAoB,IAApB,IAA4BmD,UAAU,CAACnD,KAAX,KAAqB,MAArD,EAA6D;AACzD,UAAIkF,YAAY,GAAGC,YAAY,CAAChC,UAAU,CAACnD,KAAZ,EAAmB+B,QAAQ,CAAC/B,KAA5B,CAAZ,GAAiDiF,aAApE;;AACA,UAAIpE,KAAK,CAACpC,MAAN,GAAe,CAAnB,EAAsB;AAClB,YAAIyG,YAAY,GAAGnD,QAAQ,CAACC,UAAxB,GAAqCD,QAAQ,CAAC/B,KAAlD,EAAyD;AACrD8E,UAAAA,QAAQ,GAAGH,GAAG,CAACtG,KAAJ,CAAU,IAAV,CAAX;AACAwG,UAAAA,OAAO,GAAG,IAAV;AACH;AACJ;;AACD9C,MAAAA,QAAQ,CAACC,UAAT,GAAsBkD,YAAtB;AACH,KATD,MAUK;AACD,UAAIE,GAAG,GAAGtE,QAAQ,CAAC6D,GAAD,EAAM1G,IAAN,EAAY8D,QAAQ,CAAC/B,KAArB,EAA4B+B,QAAQ,CAACE,QAArC,EAA+CF,QAAQ,CAACC,UAAxD,CAAlB;AACAD,MAAAA,QAAQ,CAACC,UAAT,GAAsBoD,GAAG,CAACpD,UAAJ,GAAiBiD,aAAvC;AACAF,MAAAA,WAAW,GAAGK,GAAG,CAACL,WAAlB;AACAD,MAAAA,QAAQ,GAAGM,GAAG,CAACvE,KAAf;AACH;AACJ,GAnBD,MAoBK;AACDiE,IAAAA,QAAQ,GAAGH,GAAG,CAACtG,KAAJ,CAAU,IAAV,CAAX;AACH;;AACD,OAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuG,QAAQ,CAACrG,MAA7B,EAAqCF,CAAC,EAAtC,EAA0C;AACtC,QAAIR,IAAI,GAAG+G,QAAQ,CAACvG,CAAD,CAAnB;AACA,QAAI2E,KAAK,GAAG,IAAI3B,aAAJ,EAAZ;AACA2B,IAAAA,KAAK,CAACE,SAAN,GAAkBA,SAAlB;AACAF,IAAAA,KAAK,CAACnF,IAAN,GAAaA,IAAb;AACAmF,IAAAA,KAAK,CAACmC,YAAN,GAAqB,CAACtH,IAAD,IAAS,CAAC6G,UAA/B;;AACA,QAAI,OAAOzB,UAAU,CAACnD,KAAlB,KAA4B,QAAhC,EAA0C;AACtCkD,MAAAA,KAAK,CAAClD,KAAN,GAAcmD,UAAU,CAACnD,KAAzB;AACH,KAFD,MAGK;AACDkD,MAAAA,KAAK,CAAClD,KAAN,GAAc+E,WAAW,GACnBA,WAAW,CAACxG,CAAD,CADQ,GAEnBX,MAAM,CAACsB,QAAP,CAAgBnB,IAAhB,EAAsBE,IAAtB,CAFN;AAGH;;AACD,QAAI,CAACM,CAAD,IAAM,CAACsG,OAAX,EAAoB;AAChB,UAAIpD,MAAM,GAAG,CAACZ,KAAK,CAACA,KAAK,CAACpC,MAAN,GAAe,CAAhB,CAAL,KAA4BoC,KAAK,CAAC,CAAD,CAAL,GAAW,IAAIW,YAAJ,EAAvC,CAAD,EAA6DC,MAA1E;AACA,UAAI6D,SAAS,GAAG7D,MAAM,CAAChD,MAAvB;AACC6G,MAAAA,SAAS,KAAK,CAAd,IAAmB7D,MAAM,CAAC,CAAD,CAAN,CAAU4D,YAA9B,GACO5D,MAAM,CAAC,CAAD,CAAN,GAAYyB,KADnB,GAEO,CAACnF,IAAI,IAAI,CAACuH,SAAT,IAAsBV,UAAvB,KAAsCnD,MAAM,CAACwC,IAAP,CAAYf,KAAZ,CAF7C;AAGH,KAND,MAOK;AACDrC,MAAAA,KAAK,CAACoD,IAAN,CAAW,IAAIzC,YAAJ,CAAiB,CAAC0B,KAAD,CAAjB,CAAX;AACH;AACJ;AACJ;;AACD,SAASqC,OAAT,CAAiBC,EAAjB,EAAqB;AACjB,MAAIC,IAAI,GAAGD,EAAE,CAACtF,UAAH,CAAc,CAAd,CAAX;AACA,SAAOuF,IAAI,IAAI,IAAR,IAAgBA,IAAI,IAAI,IAA/B;AACH;;AACD,IAAIC,YAAY,GAAG/H,MAAM,CAACgI,MAAP,CAAc,UAAUtH,KAAV,CAAgB,EAAhB,CAAd,EAAmC,UAAUuH,GAAV,EAAeJ,EAAf,EAAmB;AACrEI,EAAAA,GAAG,CAACJ,EAAD,CAAH,GAAU,IAAV;AACA,SAAOI,GAAP;AACH,CAHkB,EAGhB,EAHgB,CAAnB;;AAIA,SAASC,eAAT,CAAyBL,EAAzB,EAA6B;AACzB,MAAID,OAAO,CAACC,EAAD,CAAX,EAAiB;AACb,QAAIE,YAAY,CAACF,EAAD,CAAhB,EAAsB;AAClB,aAAO,IAAP;AACH;;AACD,WAAO,KAAP;AACH;;AACD,SAAO,IAAP;AACH;;AACD,SAAS1E,QAAT,CAAkB/C,IAAlB,EAAwBE,IAAxB,EAA8ByB,SAA9B,EAAyCoG,UAAzC,EAAqDC,cAArD,EAAqE;AACjE,MAAIlF,KAAK,GAAG,EAAZ;AACA,MAAIkE,WAAW,GAAG,EAAlB;AACA,MAAI/B,IAAI,GAAG,EAAX;AACA,MAAIgD,WAAW,GAAG,EAAlB;AACA,MAAIC,gBAAgB,GAAG,CAAvB;AACA,MAAIjE,UAAU,GAAG,CAAjB;;AACA,OAAK,IAAIzD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,IAAI,CAACU,MAAzB,EAAiCF,CAAC,EAAlC,EAAsC;AAClC,QAAIiH,EAAE,GAAGzH,IAAI,CAACgG,MAAL,CAAYxF,CAAZ,CAAT;;AACA,QAAIiH,EAAE,KAAK,IAAX,EAAiB;AACb,UAAIQ,WAAJ,EAAiB;AACbhD,QAAAA,IAAI,IAAIgD,WAAR;AACAhE,QAAAA,UAAU,IAAIiE,gBAAd;AACH;;AACDpF,MAAAA,KAAK,CAACoD,IAAN,CAAWjB,IAAX;AACA+B,MAAAA,WAAW,CAACd,IAAZ,CAAiBjC,UAAjB;AACAgB,MAAAA,IAAI,GAAG,EAAP;AACAgD,MAAAA,WAAW,GAAG,EAAd;AACAC,MAAAA,gBAAgB,GAAG,CAAnB;AACAjE,MAAAA,UAAU,GAAG,CAAb;AACA;AACH;;AACD,QAAIkE,OAAO,GAAGtI,MAAM,CAACsB,QAAP,CAAgBsG,EAAhB,EAAoBvH,IAApB,CAAd;AACA,QAAIkI,MAAM,GAAGL,UAAU,GAAG,KAAH,GAAW,CAACD,eAAe,CAACL,EAAD,CAAlD;;AACA,QAAI,CAAC3E,KAAK,CAACpC,MAAP,GACEsH,cAAc,GAAG/D,UAAjB,GAA8BkE,OAA9B,GAAwCxG,SAD1C,GAEEsC,UAAU,GAAGkE,OAAb,GAAuBxG,SAF7B,EAEwC;AACpC,UAAI,CAACsC,UAAL,EAAiB;AACb,YAAImE,MAAJ,EAAY;AACRtF,UAAAA,KAAK,CAACoD,IAAN,CAAW+B,WAAX;AACAjB,UAAAA,WAAW,CAACd,IAAZ,CAAiBgC,gBAAjB;AACAD,UAAAA,WAAW,GAAGR,EAAd;AACAS,UAAAA,gBAAgB,GAAGC,OAAnB;AACH,SALD,MAMK;AACDrF,UAAAA,KAAK,CAACoD,IAAN,CAAWuB,EAAX;AACAT,UAAAA,WAAW,CAACd,IAAZ,CAAiBiC,OAAjB;AACH;AACJ,OAXD,MAYK,IAAIlD,IAAI,IAAIgD,WAAZ,EAAyB;AAC1B,YAAIG,MAAJ,EAAY;AACR,cAAI,CAACnD,IAAL,EAAW;AACPA,YAAAA,IAAI,GAAGgD,WAAP;AACAA,YAAAA,WAAW,GAAG,EAAd;AACAC,YAAAA,gBAAgB,GAAG,CAAnB;AACAjE,YAAAA,UAAU,GAAGiE,gBAAb;AACH;;AACDpF,UAAAA,KAAK,CAACoD,IAAN,CAAWjB,IAAX;AACA+B,UAAAA,WAAW,CAACd,IAAZ,CAAiBjC,UAAU,GAAGiE,gBAA9B;AACAD,UAAAA,WAAW,IAAIR,EAAf;AACAS,UAAAA,gBAAgB,IAAIC,OAApB;AACAlD,UAAAA,IAAI,GAAG,EAAP;AACAhB,UAAAA,UAAU,GAAGiE,gBAAb;AACH,SAbD,MAcK;AACD,cAAID,WAAJ,EAAiB;AACbhD,YAAAA,IAAI,IAAIgD,WAAR;AACAhE,YAAAA,UAAU,IAAIiE,gBAAd;AACAD,YAAAA,WAAW,GAAG,EAAd;AACAC,YAAAA,gBAAgB,GAAG,CAAnB;AACH;;AACDpF,UAAAA,KAAK,CAACoD,IAAN,CAAWjB,IAAX;AACA+B,UAAAA,WAAW,CAACd,IAAZ,CAAiBjC,UAAjB;AACAgB,UAAAA,IAAI,GAAGwC,EAAP;AACAxD,UAAAA,UAAU,GAAGkE,OAAb;AACH;AACJ;;AACD;AACH;;AACDlE,IAAAA,UAAU,IAAIkE,OAAd;;AACA,QAAIC,MAAJ,EAAY;AACRH,MAAAA,WAAW,IAAIR,EAAf;AACAS,MAAAA,gBAAgB,IAAIC,OAApB;AACH,KAHD,MAIK;AACD,UAAIF,WAAJ,EAAiB;AACbhD,QAAAA,IAAI,IAAIgD,WAAR;AACAA,QAAAA,WAAW,GAAG,EAAd;AACAC,QAAAA,gBAAgB,GAAG,CAAnB;AACH;;AACDjD,MAAAA,IAAI,IAAIwC,EAAR;AACH;AACJ;;AACD,MAAI,CAAC3E,KAAK,CAACpC,MAAP,IAAiB,CAACuE,IAAtB,EAA4B;AACxBA,IAAAA,IAAI,GAAGjF,IAAP;AACAiI,IAAAA,WAAW,GAAG,EAAd;AACAC,IAAAA,gBAAgB,GAAG,CAAnB;AACH;;AACD,MAAID,WAAJ,EAAiB;AACbhD,IAAAA,IAAI,IAAIgD,WAAR;AACH;;AACD,MAAIhD,IAAJ,EAAU;AACNnC,IAAAA,KAAK,CAACoD,IAAN,CAAWjB,IAAX;AACA+B,IAAAA,WAAW,CAACd,IAAZ,CAAiBjC,UAAjB;AACH;;AACD,MAAInB,KAAK,CAACpC,MAAN,KAAiB,CAArB,EAAwB;AACpBuD,IAAAA,UAAU,IAAI+D,cAAd;AACH;;AACD,SAAO;AACH/D,IAAAA,UAAU,EAAEA,UADT;AAEHnB,IAAAA,KAAK,EAAEA,KAFJ;AAGHkE,IAAAA,WAAW,EAAEA;AAHV,GAAP;AAKH;;AACD,SAASI,YAAT,CAAsBiB,KAAtB,EAA6BC,QAA7B,EAAuC;AACnC,MAAI,OAAOD,KAAP,KAAiB,QAArB,EAA+B;AAC3B,QAAIA,KAAK,CAACE,WAAN,CAAkB,GAAlB,KAA0B,CAA9B,EAAiC;AAC7B,aAAOC,UAAU,CAACH,KAAD,CAAV,GAAoB,GAApB,GAA0BC,QAAjC;AACH;;AACD,WAAOE,UAAU,CAACH,KAAD,CAAjB;AACH;;AACD,SAAOA,KAAP;AACH","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar imageHelper = require(\"../helper/image\");\nvar util_1 = require(\"../../core/util\");\nvar text_1 = require(\"../../contain/text\");\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n    if (!containerWidth) {\n        return '';\n    }\n    var textLines = (text + '').split('\\n');\n    options = prepareTruncateOptions(containerWidth, font, ellipsis, options);\n    for (var i = 0, len = textLines.length; i < len; i++) {\n        textLines[i] = truncateSingleLine(textLines[i], options);\n    }\n    return textLines.join('\\n');\n}\nexports.truncateText = truncateText;\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n    options = options || {};\n    var preparedOpts = util_1.extend({}, options);\n    preparedOpts.font = font;\n    ellipsis = util_1.retrieve2(ellipsis, '...');\n    preparedOpts.maxIterations = util_1.retrieve2(options.maxIterations, 2);\n    var minChar = preparedOpts.minChar = util_1.retrieve2(options.minChar, 0);\n    preparedOpts.cnCharWidth = text_1.getWidth('国', font);\n    var ascCharWidth = preparedOpts.ascCharWidth = text_1.getWidth('a', font);\n    preparedOpts.placeholder = util_1.retrieve2(options.placeholder, '');\n    var contentWidth = containerWidth = Math.max(0, containerWidth - 1);\n    for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n        contentWidth -= ascCharWidth;\n    }\n    var ellipsisWidth = text_1.getWidth(ellipsis, font);\n    if (ellipsisWidth > contentWidth) {\n        ellipsis = '';\n        ellipsisWidth = 0;\n    }\n    contentWidth = containerWidth - ellipsisWidth;\n    preparedOpts.ellipsis = ellipsis;\n    preparedOpts.ellipsisWidth = ellipsisWidth;\n    preparedOpts.contentWidth = contentWidth;\n    preparedOpts.containerWidth = containerWidth;\n    return preparedOpts;\n}\nfunction truncateSingleLine(textLine, options) {\n    var containerWidth = options.containerWidth;\n    var font = options.font;\n    var contentWidth = options.contentWidth;\n    if (!containerWidth) {\n        return '';\n    }\n    var lineWidth = text_1.getWidth(textLine, font);\n    if (lineWidth <= containerWidth) {\n        return textLine;\n    }\n    for (var j = 0;; j++) {\n        if (lineWidth <= contentWidth || j >= options.maxIterations) {\n            textLine += options.ellipsis;\n            break;\n        }\n        var subLength = j === 0\n            ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)\n            : lineWidth > 0\n                ? Math.floor(textLine.length * contentWidth / lineWidth)\n                : 0;\n        textLine = textLine.substr(0, subLength);\n        lineWidth = text_1.getWidth(textLine, font);\n    }\n    if (textLine === '') {\n        textLine = options.placeholder;\n    }\n    return textLine;\n}\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n    var width = 0;\n    var i = 0;\n    for (var len = text.length; i < len && width < contentWidth; i++) {\n        var charCode = text.charCodeAt(i);\n        width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;\n    }\n    return i;\n}\nfunction parsePlainText(text, style) {\n    text != null && (text += '');\n    var overflow = style.overflow;\n    var padding = style.padding;\n    var font = style.font;\n    var truncate = overflow === 'truncate';\n    var calculatedLineHeight = text_1.getLineHeight(font);\n    var lineHeight = util_1.retrieve2(style.lineHeight, calculatedLineHeight);\n    var truncateLineOverflow = style.lineOverflow === 'truncate';\n    var width = style.width;\n    var lines;\n    if (width != null && overflow === 'break' || overflow === 'breakAll') {\n        lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : [];\n    }\n    else {\n        lines = text ? text.split('\\n') : [];\n    }\n    var contentHeight = lines.length * lineHeight;\n    var height = util_1.retrieve2(style.height, contentHeight);\n    if (contentHeight > height && truncateLineOverflow) {\n        var lineCount = Math.floor(height / lineHeight);\n        lines = lines.slice(0, lineCount);\n    }\n    var outerHeight = height;\n    var outerWidth = width;\n    if (padding) {\n        outerHeight += padding[0] + padding[2];\n        if (outerWidth != null) {\n            outerWidth += padding[1] + padding[3];\n        }\n    }\n    if (text && truncate && outerWidth != null) {\n        var options = prepareTruncateOptions(width, font, style.ellipsis, {\n            minChar: style.truncateMinChar,\n            placeholder: style.placeholder\n        });\n        for (var i = 0; i < lines.length; i++) {\n            lines[i] = truncateSingleLine(lines[i], options);\n        }\n    }\n    if (width == null) {\n        var maxWidth = 0;\n        for (var i = 0; i < lines.length; i++) {\n            maxWidth = Math.max(text_1.getWidth(lines[i], font), maxWidth);\n        }\n        width = maxWidth;\n    }\n    return {\n        lines: lines,\n        height: height,\n        outerHeight: outerHeight,\n        lineHeight: lineHeight,\n        calculatedLineHeight: calculatedLineHeight,\n        contentHeight: contentHeight,\n        width: width\n    };\n}\nexports.parsePlainText = parsePlainText;\nvar RichTextToken = (function () {\n    function RichTextToken() {\n    }\n    return RichTextToken;\n}());\nvar RichTextLine = (function () {\n    function RichTextLine(tokens) {\n        this.tokens = [];\n        if (tokens) {\n            this.tokens = tokens;\n        }\n    }\n    return RichTextLine;\n}());\nvar RichTextContentBlock = (function () {\n    function RichTextContentBlock() {\n        this.width = 0;\n        this.height = 0;\n        this.contentWidth = 0;\n        this.contentHeight = 0;\n        this.outerWidth = 0;\n        this.outerHeight = 0;\n        this.lines = [];\n    }\n    return RichTextContentBlock;\n}());\nexports.RichTextContentBlock = RichTextContentBlock;\nfunction parseRichText(text, style) {\n    var contentBlock = new RichTextContentBlock();\n    text != null && (text += '');\n    if (!text) {\n        return contentBlock;\n    }\n    var topWidth = style.width;\n    var topHeight = style.height;\n    var overflow = style.overflow;\n    var wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null\n        ? { width: topWidth, accumWidth: 0, breakAll: overflow === 'breakAll' }\n        : null;\n    var lastIndex = STYLE_REG.lastIndex = 0;\n    var result;\n    while ((result = STYLE_REG.exec(text)) != null) {\n        var matchedIndex = result.index;\n        if (matchedIndex > lastIndex) {\n            pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo);\n        }\n        pushTokens(contentBlock, result[2], style, wrapInfo, result[1]);\n        lastIndex = STYLE_REG.lastIndex;\n    }\n    if (lastIndex < text.length) {\n        pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo);\n    }\n    var pendingList = [];\n    var calculatedHeight = 0;\n    var calculatedWidth = 0;\n    var stlPadding = style.padding;\n    var truncate = overflow === 'truncate';\n    var truncateLine = style.lineOverflow === 'truncate';\n    var prevToken;\n    function finishLine(line, lineWidth, lineHeight) {\n        line.width = lineWidth;\n        line.lineHeight = lineHeight;\n        calculatedHeight += lineHeight;\n        calculatedWidth = Math.max(calculatedWidth, lineWidth);\n    }\n    outer: for (var i = 0; i < contentBlock.lines.length; i++) {\n        var line = contentBlock.lines[i];\n        var lineHeight = 0;\n        var lineWidth = 0;\n        for (var j = 0; j < line.tokens.length; j++) {\n            var token = line.tokens[j];\n            var tokenStyle = token.styleName && style.rich[token.styleName] || {};\n            var textPadding = token.textPadding = tokenStyle.padding;\n            var paddingH = textPadding ? textPadding[1] + textPadding[3] : 0;\n            var font = token.font = tokenStyle.font || style.font;\n            token.contentHeight = text_1.getLineHeight(font);\n            var tokenHeight = util_1.retrieve2(tokenStyle.height, token.contentHeight);\n            token.innerHeight = tokenHeight;\n            textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n            token.height = tokenHeight;\n            token.lineHeight = util_1.retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight);\n            token.align = tokenStyle && tokenStyle.align || style.align;\n            token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle';\n            if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {\n                if (j > 0) {\n                    line.tokens = line.tokens.slice(0, j);\n                    finishLine(line, lineWidth, lineHeight);\n                    contentBlock.lines = contentBlock.lines.slice(0, i + 1);\n                }\n                else {\n                    contentBlock.lines = contentBlock.lines.slice(0, i);\n                }\n                break outer;\n            }\n            var styleTokenWidth = tokenStyle.width;\n            var tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto';\n            if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {\n                token.percentWidth = styleTokenWidth;\n                pendingList.push(token);\n                token.contentWidth = text_1.getWidth(token.text, font);\n            }\n            else {\n                if (tokenWidthNotSpecified) {\n                    var textBackgroundColor = tokenStyle.backgroundColor;\n                    var bgImg = textBackgroundColor && textBackgroundColor.image;\n                    if (bgImg) {\n                        bgImg = imageHelper.findExistImage(bgImg);\n                        if (imageHelper.isImageReady(bgImg)) {\n                            token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height);\n                        }\n                    }\n                }\n                var remainTruncWidth = truncate && topWidth != null\n                    ? topWidth - lineWidth : null;\n                if (remainTruncWidth != null && remainTruncWidth < token.width) {\n                    if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {\n                        token.text = '';\n                        token.width = token.contentWidth = 0;\n                    }\n                    else {\n                        token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar });\n                        token.width = token.contentWidth = text_1.getWidth(token.text, font);\n                    }\n                }\n                else {\n                    token.contentWidth = text_1.getWidth(token.text, font);\n                }\n            }\n            token.width += paddingH;\n            lineWidth += token.width;\n            tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n            prevToken = token;\n        }\n        finishLine(line, lineWidth, lineHeight);\n    }\n    contentBlock.outerWidth = contentBlock.width = util_1.retrieve2(topWidth, calculatedWidth);\n    contentBlock.outerHeight = contentBlock.height = util_1.retrieve2(topHeight, calculatedHeight);\n    contentBlock.contentHeight = calculatedHeight;\n    contentBlock.contentWidth = calculatedWidth;\n    if (stlPadding) {\n        contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n        contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n    }\n    for (var i = 0; i < pendingList.length; i++) {\n        var token = pendingList[i];\n        var percentWidth = token.percentWidth;\n        token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width;\n    }\n    return contentBlock;\n}\nexports.parseRichText = parseRichText;\nfunction pushTokens(block, str, style, wrapInfo, styleName) {\n    var isEmptyStr = str === '';\n    var tokenStyle = styleName && style.rich[styleName] || {};\n    var lines = block.lines;\n    var font = tokenStyle.font || style.font;\n    var newLine = false;\n    var strLines;\n    var linesWidths;\n    if (wrapInfo) {\n        var tokenPadding = tokenStyle.padding;\n        var tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0;\n        if (tokenStyle.width != null && tokenStyle.width !== 'auto') {\n            var outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH;\n            if (lines.length > 0) {\n                if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {\n                    strLines = str.split('\\n');\n                    newLine = true;\n                }\n            }\n            wrapInfo.accumWidth = outerWidth_1;\n        }\n        else {\n            var res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth);\n            wrapInfo.accumWidth = res.accumWidth + tokenPaddingH;\n            linesWidths = res.linesWidths;\n            strLines = res.lines;\n        }\n    }\n    else {\n        strLines = str.split('\\n');\n    }\n    for (var i = 0; i < strLines.length; i++) {\n        var text = strLines[i];\n        var token = new RichTextToken();\n        token.styleName = styleName;\n        token.text = text;\n        token.isLineHolder = !text && !isEmptyStr;\n        if (typeof tokenStyle.width === 'number') {\n            token.width = tokenStyle.width;\n        }\n        else {\n            token.width = linesWidths\n                ? linesWidths[i]\n                : text_1.getWidth(text, font);\n        }\n        if (!i && !newLine) {\n            var tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens;\n            var tokensLen = tokens.length;\n            (tokensLen === 1 && tokens[0].isLineHolder)\n                ? (tokens[0] = token)\n                : ((text || !tokensLen || isEmptyStr) && tokens.push(token));\n        }\n        else {\n            lines.push(new RichTextLine([token]));\n        }\n    }\n}\nfunction isLatin(ch) {\n    var code = ch.charCodeAt(0);\n    return code >= 0x21 && code <= 0xFF;\n}\nvar breakCharMap = util_1.reduce(',&?/;] '.split(''), function (obj, ch) {\n    obj[ch] = true;\n    return obj;\n}, {});\nfunction isWordBreakChar(ch) {\n    if (isLatin(ch)) {\n        if (breakCharMap[ch]) {\n            return true;\n        }\n        return false;\n    }\n    return true;\n}\nfunction wrapText(text, font, lineWidth, isBreakAll, lastAccumWidth) {\n    var lines = [];\n    var linesWidths = [];\n    var line = '';\n    var currentWord = '';\n    var currentWordWidth = 0;\n    var accumWidth = 0;\n    for (var i = 0; i < text.length; i++) {\n        var ch = text.charAt(i);\n        if (ch === '\\n') {\n            if (currentWord) {\n                line += currentWord;\n                accumWidth += currentWordWidth;\n            }\n            lines.push(line);\n            linesWidths.push(accumWidth);\n            line = '';\n            currentWord = '';\n            currentWordWidth = 0;\n            accumWidth = 0;\n            continue;\n        }\n        var chWidth = text_1.getWidth(ch, font);\n        var inWord = isBreakAll ? false : !isWordBreakChar(ch);\n        if (!lines.length\n            ? lastAccumWidth + accumWidth + chWidth > lineWidth\n            : accumWidth + chWidth > lineWidth) {\n            if (!accumWidth) {\n                if (inWord) {\n                    lines.push(currentWord);\n                    linesWidths.push(currentWordWidth);\n                    currentWord = ch;\n                    currentWordWidth = chWidth;\n                }\n                else {\n                    lines.push(ch);\n                    linesWidths.push(chWidth);\n                }\n            }\n            else if (line || currentWord) {\n                if (inWord) {\n                    if (!line) {\n                        line = currentWord;\n                        currentWord = '';\n                        currentWordWidth = 0;\n                        accumWidth = currentWordWidth;\n                    }\n                    lines.push(line);\n                    linesWidths.push(accumWidth - currentWordWidth);\n                    currentWord += ch;\n                    currentWordWidth += chWidth;\n                    line = '';\n                    accumWidth = currentWordWidth;\n                }\n                else {\n                    if (currentWord) {\n                        line += currentWord;\n                        accumWidth += currentWordWidth;\n                        currentWord = '';\n                        currentWordWidth = 0;\n                    }\n                    lines.push(line);\n                    linesWidths.push(accumWidth);\n                    line = ch;\n                    accumWidth = chWidth;\n                }\n            }\n            continue;\n        }\n        accumWidth += chWidth;\n        if (inWord) {\n            currentWord += ch;\n            currentWordWidth += chWidth;\n        }\n        else {\n            if (currentWord) {\n                line += currentWord;\n                currentWord = '';\n                currentWordWidth = 0;\n            }\n            line += ch;\n        }\n    }\n    if (!lines.length && !line) {\n        line = text;\n        currentWord = '';\n        currentWordWidth = 0;\n    }\n    if (currentWord) {\n        line += currentWord;\n    }\n    if (line) {\n        lines.push(line);\n        linesWidths.push(accumWidth);\n    }\n    if (lines.length === 1) {\n        accumWidth += lastAccumWidth;\n    }\n    return {\n        accumWidth: accumWidth,\n        lines: lines,\n        linesWidths: linesWidths\n    };\n}\nfunction parsePercent(value, maxValue) {\n    if (typeof value === 'string') {\n        if (value.lastIndexOf('%') >= 0) {\n            return parseFloat(value) / 100 * maxValue;\n        }\n        return parseFloat(value);\n    }\n    return value;\n}\n"]},"metadata":{},"sourceType":"script"}