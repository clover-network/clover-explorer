{"ast":null,"code":"function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nimport deepMix from '@antv/util/lib/deep-mix';\nimport { getLineIntersect } from '../../util/math';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  // console.warn('fallbackRoute: simple polyline path');\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: 90,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: 45,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.floor(pos / gridSize);\n  return gridIx < 0 ? 0 : gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (item) {\n      var bbox = getExpandedBBox(item.getBBox(), offset);\n\n      for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n        for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n          var gridKey = x + \"-\" + y;\n          map[gridKey] = true;\n        }\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n  if (!deltaX && !deltaY) return 0;\n  var angle = (360 + Math.atan2(deltaY, deltaX) * 180 / Math.PI) % 360;\n  return angle;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, node, cfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return points;\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var expandBBox = getExpandedBBox(node.getBBox(), offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  var isInside = point.x > pos2GridIx(bbox.minX, cfg.gridSize) && point.x < pos2GridIx(bbox.maxX, cfg.gridSize) && point.y > pos2GridIx(bbox.minY, cfg.gridSize) && point.y < pos2GridIx(bbox.maxY, cfg.gridSize);\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP = getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP && !isSegmentCrossingBBox(point, insterctP, node.getBBox())) {\n          insterctP.id = insterctP.x + \"-\" + insterctP.y;\n          points.push(insterctP);\n        }\n      }\n    }\n  } else {\n    // 如果 anchorPoint 在节点上，只有一个可选方向\n    var insterctP = getExpandedBBoxPoint(expandBBox, point);\n    insterctP.id = insterctP.x + \"-\" + insterctP.y;\n    points.push(insterctP);\n  }\n\n  return points;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), cfg.gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, cfg.gridSize),\n    y: pos2GridIx(startPoint.y, cfg.gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, cfg.gridSize),\n    y: pos2GridIx(endPoint.y, cfg.gridSize)\n  };\n  startPoint.id = scaleStartPoint.x + \"-\" + scaleStartPoint.y;\n  endPoint.id = scaleEndPoint.x + \"-\" + scaleEndPoint.y;\n  var startPoints = getBoxPoints(scaleStartPoint, startNode, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endNode, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var getDirectionChange = function getDirectionChange(current, neighbor) {\n    var directionAngle = getDirectionAngle(current, neighbor);\n    var directionChange;\n\n    if (!cameFrom[current.id]) {\n      var startAngle = getDirectionAngle(scaleStartPoint, current);\n      directionChange = getAngleDiff(startAngle, directionAngle);\n    } else {\n      var prevDirectionAngle = getDirectionAngle({\n        x: parseFloat(cameFrom[current.id].split('-')[0]),\n        y: parseFloat(cameFrom[current.id].split('-')[1])\n      }, current);\n      directionChange = getAngleDiff(prevDirectionAngle, directionAngle);\n    }\n\n    return directionChange;\n  };\n\n  var getControlPoints = function getControlPoints(currentId) {\n    var controlPoints = [endPoint];\n    var lastPoint = {\n      x: parseFloat(currentId.split('-')[0]),\n      y: parseFloat(currentId.split('-')[1]),\n      id: currentId\n    };\n\n    if (getDirectionChange(lastPoint, scaleEndPoint)) {\n      controlPoints.unshift({\n        x: lastPoint.x === scaleEndPoint.x ? endPoint.x : lastPoint.x * cfg.gridSize,\n        y: lastPoint.y === scaleEndPoint.y ? endPoint.y : lastPoint.y * cfg.gridSize\n      });\n    }\n\n    while (cameFrom[currentId] && cameFrom[currentId] !== currentId) {\n      var point = {\n        x: parseFloat(currentId.split('-')[0]),\n        y: parseFloat(currentId.split('-')[1]),\n        id: currentId\n      };\n      var preId = cameFrom[currentId];\n      var prePoint = {\n        x: parseFloat(preId.split('-')[0]),\n        y: parseFloat(preId.split('-')[1]),\n        id: preId\n      };\n      var directionChange = getDirectionChange(prePoint, point);\n\n      if (directionChange) {\n        controlPoints.unshift({\n          x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * cfg.gridSize,\n          y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * cfg.gridSize\n        });\n      }\n\n      currentId = preId;\n    } // 和startNode对齐\n\n\n    var firstPoint = {\n      x: parseFloat(currentId.split('-')[0]),\n      y: parseFloat(currentId.split('-')[1]),\n      id: currentId\n    };\n    controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n    controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n    controlPoints.unshift(startPoint);\n    return controlPoints;\n  };\n\n  var remainLoops = cfg.maximumLoops;\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    for (var id in openSet) {\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    }\n\n    if (!current) return \"break\"; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      var controlPoints = getControlPoints(current.id);\n      return {\n        value: controlPoints\n      };\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      var direction = cfg.directions[i];\n      var neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: current.x + direction.stepX + \"-\" + (current.y + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      var directionChange = getDirectionChange(current, neighbor);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      var neighborCost = cfg.distFunc(current, neighbor) + (isNaN(cfg.penalties[directionChange]) ? cfg.gridSize : cfg.penalties[directionChange]);\n      var costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  };\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n    if (state_1 === \"break\") break;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/shape/edges/router.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","deepMix","getLineIntersect","getExpandedBBox","getExpandedBBoxPoint","getPolylinePoints","simplifyPolyline","isSegmentCrossingBBox","manhattanDist","p1","p2","Math","abs","x","y","eucliDist","sqrt","pow","straightPath","start","end","simplePolyline","startNode","endNode","cfg","offset","defaultCfg","maxAllowedDirectionChange","maximumLoops","gridSize","directions","stepX","stepY","penalties","distFunc","fallbackRoute","octolinearCfg","pos2GridIx","pos","gridIx","floor","getObstacleMap","items","map","forEach","item","bbox","getBBox","minX","maxX","minY","maxY","gridKey","getDirectionAngle","deltaX","deltaY","angle","atan2","PI","getAngleDiff","angle1","angle2","directionChange","estimateCost","from","endPoints","min","Infinity","i","len","length","cost","getBoxPoints","point","node","points","expandBBox","isInside","_i","directions_1","dir","bounds","boundLine","insterctP","width","height","id","push","pathFinder","startPoint","endPoint","routerCfg","obstacles","concat","scaleStartPoint","scaleEndPoint","startPoints","openSet","closedSet","cameFrom","gScore","fScore","firstStep","getDirectionChange","current","neighbor","directionAngle","startAngle","prevDirectionAngle","parseFloat","split","getControlPoints","currentId","controlPoints","lastPoint","unshift","preId","prePoint","firstPoint","remainLoops","_loop_1","curCost","findIndex","value","direction","neighborCost","isNaN","costFromStart","Object","keys","state_1"],"mappings":"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","sourcesContent":["function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport deepMix from '@antv/util/lib/deep-mix';\nimport { getLineIntersect } from '../../util/math';\nimport { getExpandedBBox, getExpandedBBoxPoint, getPolylinePoints, simplifyPolyline, isSegmentCrossingBBox } from './polyline-util';\n\nvar manhattanDist = function manhattanDist(p1, p2) {\n  return Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);\n};\n\nvar eucliDist = function eucliDist(p1, p2) {\n  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n};\n\nvar straightPath = function straightPath(start, end) {\n  // console.warn('fallbackRoute: straight path');\n  return [start, end];\n};\n\nvar simplePolyline = function simplePolyline(start, end, startNode, endNode, cfg) {\n  // console.warn('fallbackRoute: simple polyline path');\n  return simplifyPolyline(getPolylinePoints(start, end, startNode, endNode, cfg.offset));\n}; // getPolylinePoints\n\n\nvar defaultCfg = {\n  offset: 20,\n  maxAllowedDirectionChange: 90,\n  maximumLoops: 2000,\n  gridSize: 10,\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }],\n\n  get penalties() {\n    return {\n      0: 0,\n      45: this.gridSize / 2,\n      90: this.gridSize / 2\n    };\n  },\n\n  distFunc: manhattanDist,\n  fallbackRoute: simplePolyline\n};\nexport var octolinearCfg = {\n  maxAllowedDirectionChange: 45,\n  // 8 个方向: 上下左右 + 45度斜线方向\n  directions: [{\n    stepX: 1,\n    stepY: 0\n  }, {\n    stepX: 1,\n    stepY: 1\n  }, {\n    stepX: 0,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 1\n  }, {\n    stepX: -1,\n    stepY: 0\n  }, {\n    stepX: -1,\n    stepY: -1\n  }, {\n    stepX: 0,\n    stepY: -1\n  }, {\n    stepX: 1,\n    stepY: -1\n  }],\n  distFunc: eucliDist,\n  fallbackRoute: straightPath\n};\n\nvar pos2GridIx = function pos2GridIx(pos, gridSize) {\n  var gridIx = Math.floor(pos / gridSize);\n  return gridIx < 0 ? 0 : gridIx;\n};\n\nvar getObstacleMap = function getObstacleMap(items, gridSize, offset) {\n  var map = {};\n  items.forEach(function (item) {\n    // create-edge 时，当边类型为 polyline 时 endNode 为 null\n    if (item) {\n      var bbox = getExpandedBBox(item.getBBox(), offset);\n\n      for (var x = pos2GridIx(bbox.minX, gridSize); x <= pos2GridIx(bbox.maxX, gridSize); x += 1) {\n        for (var y = pos2GridIx(bbox.minY, gridSize); y <= pos2GridIx(bbox.maxY, gridSize); y += 1) {\n          var gridKey = x + \"-\" + y;\n          map[gridKey] = true;\n        }\n      }\n    }\n  });\n  return map;\n};\n/**\n * 方向角：计算从 p1 到 p2 的射线与水平线形成的夹角度数（顺时针从右侧0°转到该射线的角度）\n * @param p1 PolyPoint\n * @param p2 PolyPoint\n */\n\n\nvar getDirectionAngle = function getDirectionAngle(p1, p2) {\n  var deltaX = p2.x - p1.x;\n  var deltaY = p2.y - p1.y;\n  if (!deltaX && !deltaY) return 0;\n  var angle = (360 + Math.atan2(deltaY, deltaX) * 180 / Math.PI) % 360;\n  return angle;\n};\n/**\n * 方向角的改变，取小于180度角\n * @param angle1\n * @param angle2\n */\n\n\nvar getAngleDiff = function getAngleDiff(angle1, angle2) {\n  var directionChange = Math.abs(angle1 - angle2);\n  return directionChange > 180 ? 360 - directionChange : directionChange;\n}; // Path finder //\n\n\nvar estimateCost = function estimateCost(from, endPoints, distFunc) {\n  var min = Infinity;\n\n  for (var i = 0, len = endPoints.length; i < len; i++) {\n    var cost = distFunc(from, endPoints[i]);\n\n    if (cost < min) {\n      min = cost;\n    }\n  }\n\n  return min;\n}; // 计算考虑 offset 后的 BBox 上的连接点\n\n\nvar getBoxPoints = function getBoxPoints(point, node, cfg) {\n  var points = []; // create-edge 生成边的过程中，endNode 为 null\n\n  if (!node) {\n    return points;\n  }\n\n  var directions = cfg.directions,\n      offset = cfg.offset;\n  var bbox = node.getBBox();\n  var expandBBox = getExpandedBBox(node.getBBox(), offset);\n\n  for (var i in expandBBox) {\n    expandBBox[i] = pos2GridIx(expandBBox[i], cfg.gridSize);\n  }\n\n  var isInside = point.x > pos2GridIx(bbox.minX, cfg.gridSize) && point.x < pos2GridIx(bbox.maxX, cfg.gridSize) && point.y > pos2GridIx(bbox.minY, cfg.gridSize) && point.y < pos2GridIx(bbox.maxY, cfg.gridSize);\n\n  if (isInside) {\n    // 如果 anchorPoint 在节点内部，允许第一段线穿过节点\n    for (var _i = 0, directions_1 = directions; _i < directions_1.length; _i++) {\n      var dir = directions_1[_i];\n      var bounds = [[{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.maxX,\n        y: expandBBox.minY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }], [{\n        x: expandBBox.minX,\n        y: expandBBox.maxY\n      }, {\n        x: expandBBox.maxX,\n        y: expandBBox.maxY\n      }]];\n\n      for (var i = 0; i < 4; i++) {\n        var boundLine = bounds[i];\n        var insterctP = getLineIntersect(point, {\n          x: point.x + dir.stepX * expandBBox.width,\n          y: point.y + dir.stepY * expandBBox.height\n        }, boundLine[0], boundLine[1]);\n\n        if (insterctP && !isSegmentCrossingBBox(point, insterctP, node.getBBox())) {\n          insterctP.id = insterctP.x + \"-\" + insterctP.y;\n          points.push(insterctP);\n        }\n      }\n    }\n  } else {\n    // 如果 anchorPoint 在节点上，只有一个可选方向\n    var insterctP = getExpandedBBoxPoint(expandBBox, point);\n    insterctP.id = insterctP.x + \"-\" + insterctP.y;\n    points.push(insterctP);\n  }\n\n  return points;\n};\n\nexport var pathFinder = function pathFinder(startPoint, endPoint, startNode, endNode, routerCfg) {\n  var cfg = deepMix(defaultCfg, routerCfg);\n  cfg.obstacles = cfg.obstacles || [];\n  var map = getObstacleMap(cfg.obstacles.concat([startNode, endNode]), cfg.gridSize, cfg.offset);\n  var scaleStartPoint = {\n    x: pos2GridIx(startPoint.x, cfg.gridSize),\n    y: pos2GridIx(startPoint.y, cfg.gridSize)\n  };\n  var scaleEndPoint = {\n    x: pos2GridIx(endPoint.x, cfg.gridSize),\n    y: pos2GridIx(endPoint.y, cfg.gridSize)\n  };\n  startPoint.id = scaleStartPoint.x + \"-\" + scaleStartPoint.y;\n  endPoint.id = scaleEndPoint.x + \"-\" + scaleEndPoint.y;\n  var startPoints = getBoxPoints(scaleStartPoint, startNode, cfg);\n  var endPoints = getBoxPoints(scaleEndPoint, endNode, cfg);\n  startPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  endPoints.forEach(function (point) {\n    delete map[point.id];\n  });\n  var openSet = {};\n  var closedSet = {};\n  var cameFrom = {}; // 从起点到当前点已产生的 cost, default: Infinity\n\n  var gScore = {}; // 起点经过当前点到达终点预估的 cost, default: Infinity\n\n  var fScore = {}; // initialize\n\n  for (var i = 0; i < startPoints.length; i++) {\n    var firstStep = startPoints[i];\n    openSet[firstStep.id] = firstStep; // cameFrom[firstStep.id] = startPoint.id;\n\n    gScore[firstStep.id] = 0;\n    fScore[firstStep.id] = estimateCost(firstStep, endPoints, cfg.distFunc);\n  }\n\n  var getDirectionChange = function getDirectionChange(current, neighbor) {\n    var directionAngle = getDirectionAngle(current, neighbor);\n    var directionChange;\n\n    if (!cameFrom[current.id]) {\n      var startAngle = getDirectionAngle(scaleStartPoint, current);\n      directionChange = getAngleDiff(startAngle, directionAngle);\n    } else {\n      var prevDirectionAngle = getDirectionAngle({\n        x: parseFloat(cameFrom[current.id].split('-')[0]),\n        y: parseFloat(cameFrom[current.id].split('-')[1])\n      }, current);\n      directionChange = getAngleDiff(prevDirectionAngle, directionAngle);\n    }\n\n    return directionChange;\n  };\n\n  var getControlPoints = function getControlPoints(currentId) {\n    var controlPoints = [endPoint];\n    var lastPoint = {\n      x: parseFloat(currentId.split('-')[0]),\n      y: parseFloat(currentId.split('-')[1]),\n      id: currentId\n    };\n\n    if (getDirectionChange(lastPoint, scaleEndPoint)) {\n      controlPoints.unshift({\n        x: lastPoint.x === scaleEndPoint.x ? endPoint.x : lastPoint.x * cfg.gridSize,\n        y: lastPoint.y === scaleEndPoint.y ? endPoint.y : lastPoint.y * cfg.gridSize\n      });\n    }\n\n    while (cameFrom[currentId] && cameFrom[currentId] !== currentId) {\n      var point = {\n        x: parseFloat(currentId.split('-')[0]),\n        y: parseFloat(currentId.split('-')[1]),\n        id: currentId\n      };\n      var preId = cameFrom[currentId];\n      var prePoint = {\n        x: parseFloat(preId.split('-')[0]),\n        y: parseFloat(preId.split('-')[1]),\n        id: preId\n      };\n      var directionChange = getDirectionChange(prePoint, point);\n\n      if (directionChange) {\n        controlPoints.unshift({\n          x: prePoint.x === point.x ? controlPoints[0].x : prePoint.x * cfg.gridSize,\n          y: prePoint.y === point.y ? controlPoints[0].y : prePoint.y * cfg.gridSize\n        });\n      }\n\n      currentId = preId;\n    } // 和startNode对齐\n\n\n    var firstPoint = {\n      x: parseFloat(currentId.split('-')[0]),\n      y: parseFloat(currentId.split('-')[1]),\n      id: currentId\n    };\n    controlPoints[0].x = firstPoint.x === scaleStartPoint.x ? startPoint.x : controlPoints[0].x;\n    controlPoints[0].y = firstPoint.y === scaleStartPoint.y ? startPoint.y : controlPoints[0].y;\n    controlPoints.unshift(startPoint);\n    return controlPoints;\n  };\n\n  var remainLoops = cfg.maximumLoops;\n\n  var _loop_1 = function _loop_1() {\n    var current;\n    var curCost = Infinity; // 找到 openSet 中 fScore 最小的点\n\n    for (var id in openSet) {\n      if (fScore[id] <= curCost) {\n        curCost = fScore[id];\n        current = openSet[id];\n      }\n    }\n\n    if (!current) return \"break\"; // 如果 fScore 最小的点就是终点\n\n    if (endPoints.findIndex(function (point) {\n      return point.x === current.x && point.y === current.y;\n    }) > -1) {\n      var controlPoints = getControlPoints(current.id);\n      return {\n        value: controlPoints\n      };\n    }\n\n    delete openSet[current.id];\n    closedSet[current.id] = true; // 获取符合条件的下一步的候选连接点\n    // 沿候选方向走一步\n\n    for (var i = 0; i < cfg.directions.length; i++) {\n      var direction = cfg.directions[i];\n      var neighbor = {\n        x: current.x + direction.stepX,\n        y: current.y + direction.stepY,\n        id: current.x + direction.stepX + \"-\" + (current.y + direction.stepY)\n      };\n      if (closedSet[neighbor.id]) continue;\n      var directionChange = getDirectionChange(current, neighbor);\n      if (directionChange > cfg.maxAllowedDirectionChange) continue;\n      if (map[neighbor.id]) continue; // 如果交叉则跳过\n      // 将候选点加入 openSet, 并计算每个候选点的 cost\n\n      if (!openSet[neighbor.id]) {\n        openSet[neighbor.id] = neighbor;\n      }\n\n      var neighborCost = cfg.distFunc(current, neighbor) + (isNaN(cfg.penalties[directionChange]) ? cfg.gridSize : cfg.penalties[directionChange]);\n      var costFromStart = gScore[current.id] + neighborCost;\n\n      if (gScore[neighbor.id] && costFromStart >= gScore[neighbor.id]) {\n        continue;\n      }\n\n      cameFrom[neighbor.id] = current.id;\n      gScore[neighbor.id] = costFromStart;\n      fScore[neighbor.id] = costFromStart + estimateCost(neighbor, endPoints, cfg.distFunc);\n    }\n\n    remainLoops -= 1;\n  };\n\n  while (Object.keys(openSet).length > 0 && remainLoops > 0) {\n    var state_1 = _loop_1();\n\n    if (_typeof(state_1) === \"object\") return state_1.value;\n    if (state_1 === \"break\") break;\n  }\n\n  return cfg.fallbackRoute(startPoint, endPoint, startNode, endNode, cfg);\n};"]},"metadata":{},"sourceType":"module"}