{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types';\nimport { normalizeToArray } from '../../util/model';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, isArrayLike, extend, isArray } from 'zrender/esm/core/util';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider';\nimport { parseDataValue } from './dataValueHelper';\nimport { inheritSourceMetaRawOption } from './sourceHelper';\nimport { consoleLog, makePrintable, throwError } from '../../util/log';\nimport { createSource } from '../Source';\n\nvar ExternalSource = function () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexport { ExternalSource };\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n\n      if (name != null) {\n        var errMsg = '';\n\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          throwError(errMsg);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex];\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || !data || isArray(data) && !data.length) {\n    return upstream.data;\n  }\n\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n  }\n\n  throwError(errMsg);\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!data) {\n    return data;\n  } else if (isArray(data) && !data.length) {\n    return [];\n  } else if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n\n  if (typeof dim === 'number' || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\n\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    throwError(errMsg);\n  }\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    throwError(errMsg);\n  }\n\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    throwError(errMsg);\n  }\n\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      consoleLog(printStrArr);\n    }\n  }\n\n  return map(resultList, function (result) {\n    var errMsg = '';\n\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      throwError(errMsg);\n    }\n\n    var resultData = result.data;\n\n    if (resultData != null) {\n      if (!isObject(resultData) && !isArrayLike(resultData)) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Result data should be object or array in data transform.';\n        }\n\n        throwError(errMsg);\n      }\n    } else {\n      resultData = upSourceList[0].data;\n    }\n\n    var resultMetaRawOption = inheritSourceMetaRawOption(upSourceList[0], {\n      seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n      sourceHeader: 0,\n      dimensions: result.dimensions\n    });\n    return createSource(resultData, resultMetaRawOption, null, null);\n  });\n}","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/esm/data/helper/transform.js"],"names":["SERIES_LAYOUT_BY_COLUMN","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_ARRAY_ROWS","normalizeToArray","createHashMap","bind","each","hasOwn","map","clone","isObject","isArrayLike","extend","isArray","getRawSourceItemGetter","getRawSourceDataCounter","getRawSourceValueGetter","parseDataValue","inheritSourceMetaRawOption","consoleLog","makePrintable","throwError","createSource","ExternalSource","prototype","getRawData","Error","getRawDataItem","dataIndex","cloneRawData","getDimensionInfo","dim","cloneAllDimensionInfo","count","retrieveValue","dimIndex","retrieveValueFromItem","dataItem","convertValue","rawVal","dimInfo","createExternalSource","internalSource","externalTransform","extSource","data","sourceFormat","sourceHeaderCount","startIndex","dimensions","dimsByName","dimsDef","dimensionsDefine","dimDef","idx","name","dimDefExt","index","displayName","push","errMsg","process","env","NODE_ENV","i","dimensionsDetectedCount","rawItemGetter","__isBuiltIn","rawCounter","rawValueGetter","rawItem","upstream","length","result","len","slice","isNaN","externalTransformMap","registerExternalTransform","type","typeParsed","split","isBuiltIn","set","applyDataTransform","rawTransOption","sourceList","infoForPrint","pipedTransOption","pipeLen","transOption","applySingleDataTransform","Math","max","upSourceList","pipeIndex","transType","get","extUpSourceList","upSource","resultList","transform","upstreamList","config","print","printStrArr","pipeIndexStr","datasetIndex","join","resultData","resultMetaRawOption","seriesLayoutBy","sourceHeader"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nimport { SERIES_LAYOUT_BY_COLUMN, SOURCE_FORMAT_OBJECT_ROWS, SOURCE_FORMAT_ARRAY_ROWS } from '../../util/types';\nimport { normalizeToArray } from '../../util/model';\nimport { createHashMap, bind, each, hasOwn, map, clone, isObject, isArrayLike, extend, isArray } from 'zrender/esm/core/util';\nimport { getRawSourceItemGetter, getRawSourceDataCounter, getRawSourceValueGetter } from './dataProvider';\nimport { parseDataValue } from './dataValueHelper';\nimport { inheritSourceMetaRawOption } from './sourceHelper';\nimport { consoleLog, makePrintable, throwError } from '../../util/log';\nimport { createSource } from '../Source';\n\nvar ExternalSource = function () {\n  function ExternalSource() {}\n\n  ExternalSource.prototype.getRawData = function () {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.getRawDataItem = function (dataIndex) {\n    throw new Error('not supported');\n  };\n\n  ExternalSource.prototype.cloneRawData = function () {\n    return;\n  };\n\n  ExternalSource.prototype.getDimensionInfo = function (dim) {\n    return;\n  };\n\n  ExternalSource.prototype.cloneAllDimensionInfo = function () {\n    return;\n  };\n\n  ExternalSource.prototype.count = function () {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {\n    return;\n  };\n\n  ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {\n    return parseDataValue(rawVal, dimInfo);\n  };\n\n  return ExternalSource;\n}();\n\nexport { ExternalSource };\n\nfunction createExternalSource(internalSource, externalTransform) {\n  var extSource = new ExternalSource();\n  var data = internalSource.data;\n  var sourceFormat = extSource.sourceFormat = internalSource.sourceFormat;\n  var sourceHeaderCount = internalSource.startIndex;\n  var dimensions = [];\n  var dimsByName = {};\n  var dimsDef = internalSource.dimensionsDefine;\n\n  if (dimsDef) {\n    each(dimsDef, function (dimDef, idx) {\n      var name = dimDef.name;\n      var dimDefExt = {\n        index: idx,\n        name: name,\n        displayName: dimDef.displayName\n      };\n      dimensions.push(dimDefExt);\n\n      if (name != null) {\n        var errMsg = '';\n\n        if (hasOwn(dimsByName, name)) {\n          if (process.env.NODE_ENV !== 'production') {\n            errMsg = 'dimension name \"' + name + '\" duplicated.';\n          }\n\n          throwError(errMsg);\n        }\n\n        dimsByName[name] = dimDefExt;\n      }\n    });\n  } else {\n    for (var i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {\n      dimensions.push({\n        index: i\n      });\n    }\n  }\n\n  var rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n\n  if (externalTransform.__isBuiltIn) {\n    extSource.getRawDataItem = function (dataIndex) {\n      return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    };\n\n    extSource.getRawData = bind(getRawData, null, internalSource);\n  }\n\n  extSource.cloneRawData = bind(cloneRawData, null, internalSource);\n  var rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN);\n  extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions);\n  var rawValueGetter = getRawSourceValueGetter(sourceFormat);\n\n  extSource.retrieveValue = function (dataIndex, dimIndex) {\n    var rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex);\n    return retrieveValueFromItem(rawItem, dimIndex);\n  };\n\n  var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {\n    if (dataItem == null) {\n      return;\n    }\n\n    var dimDef = dimensions[dimIndex];\n\n    if (dimDef) {\n      return rawValueGetter(dataItem, dimIndex, dimDef.name);\n    }\n  };\n\n  extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName);\n  extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions);\n  return extSource;\n}\n\nfunction getRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || !data || isArray(data) && !data.length) {\n    return upstream.data;\n  }\n\n  var errMsg = '';\n\n  if (process.env.NODE_ENV !== 'production') {\n    errMsg = '`getRawData` is not supported in source format ' + sourceFormat;\n  }\n\n  throwError(errMsg);\n}\n\nfunction cloneRawData(upstream) {\n  var sourceFormat = upstream.sourceFormat;\n  var data = upstream.data;\n\n  if (!data) {\n    return data;\n  } else if (isArray(data) && !data.length) {\n    return [];\n  } else if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(data[i].slice());\n    }\n\n    return result;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    var result = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      result.push(extend({}, data[i]));\n    }\n\n    return result;\n  }\n}\n\nfunction getDimensionInfo(dimensions, dimsByName, dim) {\n  if (dim == null) {\n    return;\n  }\n\n  if (typeof dim === 'number' || !isNaN(dim) && !hasOwn(dimsByName, dim)) {\n    return dimensions[dim];\n  } else if (hasOwn(dimsByName, dim)) {\n    return dimsByName[dim];\n  }\n}\n\nfunction cloneAllDimensionInfo(dimensions) {\n  return clone(dimensions);\n}\n\nvar externalTransformMap = createHashMap();\nexport function registerExternalTransform(externalTransform) {\n  externalTransform = clone(externalTransform);\n  var type = externalTransform.type;\n  var errMsg = '';\n\n  if (!type) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have a `type` when `registerTransform`.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var typeParsed = type.split(':');\n\n  if (typeParsed.length !== 2) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Name must include namespace like \"ns:regression\".';\n    }\n\n    throwError(errMsg);\n  }\n\n  var isBuiltIn = false;\n\n  if (typeParsed[0] === 'echarts') {\n    type = typeParsed[1];\n    isBuiltIn = true;\n  }\n\n  externalTransform.__isBuiltIn = isBuiltIn;\n  externalTransformMap.set(type, externalTransform);\n}\nexport function applyDataTransform(rawTransOption, sourceList, infoForPrint) {\n  var pipedTransOption = normalizeToArray(rawTransOption);\n  var pipeLen = pipedTransOption.length;\n  var errMsg = '';\n\n  if (!pipeLen) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'If `transform` declared, it should at least contain one transform.';\n    }\n\n    throwError(errMsg);\n  }\n\n  for (var i = 0, len = pipeLen; i < len; i++) {\n    var transOption = pipedTransOption[i];\n    sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i);\n\n    if (i !== len - 1) {\n      sourceList.length = Math.max(sourceList.length, 1);\n    }\n  }\n\n  return sourceList;\n}\n\nfunction applySingleDataTransform(transOption, upSourceList, infoForPrint, pipeIndex) {\n  var errMsg = '';\n\n  if (!upSourceList.length) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Must have at least one upstream dataset.';\n    }\n\n    throwError(errMsg);\n  }\n\n  if (!isObject(transOption)) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.';\n    }\n\n    throwError(errMsg);\n  }\n\n  var transType = transOption.type;\n  var externalTransform = externalTransformMap.get(transType);\n\n  if (!externalTransform) {\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = 'Can not find transform on type \"' + transType + '\".';\n    }\n\n    throwError(errMsg);\n  }\n\n  var extUpSourceList = map(upSourceList, function (upSource) {\n    return createExternalSource(upSource, externalTransform);\n  });\n  var resultList = normalizeToArray(externalTransform.transform({\n    upstream: extUpSourceList[0],\n    upstreamList: extUpSourceList,\n    config: clone(transOption.config)\n  }));\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (transOption.print) {\n      var printStrArr = map(resultList, function (extSource) {\n        var pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : '';\n        return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\\n');\n      }).join('\\n');\n      consoleLog(printStrArr);\n    }\n  }\n\n  return map(resultList, function (result) {\n    var errMsg = '';\n\n    if (!isObject(result)) {\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'A transform should not return some empty results.';\n      }\n\n      throwError(errMsg);\n    }\n\n    var resultData = result.data;\n\n    if (resultData != null) {\n      if (!isObject(resultData) && !isArrayLike(resultData)) {\n        if (process.env.NODE_ENV !== 'production') {\n          errMsg = 'Result data should be object or array in data transform.';\n        }\n\n        throwError(errMsg);\n      }\n    } else {\n      resultData = upSourceList[0].data;\n    }\n\n    var resultMetaRawOption = inheritSourceMetaRawOption(upSourceList[0], {\n      seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,\n      sourceHeader: 0,\n      dimensions: result.dimensions\n    });\n    return createSource(resultData, resultMetaRawOption, null, null);\n  });\n}"]},"metadata":{},"sourceType":"module"}