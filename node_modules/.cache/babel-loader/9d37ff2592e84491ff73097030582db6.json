{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar task_1 = require(\"./task\");\n\nvar component_1 = require(\"../util/component\");\n\nvar Global_1 = require(\"../model/Global\");\n\nvar ExtensionAPI_1 = require(\"../ExtensionAPI\");\n\nvar model_1 = require(\"../util/model\");\n\n;\n\nvar Scheduler = function () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    this._stageTaskMap = util_1.createHashMap();\n    this.ecInstance = ecInstance;\n    this.api = api;\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    ecModel.restoreData(payload);\n\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  };\n\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    if (!task.__pipeline) {\n      return;\n    }\n\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n    var data = seriesModel.getData();\n    var dataLen = data.count();\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = util_1.createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    util_1.each(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n      }\n\n      util_1.assert(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n\n    this._pipe(model, renderTask);\n  };\n\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    util_1.each(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n\n          var performArgs = scheduler.getPerformArgs(task, opt.block);\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.plan = function () {\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || task_1.createTask({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || task_1.createTask({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap;\n    var newAgentStubMap = overallTask.agentStubMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false;\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n    }\n\n    util_1.assert(!stageHandler.createOnAllSeries, errMsg);\n\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    } else {\n      overallProgress = false;\n      util_1.each(ecModel.getSeries(), createStub);\n    }\n\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, task_1.createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n\n      scheduler._pipe(seriesModel, stub);\n    }\n\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n\n    var pipeline = this._pipelineMap.get(pipelineId);\n\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if (util_1.isFunction(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n\n    stageHandler.uid = component_1.getUID('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n\n  ;\n  return Scheduler;\n}();\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = model_1.normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? util_1.map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, Global_1[\"default\"]);\nmockMethods(apiMock, ExtensionAPI_1[\"default\"]);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  for (var name_1 in Clz.prototype) {\n    target[name_1] = util_1.noop;\n  }\n}\n\nexports[\"default\"] = Scheduler;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/stream/Scheduler.js"],"names":["exports","__esModule","util_1","require","task_1","component_1","Global_1","ExtensionAPI_1","model_1","Scheduler","ecInstance","api","dataProcessorHandlers","visualHandlers","_stageTaskMap","createHashMap","_dataProcessorHandlers","slice","_visualHandlers","_allHandlers","concat","prototype","restoreData","ecModel","payload","each","taskRecord","overallTask","dirty","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","incremental","progressiveEnabled","progressiveRender","__idxInPipeline","blockIndex","step","modDataCount","modBy","Math","ceil","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","data","getData","dataLen","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","round","_pipe","dataTask","prepareStageTasks","stageTaskMap","getModel","handler","record","errMsg","process","env","NODE_ENV","assert","reset","overallReset","_createSeriesStageTask","_createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","_performStageTasks","block","performVisualTasks","opt","stageHandlers","unfinished","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallNeedDirty_1","agentStubMap","stub","needSetDirty","updatePayload","performArgs_1","perform","performArgs","skip","performRawSeries","isSeriesFiltered","setDirty","dirtyMap","performSeriesTasks","plan","getUpstream","oldSeriesTaskMap","newSeriesTaskMap","seriesType","getTargetSeries","createOnAllSeries","eachRawSeries","create","eachRawSeriesByType","createTask","seriesTaskPlan","seriesTaskReset","seriesTaskCount","useClearVisual","isVisual","isLayout","overallTaskReset","oldAgentStubMap","newAgentStubMap","overallProgress","shouldOverallTaskDirty","createStub","getSeries","stubReset","onDirty","stubOnDirty","agent","pipe","wrapStageHandler","isFunction","detectSeriseType","getUID","stubProgress","getDownstream","clearAllVisual","resetDefines","normalizeToArray","length","map","v","makeSeriesTaskProgress","singleSeriesTaskProgress","resetDefineIdx","params","resetDefine","dataEach","i","start","end","progress","legacyFunc","ecModelMock","apiMock","e","mockMethods","eachSeriesByType","type","eachComponent","cond","mainType","subType","target","Clz","name_1","noop"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar util_1 = require(\"zrender/lib/core/util\");\n\nvar task_1 = require(\"./task\");\n\nvar component_1 = require(\"../util/component\");\n\nvar Global_1 = require(\"../model/Global\");\n\nvar ExtensionAPI_1 = require(\"../ExtensionAPI\");\n\nvar model_1 = require(\"../util/model\");\n\n;\n\nvar Scheduler = function () {\n  function Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n    this._stageTaskMap = util_1.createHashMap();\n    this.ecInstance = ecInstance;\n    this.api = api;\n    dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n    visualHandlers = this._visualHandlers = visualHandlers.slice();\n    this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  }\n\n  Scheduler.prototype.restoreData = function (ecModel, payload) {\n    ecModel.restoreData(payload);\n\n    this._stageTaskMap.each(function (taskRecord) {\n      var overallTask = taskRecord.overallTask;\n      overallTask && overallTask.dirty();\n    });\n  };\n\n  Scheduler.prototype.getPerformArgs = function (task, isBlock) {\n    if (!task.__pipeline) {\n      return;\n    }\n\n    var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n    var pCtx = pipeline.context;\n    var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n    var step = incremental ? pipeline.step : null;\n    var modDataCount = pCtx && pCtx.modDataCount;\n    var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n    return {\n      step: step,\n      modBy: modBy,\n      modDataCount: modDataCount\n    };\n  };\n\n  Scheduler.prototype.getPipeline = function (pipelineId) {\n    return this._pipelineMap.get(pipelineId);\n  };\n\n  Scheduler.prototype.updateStreamModes = function (seriesModel, view) {\n    var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n    var data = seriesModel.getData();\n    var dataLen = data.count();\n    var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n    var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold');\n    var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n    seriesModel.pipelineContext = pipeline.context = {\n      progressiveRender: progressiveRender,\n      modDataCount: modDataCount,\n      large: large\n    };\n  };\n\n  Scheduler.prototype.restorePipelines = function (ecModel) {\n    var scheduler = this;\n    var pipelineMap = scheduler._pipelineMap = util_1.createHashMap();\n    ecModel.eachSeries(function (seriesModel) {\n      var progressive = seriesModel.getProgressive();\n      var pipelineId = seriesModel.uid;\n      pipelineMap.set(pipelineId, {\n        id: pipelineId,\n        head: null,\n        tail: null,\n        threshold: seriesModel.getProgressiveThreshold(),\n        progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n        blockIndex: -1,\n        step: Math.round(progressive || 700),\n        count: 0\n      });\n\n      scheduler._pipe(seriesModel, seriesModel.dataTask);\n    });\n  };\n\n  Scheduler.prototype.prepareStageTasks = function () {\n    var stageTaskMap = this._stageTaskMap;\n    var ecModel = this.api.getModel();\n    var api = this.api;\n    util_1.each(this._allHandlers, function (handler) {\n      var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {});\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = '\"reset\" and \"overallReset\" must not be both specified.';\n      }\n\n      util_1.assert(!(handler.reset && handler.overallReset), errMsg);\n      handler.reset && this._createSeriesStageTask(handler, record, ecModel, api);\n      handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api);\n    }, this);\n  };\n\n  Scheduler.prototype.prepareView = function (view, model, ecModel, api) {\n    var renderTask = view.renderTask;\n    var context = renderTask.context;\n    context.model = model;\n    context.ecModel = ecModel;\n    context.api = api;\n    renderTask.__block = !view.incrementalPrepareRender;\n\n    this._pipe(model, renderTask);\n  };\n\n  Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {\n    this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {\n      block: true\n    });\n  };\n\n  Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {\n    this._performStageTasks(this._visualHandlers, ecModel, payload, opt);\n  };\n\n  Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {\n    opt = opt || {};\n    var unfinished = false;\n    var scheduler = this;\n    util_1.each(stageHandlers, function (stageHandler, idx) {\n      if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n        return;\n      }\n\n      var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n      var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n      var overallTask = stageHandlerRecord.overallTask;\n\n      if (overallTask) {\n        var overallNeedDirty_1;\n        var agentStubMap = overallTask.agentStubMap;\n        agentStubMap.each(function (stub) {\n          if (needSetDirty(opt, stub)) {\n            stub.dirty();\n            overallNeedDirty_1 = true;\n          }\n        });\n        overallNeedDirty_1 && overallTask.dirty();\n        scheduler.updatePayload(overallTask, payload);\n        var performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block);\n        agentStubMap.each(function (stub) {\n          stub.perform(performArgs_1);\n        });\n\n        if (overallTask.perform(performArgs_1)) {\n          unfinished = true;\n        }\n      } else if (seriesTaskMap) {\n        seriesTaskMap.each(function (task, pipelineId) {\n          if (needSetDirty(opt, task)) {\n            task.dirty();\n          }\n\n          var performArgs = scheduler.getPerformArgs(task, opt.block);\n          performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n          scheduler.updatePayload(task, payload);\n\n          if (task.perform(performArgs)) {\n            unfinished = true;\n          }\n        });\n      }\n    });\n\n    function needSetDirty(opt, task) {\n      return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n    }\n\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.performSeriesTasks = function (ecModel) {\n    var unfinished;\n    ecModel.eachSeries(function (seriesModel) {\n      unfinished = seriesModel.dataTask.perform() || unfinished;\n    });\n    this.unfinished = unfinished || this.unfinished;\n  };\n\n  Scheduler.prototype.plan = function () {\n    this._pipelineMap.each(function (pipeline) {\n      var task = pipeline.tail;\n\n      do {\n        if (task.__block) {\n          pipeline.blockIndex = task.__idxInPipeline;\n          break;\n        }\n\n        task = task.getUpstream();\n      } while (task);\n    });\n  };\n\n  Scheduler.prototype.updatePayload = function (task, payload) {\n    payload !== 'remain' && (task.context.payload = payload);\n  };\n\n  Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n\n    if (stageHandler.createOnAllSeries) {\n      ecModel.eachRawSeries(create);\n    } else if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, create);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(create);\n    }\n\n    function create(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || task_1.createTask({\n        plan: seriesTaskPlan,\n        reset: seriesTaskReset,\n        count: seriesTaskCount\n      }));\n      task.context = {\n        model: seriesModel,\n        ecModel: ecModel,\n        api: api,\n        useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n        plan: stageHandler.plan,\n        reset: stageHandler.reset,\n        scheduler: scheduler\n      };\n\n      scheduler._pipe(seriesModel, task);\n    }\n  };\n\n  Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {\n    var scheduler = this;\n    var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || task_1.createTask({\n      reset: overallTaskReset\n    });\n    overallTask.context = {\n      ecModel: ecModel,\n      api: api,\n      overallReset: stageHandler.overallReset,\n      scheduler: scheduler\n    };\n    var oldAgentStubMap = overallTask.agentStubMap;\n    var newAgentStubMap = overallTask.agentStubMap = util_1.createHashMap();\n    var seriesType = stageHandler.seriesType;\n    var getTargetSeries = stageHandler.getTargetSeries;\n    var overallProgress = true;\n    var shouldOverallTaskDirty = false;\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = '\"createOnAllSeries\" do not supported for \"overallReset\", ' + 'becuase it will block all streams.';\n    }\n\n    util_1.assert(!stageHandler.createOnAllSeries, errMsg);\n\n    if (seriesType) {\n      ecModel.eachRawSeriesByType(seriesType, createStub);\n    } else if (getTargetSeries) {\n      getTargetSeries(ecModel, api).each(createStub);\n    } else {\n      overallProgress = false;\n      util_1.each(ecModel.getSeries(), createStub);\n    }\n\n    function createStub(seriesModel) {\n      var pipelineId = seriesModel.uid;\n      var stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || (shouldOverallTaskDirty = true, task_1.createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })));\n      stub.context = {\n        model: seriesModel,\n        overallProgress: overallProgress\n      };\n      stub.agent = overallTask;\n      stub.__block = overallProgress;\n\n      scheduler._pipe(seriesModel, stub);\n    }\n\n    if (shouldOverallTaskDirty) {\n      overallTask.dirty();\n    }\n  };\n\n  Scheduler.prototype._pipe = function (seriesModel, task) {\n    var pipelineId = seriesModel.uid;\n\n    var pipeline = this._pipelineMap.get(pipelineId);\n\n    !pipeline.head && (pipeline.head = task);\n    pipeline.tail && pipeline.tail.pipe(task);\n    pipeline.tail = task;\n    task.__idxInPipeline = pipeline.count++;\n    task.__pipeline = pipeline;\n  };\n\n  Scheduler.wrapStageHandler = function (stageHandler, visualType) {\n    if (util_1.isFunction(stageHandler)) {\n      stageHandler = {\n        overallReset: stageHandler,\n        seriesType: detectSeriseType(stageHandler)\n      };\n    }\n\n    stageHandler.uid = component_1.getUID('stageHandler');\n    visualType && (stageHandler.visualType = visualType);\n    return stageHandler;\n  };\n\n  ;\n  return Scheduler;\n}();\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null;\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = model_1.normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? util_1.map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, Global_1[\"default\"]);\nmockMethods(apiMock, ExtensionAPI_1[\"default\"]);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  for (var name_1 in Clz.prototype) {\n    target[name_1] = util_1.noop;\n  }\n}\n\nexports[\"default\"] = Scheduler;"]},"metadata":{},"sourceType":"script"}