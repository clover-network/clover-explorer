{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\"use strict\";\n\nexports.__esModule = true;\n\nvar tslib_1 = require(\"tslib\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar Scale_1 = require(\"./Scale\");\n\nvar helper = require(\"./helper\");\n\nvar roundNumber = numberUtil.round;\n\nvar IntervalScale = function (_super) {\n  tslib_1.__extends(IntervalScale, _super);\n\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'interval';\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n\n  IntervalScale.prototype.parse = function (val) {\n    return val;\n  };\n\n  IntervalScale.prototype.contain = function (val) {\n    return helper.contain(val, this._extent);\n  };\n\n  IntervalScale.prototype.normalize = function (val) {\n    return helper.normalize(val, this._extent);\n  };\n\n  IntervalScale.prototype.scale = function (val) {\n    return helper.scale(val, this._extent);\n  };\n\n  IntervalScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent;\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  };\n\n  IntervalScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]);\n    this.setExtent(extent[0], extent[1]);\n  };\n\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval;\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  };\n\n  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = [];\n\n    if (!interval) {\n      return ticks;\n    }\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      });\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1].value) {\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    }\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n\n    return ticks;\n  };\n\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval);\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  };\n\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data.value) || 0;\n    } else if (precision === 'auto') {\n      precision = this._intervalPrecision;\n    }\n\n    var dataNum = roundNumber(data.value, precision, true);\n    return formatUtil.addCommas(dataNum);\n  };\n\n  IntervalScale.prototype.niceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    }\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n\n  IntervalScale.prototype.niceExtent = function (opt) {\n    var extent = this._extent;\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        var expandSize = extent[0];\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  };\n\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(Scale_1[\"default\"]);\n\nScale_1[\"default\"].registerClass(IntervalScale);\nexports[\"default\"] = IntervalScale;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/lib/scale/Interval.js"],"names":["exports","__esModule","tslib_1","require","numberUtil","formatUtil","Scale_1","helper","roundNumber","round","IntervalScale","_super","__extends","_this","apply","arguments","type","_interval","_intervalPrecision","prototype","parse","val","contain","_extent","normalize","scale","setExtent","start","end","thisExtent","isNaN","parseFloat","unionExtent","other","extent","getInterval","setInterval","interval","_niceExtent","slice","getIntervalPrecision","getTicks","expandToNicedExtent","niceTickExtent","intervalPrecision","ticks","safeLimit","push","value","tick","length","lastNiceTick","getMinorTicks","splitNumber","minorTicks","getExtent","i","nextTick","prevTick","count","minorTicksGroup","minorInterval","minorTick","getLabel","data","opt","precision","getPrecisionSafe","dataNum","addCommas","niceTicks","minInterval","maxInterval","span","isFinite","reverse","result","intervalScaleNiceTicks","niceExtent","expandSize","fixMax","fixMin","Math","floor","ceil","registerClass"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEA,IAAIC,UAAU,GAAGD,OAAO,CAAC,gBAAD,CAAxB;;AAEA,IAAIE,UAAU,GAAGF,OAAO,CAAC,gBAAD,CAAxB;;AAEA,IAAIG,OAAO,GAAGH,OAAO,CAAC,SAAD,CAArB;;AAEA,IAAII,MAAM,GAAGJ,OAAO,CAAC,UAAD,CAApB;;AAEA,IAAIK,WAAW,GAAGJ,UAAU,CAACK,KAA7B;;AAEA,IAAIC,aAAa,GAAG,UAAUC,MAAV,EAAkB;AACpCT,EAAAA,OAAO,CAACU,SAAR,CAAkBF,aAAlB,EAAiCC,MAAjC;;AAEA,WAASD,aAAT,GAAyB;AACvB,QAAIG,KAAK,GAAGF,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACG,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;AAEAF,IAAAA,KAAK,CAACG,IAAN,GAAa,UAAb;AACAH,IAAAA,KAAK,CAACI,SAAN,GAAkB,CAAlB;AACAJ,IAAAA,KAAK,CAACK,kBAAN,GAA2B,CAA3B;AACA,WAAOL,KAAP;AACD;;AAEDH,EAAAA,aAAa,CAACS,SAAd,CAAwBC,KAAxB,GAAgC,UAAUC,GAAV,EAAe;AAC7C,WAAOA,GAAP;AACD,GAFD;;AAIAX,EAAAA,aAAa,CAACS,SAAd,CAAwBG,OAAxB,GAAkC,UAAUD,GAAV,EAAe;AAC/C,WAAOd,MAAM,CAACe,OAAP,CAAeD,GAAf,EAAoB,KAAKE,OAAzB,CAAP;AACD,GAFD;;AAIAb,EAAAA,aAAa,CAACS,SAAd,CAAwBK,SAAxB,GAAoC,UAAUH,GAAV,EAAe;AACjD,WAAOd,MAAM,CAACiB,SAAP,CAAiBH,GAAjB,EAAsB,KAAKE,OAA3B,CAAP;AACD,GAFD;;AAIAb,EAAAA,aAAa,CAACS,SAAd,CAAwBM,KAAxB,GAAgC,UAAUJ,GAAV,EAAe;AAC7C,WAAOd,MAAM,CAACkB,KAAP,CAAaJ,GAAb,EAAkB,KAAKE,OAAvB,CAAP;AACD,GAFD;;AAIAb,EAAAA,aAAa,CAACS,SAAd,CAAwBO,SAAxB,GAAoC,UAAUC,KAAV,EAAiBC,GAAjB,EAAsB;AACxD,QAAIC,UAAU,GAAG,KAAKN,OAAtB;;AAEA,QAAI,CAACO,KAAK,CAACH,KAAD,CAAV,EAAmB;AACjBE,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBE,UAAU,CAACJ,KAAD,CAA1B;AACD;;AAED,QAAI,CAACG,KAAK,CAACF,GAAD,CAAV,EAAiB;AACfC,MAAAA,UAAU,CAAC,CAAD,CAAV,GAAgBE,UAAU,CAACH,GAAD,CAA1B;AACD;AACF,GAVD;;AAYAlB,EAAAA,aAAa,CAACS,SAAd,CAAwBa,WAAxB,GAAsC,UAAUC,KAAV,EAAiB;AACrD,QAAIC,MAAM,GAAG,KAAKX,OAAlB;AACAU,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB,KAAyBA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAAC,CAAD,CAA1C;AACAA,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAWC,MAAM,CAAC,CAAD,CAAjB,KAAyBA,MAAM,CAAC,CAAD,CAAN,GAAYD,KAAK,CAAC,CAAD,CAA1C;AACA,SAAKP,SAAL,CAAeQ,MAAM,CAAC,CAAD,CAArB,EAA0BA,MAAM,CAAC,CAAD,CAAhC;AACD,GALD;;AAOAxB,EAAAA,aAAa,CAACS,SAAd,CAAwBgB,WAAxB,GAAsC,YAAY;AAChD,WAAO,KAAKlB,SAAZ;AACD,GAFD;;AAIAP,EAAAA,aAAa,CAACS,SAAd,CAAwBiB,WAAxB,GAAsC,UAAUC,QAAV,EAAoB;AACxD,SAAKpB,SAAL,GAAiBoB,QAAjB;AACA,SAAKC,WAAL,GAAmB,KAAKf,OAAL,CAAagB,KAAb,EAAnB;AACA,SAAKrB,kBAAL,GAA0BX,MAAM,CAACiC,oBAAP,CAA4BH,QAA5B,CAA1B;AACD,GAJD;;AAMA3B,EAAAA,aAAa,CAACS,SAAd,CAAwBsB,QAAxB,GAAmC,UAAUC,mBAAV,EAA+B;AAChE,QAAIL,QAAQ,GAAG,KAAKpB,SAApB;AACA,QAAIiB,MAAM,GAAG,KAAKX,OAAlB;AACA,QAAIoB,cAAc,GAAG,KAAKL,WAA1B;AACA,QAAIM,iBAAiB,GAAG,KAAK1B,kBAA7B;AACA,QAAI2B,KAAK,GAAG,EAAZ;;AAEA,QAAI,CAACR,QAAL,EAAe;AACb,aAAOQ,KAAP;AACD;;AAED,QAAIC,SAAS,GAAG,KAAhB;;AAEA,QAAIZ,MAAM,CAAC,CAAD,CAAN,GAAYS,cAAc,CAAC,CAAD,CAA9B,EAAmC;AACjC,UAAID,mBAAJ,EAAyB;AACvBG,QAAAA,KAAK,CAACE,IAAN,CAAW;AACTC,UAAAA,KAAK,EAAExC,WAAW,CAACmC,cAAc,CAAC,CAAD,CAAd,GAAoBN,QAArB,EAA+BO,iBAA/B;AADT,SAAX;AAGD,OAJD,MAIO;AACLC,QAAAA,KAAK,CAACE,IAAN,CAAW;AACTC,UAAAA,KAAK,EAAEd,MAAM,CAAC,CAAD;AADJ,SAAX;AAGD;AACF;;AAED,QAAIe,IAAI,GAAGN,cAAc,CAAC,CAAD,CAAzB;;AAEA,WAAOM,IAAI,IAAIN,cAAc,CAAC,CAAD,CAA7B,EAAkC;AAChCE,MAAAA,KAAK,CAACE,IAAN,CAAW;AACTC,QAAAA,KAAK,EAAEC;AADE,OAAX;AAGAA,MAAAA,IAAI,GAAGzC,WAAW,CAACyC,IAAI,GAAGZ,QAAR,EAAkBO,iBAAlB,CAAlB;;AAEA,UAAIK,IAAI,KAAKJ,KAAK,CAACA,KAAK,CAACK,MAAN,GAAe,CAAhB,CAAL,CAAwBF,KAArC,EAA4C;AAC1C;AACD;;AAED,UAAIH,KAAK,CAACK,MAAN,GAAeJ,SAAnB,EAA8B;AAC5B,eAAO,EAAP;AACD;AACF;;AAED,QAAIK,YAAY,GAAGN,KAAK,CAACK,MAAN,GAAeL,KAAK,CAACA,KAAK,CAACK,MAAN,GAAe,CAAhB,CAAL,CAAwBF,KAAvC,GAA+CL,cAAc,CAAC,CAAD,CAAhF;;AAEA,QAAIT,MAAM,CAAC,CAAD,CAAN,GAAYiB,YAAhB,EAA8B;AAC5B,UAAIT,mBAAJ,EAAyB;AACvBG,QAAAA,KAAK,CAACE,IAAN,CAAW;AACTC,UAAAA,KAAK,EAAExC,WAAW,CAAC2C,YAAY,GAAGd,QAAhB,EAA0BO,iBAA1B;AADT,SAAX;AAGD,OAJD,MAIO;AACLC,QAAAA,KAAK,CAACE,IAAN,CAAW;AACTC,UAAAA,KAAK,EAAEd,MAAM,CAAC,CAAD;AADJ,SAAX;AAGD;AACF;;AAED,WAAOW,KAAP;AACD,GAzDD;;AA2DAnC,EAAAA,aAAa,CAACS,SAAd,CAAwBiC,aAAxB,GAAwC,UAAUC,WAAV,EAAuB;AAC7D,QAAIR,KAAK,GAAG,KAAKJ,QAAL,CAAc,IAAd,CAAZ;AACA,QAAIa,UAAU,GAAG,EAAjB;AACA,QAAIpB,MAAM,GAAG,KAAKqB,SAAL,EAAb;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGX,KAAK,CAACK,MAA1B,EAAkCM,CAAC,EAAnC,EAAuC;AACrC,UAAIC,QAAQ,GAAGZ,KAAK,CAACW,CAAD,CAApB;AACA,UAAIE,QAAQ,GAAGb,KAAK,CAACW,CAAC,GAAG,CAAL,CAApB;AACA,UAAIG,KAAK,GAAG,CAAZ;AACA,UAAIC,eAAe,GAAG,EAAtB;AACA,UAAIvB,QAAQ,GAAGoB,QAAQ,CAACT,KAAT,GAAiBU,QAAQ,CAACV,KAAzC;AACA,UAAIa,aAAa,GAAGxB,QAAQ,GAAGgB,WAA/B;;AAEA,aAAOM,KAAK,GAAGN,WAAW,GAAG,CAA7B,EAAgC;AAC9B,YAAIS,SAAS,GAAGtD,WAAW,CAACkD,QAAQ,CAACV,KAAT,GAAiB,CAACW,KAAK,GAAG,CAAT,IAAcE,aAAhC,CAA3B;;AAEA,YAAIC,SAAS,GAAG5B,MAAM,CAAC,CAAD,CAAlB,IAAyB4B,SAAS,GAAG5B,MAAM,CAAC,CAAD,CAA/C,EAAoD;AAClD0B,UAAAA,eAAe,CAACb,IAAhB,CAAqBe,SAArB;AACD;;AAEDH,QAAAA,KAAK;AACN;;AAEDL,MAAAA,UAAU,CAACP,IAAX,CAAgBa,eAAhB;AACD;;AAED,WAAON,UAAP;AACD,GA3BD;;AA6BA5C,EAAAA,aAAa,CAACS,SAAd,CAAwB4C,QAAxB,GAAmC,UAAUC,IAAV,EAAgBC,GAAhB,EAAqB;AACtD,QAAID,IAAI,IAAI,IAAZ,EAAkB;AAChB,aAAO,EAAP;AACD;;AAED,QAAIE,SAAS,GAAGD,GAAG,IAAIA,GAAG,CAACC,SAA3B;;AAEA,QAAIA,SAAS,IAAI,IAAjB,EAAuB;AACrBA,MAAAA,SAAS,GAAG9D,UAAU,CAAC+D,gBAAX,CAA4BH,IAAI,CAAChB,KAAjC,KAA2C,CAAvD;AACD,KAFD,MAEO,IAAIkB,SAAS,KAAK,MAAlB,EAA0B;AAC/BA,MAAAA,SAAS,GAAG,KAAKhD,kBAAjB;AACD;;AAED,QAAIkD,OAAO,GAAG5D,WAAW,CAACwD,IAAI,CAAChB,KAAN,EAAakB,SAAb,EAAwB,IAAxB,CAAzB;AACA,WAAO7D,UAAU,CAACgE,SAAX,CAAqBD,OAArB,CAAP;AACD,GAfD;;AAiBA1D,EAAAA,aAAa,CAACS,SAAd,CAAwBmD,SAAxB,GAAoC,UAAUjB,WAAV,EAAuBkB,WAAvB,EAAoCC,WAApC,EAAiD;AACnFnB,IAAAA,WAAW,GAAGA,WAAW,IAAI,CAA7B;AACA,QAAInB,MAAM,GAAG,KAAKX,OAAlB;AACA,QAAIkD,IAAI,GAAGvC,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA7B;;AAEA,QAAI,CAACwC,QAAQ,CAACD,IAAD,CAAb,EAAqB;AACnB;AACD;;AAED,QAAIA,IAAI,GAAG,CAAX,EAAc;AACZA,MAAAA,IAAI,GAAG,CAACA,IAAR;AACAvC,MAAAA,MAAM,CAACyC,OAAP;AACD;;AAED,QAAIC,MAAM,GAAGrE,MAAM,CAACsE,sBAAP,CAA8B3C,MAA9B,EAAsCmB,WAAtC,EAAmDkB,WAAnD,EAAgEC,WAAhE,CAAb;AACA,SAAKtD,kBAAL,GAA0B0D,MAAM,CAAChC,iBAAjC;AACA,SAAK3B,SAAL,GAAiB2D,MAAM,CAACvC,QAAxB;AACA,SAAKC,WAAL,GAAmBsC,MAAM,CAACjC,cAA1B;AACD,GAlBD;;AAoBAjC,EAAAA,aAAa,CAACS,SAAd,CAAwB2D,UAAxB,GAAqC,UAAUb,GAAV,EAAe;AAClD,QAAI/B,MAAM,GAAG,KAAKX,OAAlB;;AAEA,QAAIW,MAAM,CAAC,CAAD,CAAN,KAAcA,MAAM,CAAC,CAAD,CAAxB,EAA6B;AAC3B,UAAIA,MAAM,CAAC,CAAD,CAAN,KAAc,CAAlB,EAAqB;AACnB,YAAI6C,UAAU,GAAG7C,MAAM,CAAC,CAAD,CAAvB;;AAEA,YAAI,CAAC+B,GAAG,CAACe,MAAT,EAAiB;AACf9C,UAAAA,MAAM,CAAC,CAAD,CAAN,IAAa6C,UAAU,GAAG,CAA1B;AACA7C,UAAAA,MAAM,CAAC,CAAD,CAAN,IAAa6C,UAAU,GAAG,CAA1B;AACD,SAHD,MAGO;AACL7C,UAAAA,MAAM,CAAC,CAAD,CAAN,IAAa6C,UAAU,GAAG,CAA1B;AACD;AACF,OATD,MASO;AACL7C,QAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAAZ;AACD;AACF;;AAED,QAAIuC,IAAI,GAAGvC,MAAM,CAAC,CAAD,CAAN,GAAYA,MAAM,CAAC,CAAD,CAA7B;;AAEA,QAAI,CAACwC,QAAQ,CAACD,IAAD,CAAb,EAAqB;AACnBvC,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAAZ;AACAA,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY,CAAZ;AACD;;AAED,SAAKoC,SAAL,CAAeL,GAAG,CAACZ,WAAnB,EAAgCY,GAAG,CAACM,WAApC,EAAiDN,GAAG,CAACO,WAArD;AACA,QAAInC,QAAQ,GAAG,KAAKpB,SAApB;;AAEA,QAAI,CAACgD,GAAG,CAACgB,MAAT,EAAiB;AACf/C,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY1B,WAAW,CAAC0E,IAAI,CAACC,KAAL,CAAWjD,MAAM,CAAC,CAAD,CAAN,GAAYG,QAAvB,IAAmCA,QAApC,CAAvB;AACD;;AAED,QAAI,CAAC4B,GAAG,CAACe,MAAT,EAAiB;AACf9C,MAAAA,MAAM,CAAC,CAAD,CAAN,GAAY1B,WAAW,CAAC0E,IAAI,CAACE,IAAL,CAAUlD,MAAM,CAAC,CAAD,CAAN,GAAYG,QAAtB,IAAkCA,QAAnC,CAAvB;AACD;AACF,GAnCD;;AAqCA3B,EAAAA,aAAa,CAACM,IAAd,GAAqB,UAArB;AACA,SAAON,aAAP;AACD,CA7NmB,CA6NlBJ,OAAO,CAAC,SAAD,CA7NW,CAApB;;AA+NAA,OAAO,CAAC,SAAD,CAAP,CAAmB+E,aAAnB,CAAiC3E,aAAjC;AACAV,OAAO,CAAC,SAAD,CAAP,GAAqBU,aAArB","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n\"use strict\";\n\nexports.__esModule = true;\n\nvar tslib_1 = require(\"tslib\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar formatUtil = require(\"../util/format\");\n\nvar Scale_1 = require(\"./Scale\");\n\nvar helper = require(\"./helper\");\n\nvar roundNumber = numberUtil.round;\n\nvar IntervalScale = function (_super) {\n  tslib_1.__extends(IntervalScale, _super);\n\n  function IntervalScale() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = 'interval';\n    _this._interval = 0;\n    _this._intervalPrecision = 2;\n    return _this;\n  }\n\n  IntervalScale.prototype.parse = function (val) {\n    return val;\n  };\n\n  IntervalScale.prototype.contain = function (val) {\n    return helper.contain(val, this._extent);\n  };\n\n  IntervalScale.prototype.normalize = function (val) {\n    return helper.normalize(val, this._extent);\n  };\n\n  IntervalScale.prototype.scale = function (val) {\n    return helper.scale(val, this._extent);\n  };\n\n  IntervalScale.prototype.setExtent = function (start, end) {\n    var thisExtent = this._extent;\n\n    if (!isNaN(start)) {\n      thisExtent[0] = parseFloat(start);\n    }\n\n    if (!isNaN(end)) {\n      thisExtent[1] = parseFloat(end);\n    }\n  };\n\n  IntervalScale.prototype.unionExtent = function (other) {\n    var extent = this._extent;\n    other[0] < extent[0] && (extent[0] = other[0]);\n    other[1] > extent[1] && (extent[1] = other[1]);\n    this.setExtent(extent[0], extent[1]);\n  };\n\n  IntervalScale.prototype.getInterval = function () {\n    return this._interval;\n  };\n\n  IntervalScale.prototype.setInterval = function (interval) {\n    this._interval = interval;\n    this._niceExtent = this._extent.slice();\n    this._intervalPrecision = helper.getIntervalPrecision(interval);\n  };\n\n  IntervalScale.prototype.getTicks = function (expandToNicedExtent) {\n    var interval = this._interval;\n    var extent = this._extent;\n    var niceTickExtent = this._niceExtent;\n    var intervalPrecision = this._intervalPrecision;\n    var ticks = [];\n\n    if (!interval) {\n      return ticks;\n    }\n\n    var safeLimit = 10000;\n\n    if (extent[0] < niceTickExtent[0]) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[0]\n        });\n      }\n    }\n\n    var tick = niceTickExtent[0];\n\n    while (tick <= niceTickExtent[1]) {\n      ticks.push({\n        value: tick\n      });\n      tick = roundNumber(tick + interval, intervalPrecision);\n\n      if (tick === ticks[ticks.length - 1].value) {\n        break;\n      }\n\n      if (ticks.length > safeLimit) {\n        return [];\n      }\n    }\n\n    var lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1];\n\n    if (extent[1] > lastNiceTick) {\n      if (expandToNicedExtent) {\n        ticks.push({\n          value: roundNumber(lastNiceTick + interval, intervalPrecision)\n        });\n      } else {\n        ticks.push({\n          value: extent[1]\n        });\n      }\n    }\n\n    return ticks;\n  };\n\n  IntervalScale.prototype.getMinorTicks = function (splitNumber) {\n    var ticks = this.getTicks(true);\n    var minorTicks = [];\n    var extent = this.getExtent();\n\n    for (var i = 1; i < ticks.length; i++) {\n      var nextTick = ticks[i];\n      var prevTick = ticks[i - 1];\n      var count = 0;\n      var minorTicksGroup = [];\n      var interval = nextTick.value - prevTick.value;\n      var minorInterval = interval / splitNumber;\n\n      while (count < splitNumber - 1) {\n        var minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval);\n\n        if (minorTick > extent[0] && minorTick < extent[1]) {\n          minorTicksGroup.push(minorTick);\n        }\n\n        count++;\n      }\n\n      minorTicks.push(minorTicksGroup);\n    }\n\n    return minorTicks;\n  };\n\n  IntervalScale.prototype.getLabel = function (data, opt) {\n    if (data == null) {\n      return '';\n    }\n\n    var precision = opt && opt.precision;\n\n    if (precision == null) {\n      precision = numberUtil.getPrecisionSafe(data.value) || 0;\n    } else if (precision === 'auto') {\n      precision = this._intervalPrecision;\n    }\n\n    var dataNum = roundNumber(data.value, precision, true);\n    return formatUtil.addCommas(dataNum);\n  };\n\n  IntervalScale.prototype.niceTicks = function (splitNumber, minInterval, maxInterval) {\n    splitNumber = splitNumber || 5;\n    var extent = this._extent;\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      return;\n    }\n\n    if (span < 0) {\n      span = -span;\n      extent.reverse();\n    }\n\n    var result = helper.intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval);\n    this._intervalPrecision = result.intervalPrecision;\n    this._interval = result.interval;\n    this._niceExtent = result.niceTickExtent;\n  };\n\n  IntervalScale.prototype.niceExtent = function (opt) {\n    var extent = this._extent;\n\n    if (extent[0] === extent[1]) {\n      if (extent[0] !== 0) {\n        var expandSize = extent[0];\n\n        if (!opt.fixMax) {\n          extent[1] += expandSize / 2;\n          extent[0] -= expandSize / 2;\n        } else {\n          extent[0] -= expandSize / 2;\n        }\n      } else {\n        extent[1] = 1;\n      }\n    }\n\n    var span = extent[1] - extent[0];\n\n    if (!isFinite(span)) {\n      extent[0] = 0;\n      extent[1] = 1;\n    }\n\n    this.niceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval);\n    var interval = this._interval;\n\n    if (!opt.fixMin) {\n      extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval);\n    }\n\n    if (!opt.fixMax) {\n      extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval);\n    }\n  };\n\n  IntervalScale.type = 'interval';\n  return IntervalScale;\n}(Scale_1[\"default\"]);\n\nScale_1[\"default\"].registerClass(IntervalScale);\nexports[\"default\"] = IntervalScale;"]},"metadata":{},"sourceType":"script"}