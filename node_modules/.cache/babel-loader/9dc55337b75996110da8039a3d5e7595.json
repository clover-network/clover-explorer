{"ast":null,"code":"var SPEED_DIVISOR = 800;\n\nvar RadialNonoverlapForce =\n/** @class */\nfunction () {\n  function RadialNonoverlapForce(params) {\n    this.disp = [];\n    this.positions = params.positions;\n    this.adjMatrix = params.adjMatrix;\n    this.focusID = params.focusID;\n    this.radii = params.radii;\n    this.iterations = params.iterations || 10;\n    this.height = params.height || 10;\n    this.width = params.width || 10;\n    this.speed = params.speed || 100;\n    this.gravity = params.gravity || 10;\n    this.nodeSizeFunc = params.nodeSizeFunc;\n    this.k = params.k || 5;\n    this.strictRadial = params.strictRadial;\n    this.nodes = params.nodes;\n  }\n\n  RadialNonoverlapForce.prototype.layout = function () {\n    var self = this;\n    var positions = self.positions;\n    var disp = [];\n    var iterations = self.iterations;\n    var maxDisplace = self.width / 10;\n    self.maxDisplace = maxDisplace;\n    self.disp = disp;\n\n    for (var i = 0; i < iterations; i++) {\n      positions.forEach(function (_, k) {\n        disp[k] = {\n          x: 0,\n          y: 0\n        };\n      }); // 给重叠的节点增加斥力\n\n      self.getRepulsion();\n      self.updatePositions();\n    }\n\n    return positions;\n  };\n\n  RadialNonoverlapForce.prototype.getRepulsion = function () {\n    var self = this;\n    var positions = self.positions;\n    var nodes = self.nodes;\n    var disp = self.disp;\n    var k = self.k;\n    var radii = self.radii || [];\n    positions.forEach(function (v, i) {\n      disp[i] = {\n        x: 0,\n        y: 0\n      };\n      positions.forEach(function (u, j) {\n        if (i === j) {\n          return;\n        } // v and u are not on the same circle, return\n\n\n        if (radii[i] !== radii[j]) {\n          return;\n        }\n\n        var vecx = v[0] - u[0];\n        var vecy = v[1] - u[1];\n        var vecLength = Math.sqrt(vecx * vecx + vecy * vecy);\n\n        if (vecLength === 0) {\n          vecLength = 1;\n          var sign = i > j ? 1 : -1;\n          vecx = 0.01 * sign;\n          vecy = 0.01 * sign;\n        } // these two nodes overlap\n\n\n        if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {\n          var common = k * k / vecLength;\n          disp[i].x += vecx / vecLength * common;\n          disp[i].y += vecy / vecLength * common;\n        }\n      });\n    });\n  };\n\n  RadialNonoverlapForce.prototype.updatePositions = function () {\n    var self = this;\n    var positions = self.positions;\n    var disp = self.disp;\n    var speed = self.speed;\n    var strictRadial = self.strictRadial;\n    var f = self.focusID;\n    var maxDisplace = self.maxDisplace || self.width / 10;\n\n    if (strictRadial) {\n      disp.forEach(function (di, i) {\n        var vx = positions[i][0] - positions[f][0];\n        var vy = positions[i][1] - positions[f][1];\n        var vLength = Math.sqrt(vx * vx + vy * vy);\n        var vpx = vy / vLength;\n        var vpy = -vx / vLength;\n        var diLength = Math.sqrt(di.x * di.x + di.y * di.y);\n        var alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);\n\n        if (alpha > Math.PI / 2) {\n          alpha -= Math.PI / 2;\n          vpx *= -1;\n          vpy *= -1;\n        }\n\n        var tdispLength = Math.cos(alpha) * diLength;\n        di.x = vpx * tdispLength;\n        di.y = vpy * tdispLength;\n      });\n    } // move\n\n\n    var radii = self.radii;\n    positions.forEach(function (n, i) {\n      if (i === f) {\n        return;\n      }\n\n      var distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);\n\n      if (distLength > 0 && i !== f) {\n        var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n        n[0] += disp[i].x / distLength * limitedDist;\n        n[1] += disp[i].y / distLength * limitedDist;\n\n        if (strictRadial) {\n          var vx = n[0] - positions[f][0];\n          var vy = n[1] - positions[f][1];\n          var nfDis = Math.sqrt(vx * vx + vy * vy);\n          vx = vx / nfDis * radii[i];\n          vy = vy / nfDis * radii[i];\n          n[0] = positions[f][0] + vx;\n          n[1] = positions[f][1] + vy;\n        }\n      }\n    });\n  };\n\n  return RadialNonoverlapForce;\n}();\n\nexport default RadialNonoverlapForce;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/radial/radialNonoverlapForce.js"],"names":["SPEED_DIVISOR","RadialNonoverlapForce","params","disp","positions","adjMatrix","focusID","radii","iterations","height","width","speed","gravity","nodeSizeFunc","k","strictRadial","nodes","prototype","layout","self","maxDisplace","i","forEach","_","x","y","getRepulsion","updatePositions","v","u","j","vecx","vecy","vecLength","Math","sqrt","sign","common","f","di","vx","vy","vLength","vpx","vpy","diLength","alpha","acos","PI","tdispLength","cos","n","distLength","limitedDist","min","nfDis"],"mappings":"AAAA,IAAIA,aAAa,GAAG,GAApB;;AAEA,IAAIC,qBAAqB;AACzB;AACA,YAAY;AACV,WAASA,qBAAT,CAA+BC,MAA/B,EAAuC;AACrC,SAAKC,IAAL,GAAY,EAAZ;AACA,SAAKC,SAAL,GAAiBF,MAAM,CAACE,SAAxB;AACA,SAAKC,SAAL,GAAiBH,MAAM,CAACG,SAAxB;AACA,SAAKC,OAAL,GAAeJ,MAAM,CAACI,OAAtB;AACA,SAAKC,KAAL,GAAaL,MAAM,CAACK,KAApB;AACA,SAAKC,UAAL,GAAkBN,MAAM,CAACM,UAAP,IAAqB,EAAvC;AACA,SAAKC,MAAL,GAAcP,MAAM,CAACO,MAAP,IAAiB,EAA/B;AACA,SAAKC,KAAL,GAAaR,MAAM,CAACQ,KAAP,IAAgB,EAA7B;AACA,SAAKC,KAAL,GAAaT,MAAM,CAACS,KAAP,IAAgB,GAA7B;AACA,SAAKC,OAAL,GAAeV,MAAM,CAACU,OAAP,IAAkB,EAAjC;AACA,SAAKC,YAAL,GAAoBX,MAAM,CAACW,YAA3B;AACA,SAAKC,CAAL,GAASZ,MAAM,CAACY,CAAP,IAAY,CAArB;AACA,SAAKC,YAAL,GAAoBb,MAAM,CAACa,YAA3B;AACA,SAAKC,KAAL,GAAad,MAAM,CAACc,KAApB;AACD;;AAEDf,EAAAA,qBAAqB,CAACgB,SAAtB,CAAgCC,MAAhC,GAAyC,YAAY;AACnD,QAAIC,IAAI,GAAG,IAAX;AACA,QAAIf,SAAS,GAAGe,IAAI,CAACf,SAArB;AACA,QAAID,IAAI,GAAG,EAAX;AACA,QAAIK,UAAU,GAAGW,IAAI,CAACX,UAAtB;AACA,QAAIY,WAAW,GAAGD,IAAI,CAACT,KAAL,GAAa,EAA/B;AACAS,IAAAA,IAAI,CAACC,WAAL,GAAmBA,WAAnB;AACAD,IAAAA,IAAI,CAAChB,IAAL,GAAYA,IAAZ;;AAEA,SAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,UAApB,EAAgCa,CAAC,EAAjC,EAAqC;AACnCjB,MAAAA,SAAS,CAACkB,OAAV,CAAkB,UAAUC,CAAV,EAAaT,CAAb,EAAgB;AAChCX,QAAAA,IAAI,CAACW,CAAD,CAAJ,GAAU;AACRU,UAAAA,CAAC,EAAE,CADK;AAERC,UAAAA,CAAC,EAAE;AAFK,SAAV;AAID,OALD,EADmC,CAM/B;;AAEJN,MAAAA,IAAI,CAACO,YAAL;AACAP,MAAAA,IAAI,CAACQ,eAAL;AACD;;AAED,WAAOvB,SAAP;AACD,GAtBD;;AAwBAH,EAAAA,qBAAqB,CAACgB,SAAtB,CAAgCS,YAAhC,GAA+C,YAAY;AACzD,QAAIP,IAAI,GAAG,IAAX;AACA,QAAIf,SAAS,GAAGe,IAAI,CAACf,SAArB;AACA,QAAIY,KAAK,GAAGG,IAAI,CAACH,KAAjB;AACA,QAAIb,IAAI,GAAGgB,IAAI,CAAChB,IAAhB;AACA,QAAIW,CAAC,GAAGK,IAAI,CAACL,CAAb;AACA,QAAIP,KAAK,GAAGY,IAAI,CAACZ,KAAL,IAAc,EAA1B;AACAH,IAAAA,SAAS,CAACkB,OAAV,CAAkB,UAAUM,CAAV,EAAaP,CAAb,EAAgB;AAChClB,MAAAA,IAAI,CAACkB,CAAD,CAAJ,GAAU;AACRG,QAAAA,CAAC,EAAE,CADK;AAERC,QAAAA,CAAC,EAAE;AAFK,OAAV;AAIArB,MAAAA,SAAS,CAACkB,OAAV,CAAkB,UAAUO,CAAV,EAAaC,CAAb,EAAgB;AAChC,YAAIT,CAAC,KAAKS,CAAV,EAAa;AACX;AACD,SAH+B,CAG9B;;;AAGF,YAAIvB,KAAK,CAACc,CAAD,CAAL,KAAad,KAAK,CAACuB,CAAD,CAAtB,EAA2B;AACzB;AACD;;AAED,YAAIC,IAAI,GAAGH,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAnB;AACA,YAAIG,IAAI,GAAGJ,CAAC,CAAC,CAAD,CAAD,GAAOC,CAAC,CAAC,CAAD,CAAnB;AACA,YAAII,SAAS,GAAGC,IAAI,CAACC,IAAL,CAAUJ,IAAI,GAAGA,IAAP,GAAcC,IAAI,GAAGA,IAA/B,CAAhB;;AAEA,YAAIC,SAAS,KAAK,CAAlB,EAAqB;AACnBA,UAAAA,SAAS,GAAG,CAAZ;AACA,cAAIG,IAAI,GAAGf,CAAC,GAAGS,CAAJ,GAAQ,CAAR,GAAY,CAAC,CAAxB;AACAC,UAAAA,IAAI,GAAG,OAAOK,IAAd;AACAJ,UAAAA,IAAI,GAAG,OAAOI,IAAd;AACD,SAnB+B,CAmB9B;;;AAGF,YAAIH,SAAS,GAAGd,IAAI,CAACN,YAAL,CAAkBG,KAAK,CAACK,CAAD,CAAvB,IAA8B,CAA9B,GAAkCF,IAAI,CAACN,YAAL,CAAkBG,KAAK,CAACc,CAAD,CAAvB,IAA8B,CAAhF,EAAmF;AACjF,cAAIO,MAAM,GAAGvB,CAAC,GAAGA,CAAJ,GAAQmB,SAArB;AACA9B,UAAAA,IAAI,CAACkB,CAAD,CAAJ,CAAQG,CAAR,IAAaO,IAAI,GAAGE,SAAP,GAAmBI,MAAhC;AACAlC,UAAAA,IAAI,CAACkB,CAAD,CAAJ,CAAQI,CAAR,IAAaO,IAAI,GAAGC,SAAP,GAAmBI,MAAhC;AACD;AACF,OA3BD;AA4BD,KAjCD;AAkCD,GAzCD;;AA2CApC,EAAAA,qBAAqB,CAACgB,SAAtB,CAAgCU,eAAhC,GAAkD,YAAY;AAC5D,QAAIR,IAAI,GAAG,IAAX;AACA,QAAIf,SAAS,GAAGe,IAAI,CAACf,SAArB;AACA,QAAID,IAAI,GAAGgB,IAAI,CAAChB,IAAhB;AACA,QAAIQ,KAAK,GAAGQ,IAAI,CAACR,KAAjB;AACA,QAAII,YAAY,GAAGI,IAAI,CAACJ,YAAxB;AACA,QAAIuB,CAAC,GAAGnB,IAAI,CAACb,OAAb;AACA,QAAIc,WAAW,GAAGD,IAAI,CAACC,WAAL,IAAoBD,IAAI,CAACT,KAAL,GAAa,EAAnD;;AAEA,QAAIK,YAAJ,EAAkB;AAChBZ,MAAAA,IAAI,CAACmB,OAAL,CAAa,UAAUiB,EAAV,EAAclB,CAAd,EAAiB;AAC5B,YAAImB,EAAE,GAAGpC,SAAS,CAACiB,CAAD,CAAT,CAAa,CAAb,IAAkBjB,SAAS,CAACkC,CAAD,CAAT,CAAa,CAAb,CAA3B;AACA,YAAIG,EAAE,GAAGrC,SAAS,CAACiB,CAAD,CAAT,CAAa,CAAb,IAAkBjB,SAAS,CAACkC,CAAD,CAAT,CAAa,CAAb,CAA3B;AACA,YAAII,OAAO,GAAGR,IAAI,CAACC,IAAL,CAAUK,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAzB,CAAd;AACA,YAAIE,GAAG,GAAGF,EAAE,GAAGC,OAAf;AACA,YAAIE,GAAG,GAAG,CAACJ,EAAD,GAAME,OAAhB;AACA,YAAIG,QAAQ,GAAGX,IAAI,CAACC,IAAL,CAAUI,EAAE,CAACf,CAAH,GAAOe,EAAE,CAACf,CAAV,GAAce,EAAE,CAACd,CAAH,GAAOc,EAAE,CAACd,CAAlC,CAAf;AACA,YAAIqB,KAAK,GAAGZ,IAAI,CAACa,IAAL,CAAU,CAACJ,GAAG,GAAGJ,EAAE,CAACf,CAAT,GAAaoB,GAAG,GAAGL,EAAE,CAACd,CAAvB,IAA4BoB,QAAtC,CAAZ;;AAEA,YAAIC,KAAK,GAAGZ,IAAI,CAACc,EAAL,GAAU,CAAtB,EAAyB;AACvBF,UAAAA,KAAK,IAAIZ,IAAI,CAACc,EAAL,GAAU,CAAnB;AACAL,UAAAA,GAAG,IAAI,CAAC,CAAR;AACAC,UAAAA,GAAG,IAAI,CAAC,CAAR;AACD;;AAED,YAAIK,WAAW,GAAGf,IAAI,CAACgB,GAAL,CAASJ,KAAT,IAAkBD,QAApC;AACAN,QAAAA,EAAE,CAACf,CAAH,GAAOmB,GAAG,GAAGM,WAAb;AACAV,QAAAA,EAAE,CAACd,CAAH,GAAOmB,GAAG,GAAGK,WAAb;AACD,OAlBD;AAmBD,KA7B2D,CA6B1D;;;AAGF,QAAI1C,KAAK,GAAGY,IAAI,CAACZ,KAAjB;AACAH,IAAAA,SAAS,CAACkB,OAAV,CAAkB,UAAU6B,CAAV,EAAa9B,CAAb,EAAgB;AAChC,UAAIA,CAAC,KAAKiB,CAAV,EAAa;AACX;AACD;;AAED,UAAIc,UAAU,GAAGlB,IAAI,CAACC,IAAL,CAAUhC,IAAI,CAACkB,CAAD,CAAJ,CAAQG,CAAR,GAAYrB,IAAI,CAACkB,CAAD,CAAJ,CAAQG,CAApB,GAAwBrB,IAAI,CAACkB,CAAD,CAAJ,CAAQI,CAAR,GAAYtB,IAAI,CAACkB,CAAD,CAAJ,CAAQI,CAAtD,CAAjB;;AAEA,UAAI2B,UAAU,GAAG,CAAb,IAAkB/B,CAAC,KAAKiB,CAA5B,EAA+B;AAC7B,YAAIe,WAAW,GAAGnB,IAAI,CAACoB,GAAL,CAASlC,WAAW,IAAIT,KAAK,GAAGX,aAAZ,CAApB,EAAgDoD,UAAhD,CAAlB;AACAD,QAAAA,CAAC,CAAC,CAAD,CAAD,IAAQhD,IAAI,CAACkB,CAAD,CAAJ,CAAQG,CAAR,GAAY4B,UAAZ,GAAyBC,WAAjC;AACAF,QAAAA,CAAC,CAAC,CAAD,CAAD,IAAQhD,IAAI,CAACkB,CAAD,CAAJ,CAAQI,CAAR,GAAY2B,UAAZ,GAAyBC,WAAjC;;AAEA,YAAItC,YAAJ,EAAkB;AAChB,cAAIyB,EAAE,GAAGW,CAAC,CAAC,CAAD,CAAD,GAAO/C,SAAS,CAACkC,CAAD,CAAT,CAAa,CAAb,CAAhB;AACA,cAAIG,EAAE,GAAGU,CAAC,CAAC,CAAD,CAAD,GAAO/C,SAAS,CAACkC,CAAD,CAAT,CAAa,CAAb,CAAhB;AACA,cAAIiB,KAAK,GAAGrB,IAAI,CAACC,IAAL,CAAUK,EAAE,GAAGA,EAAL,GAAUC,EAAE,GAAGA,EAAzB,CAAZ;AACAD,UAAAA,EAAE,GAAGA,EAAE,GAAGe,KAAL,GAAahD,KAAK,CAACc,CAAD,CAAvB;AACAoB,UAAAA,EAAE,GAAGA,EAAE,GAAGc,KAAL,GAAahD,KAAK,CAACc,CAAD,CAAvB;AACA8B,UAAAA,CAAC,CAAC,CAAD,CAAD,GAAO/C,SAAS,CAACkC,CAAD,CAAT,CAAa,CAAb,IAAkBE,EAAzB;AACAW,UAAAA,CAAC,CAAC,CAAD,CAAD,GAAO/C,SAAS,CAACkC,CAAD,CAAT,CAAa,CAAb,IAAkBG,EAAzB;AACD;AACF;AACF,KAtBD;AAuBD,GAxDD;;AA0DA,SAAOxC,qBAAP;AACD,CAhJD,EAFA;;AAoJA,eAAeA,qBAAf","sourcesContent":["var SPEED_DIVISOR = 800;\n\nvar RadialNonoverlapForce =\n/** @class */\nfunction () {\n  function RadialNonoverlapForce(params) {\n    this.disp = [];\n    this.positions = params.positions;\n    this.adjMatrix = params.adjMatrix;\n    this.focusID = params.focusID;\n    this.radii = params.radii;\n    this.iterations = params.iterations || 10;\n    this.height = params.height || 10;\n    this.width = params.width || 10;\n    this.speed = params.speed || 100;\n    this.gravity = params.gravity || 10;\n    this.nodeSizeFunc = params.nodeSizeFunc;\n    this.k = params.k || 5;\n    this.strictRadial = params.strictRadial;\n    this.nodes = params.nodes;\n  }\n\n  RadialNonoverlapForce.prototype.layout = function () {\n    var self = this;\n    var positions = self.positions;\n    var disp = [];\n    var iterations = self.iterations;\n    var maxDisplace = self.width / 10;\n    self.maxDisplace = maxDisplace;\n    self.disp = disp;\n\n    for (var i = 0; i < iterations; i++) {\n      positions.forEach(function (_, k) {\n        disp[k] = {\n          x: 0,\n          y: 0\n        };\n      }); // 给重叠的节点增加斥力\n\n      self.getRepulsion();\n      self.updatePositions();\n    }\n\n    return positions;\n  };\n\n  RadialNonoverlapForce.prototype.getRepulsion = function () {\n    var self = this;\n    var positions = self.positions;\n    var nodes = self.nodes;\n    var disp = self.disp;\n    var k = self.k;\n    var radii = self.radii || [];\n    positions.forEach(function (v, i) {\n      disp[i] = {\n        x: 0,\n        y: 0\n      };\n      positions.forEach(function (u, j) {\n        if (i === j) {\n          return;\n        } // v and u are not on the same circle, return\n\n\n        if (radii[i] !== radii[j]) {\n          return;\n        }\n\n        var vecx = v[0] - u[0];\n        var vecy = v[1] - u[1];\n        var vecLength = Math.sqrt(vecx * vecx + vecy * vecy);\n\n        if (vecLength === 0) {\n          vecLength = 1;\n          var sign = i > j ? 1 : -1;\n          vecx = 0.01 * sign;\n          vecy = 0.01 * sign;\n        } // these two nodes overlap\n\n\n        if (vecLength < self.nodeSizeFunc(nodes[i]) / 2 + self.nodeSizeFunc(nodes[j]) / 2) {\n          var common = k * k / vecLength;\n          disp[i].x += vecx / vecLength * common;\n          disp[i].y += vecy / vecLength * common;\n        }\n      });\n    });\n  };\n\n  RadialNonoverlapForce.prototype.updatePositions = function () {\n    var self = this;\n    var positions = self.positions;\n    var disp = self.disp;\n    var speed = self.speed;\n    var strictRadial = self.strictRadial;\n    var f = self.focusID;\n    var maxDisplace = self.maxDisplace || self.width / 10;\n\n    if (strictRadial) {\n      disp.forEach(function (di, i) {\n        var vx = positions[i][0] - positions[f][0];\n        var vy = positions[i][1] - positions[f][1];\n        var vLength = Math.sqrt(vx * vx + vy * vy);\n        var vpx = vy / vLength;\n        var vpy = -vx / vLength;\n        var diLength = Math.sqrt(di.x * di.x + di.y * di.y);\n        var alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);\n\n        if (alpha > Math.PI / 2) {\n          alpha -= Math.PI / 2;\n          vpx *= -1;\n          vpy *= -1;\n        }\n\n        var tdispLength = Math.cos(alpha) * diLength;\n        di.x = vpx * tdispLength;\n        di.y = vpy * tdispLength;\n      });\n    } // move\n\n\n    var radii = self.radii;\n    positions.forEach(function (n, i) {\n      if (i === f) {\n        return;\n      }\n\n      var distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);\n\n      if (distLength > 0 && i !== f) {\n        var limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);\n        n[0] += disp[i].x / distLength * limitedDist;\n        n[1] += disp[i].y / distLength * limitedDist;\n\n        if (strictRadial) {\n          var vx = n[0] - positions[f][0];\n          var vy = n[1] - positions[f][1];\n          var nfDis = Math.sqrt(vx * vx + vy * vy);\n          vx = vx / nfDis * radii[i];\n          vy = vy / nfDis * radii[i];\n          n[0] = positions[f][0] + vx;\n          n[1] = positions[f][1] + vy;\n        }\n      }\n    });\n  };\n\n  return RadialNonoverlapForce;\n}();\n\nexport default RadialNonoverlapForce;"]},"metadata":{},"sourceType":"module"}