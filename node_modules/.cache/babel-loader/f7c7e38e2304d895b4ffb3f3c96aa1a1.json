{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath';\nimport * as graphic from '../../util/graphic';\nimport { setStatesStylesFromModel, enableHoverEmphasis } from '../../util/states';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle';\nimport ChartView from '../../view/Chart';\nimport { parsePercent, round, linearMap } from '../../util/number';\nimport Sausage from '../../util/shape/sausage';\nimport { createSymbol } from '../../util/symbol';\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label);\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(value);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\n\nvar GaugeView = function (_super) {\n  __extends(GaugeView, _super);\n\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GaugeView.type;\n    return _this;\n  }\n\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n    this._data = seriesModel.getData();\n  };\n\n  GaugeView.prototype.dispose = function () {};\n\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle(['color', 'width']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      var i;\n\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      }\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderAnchor(seriesModel, posInfo);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle);\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      }\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: createTextStyle(labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n            align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            inheritColor: autoColor\n          }),\n          silent: true\n        }));\n      }\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer;\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, parsePercent(pointerOffset[0], posInfo.r) - pointerWidth / 2, parsePercent(pointerOffset[1], posInfo.r) - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: parsePercent(pointerModel.get('width'), posInfo.r),\n            r: parsePercent(pointerModel.get('length'), posInfo.r)\n          }\n        });\n      }\n\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle);\n          graphic.initProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          pointer.useStyle(data.getItemVisual(idx, 'style'));\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          enableHoverEmphasis(pointer, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          enableHoverEmphasis(progress, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemTitleModel\n        }, seriesModel.getRawValue(idx), function () {\n          return data.getName(idx);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel);\n        itemGroup.add(labelEl);\n      }\n\n      var itemDetailModel = itemModel.getModel('detail');\n\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, seriesModel.getRawValue(idx), function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel);\n        itemGroup.add(labelEl);\n      }\n\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\n\nChartView.registerClass(GaugeView);\nexport default GaugeView;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/esm/chart/gauge/GaugeView.js"],"names":["__extends","PointerPath","graphic","setStatesStylesFromModel","enableHoverEmphasis","createTextStyle","setLabelValueAnimation","animateLabelValue","ChartView","parsePercent","round","linearMap","Sausage","createSymbol","parsePosition","seriesModel","api","center","get","width","getWidth","height","getHeight","size","Math","min","cx","cy","r","formatLabel","value","labelFormatter","label","replace","PI2","PI","GaugeView","_super","_this","apply","arguments","type","prototype","render","ecModel","group","removeAll","colorList","posInfo","_renderMain","_data","getData","dispose","clockwise","startAngle","endAngle","axisLineModel","getModel","roundCap","MainPath","Sector","showAxis","lineStyleModel","axisLineWidth","angleRangeSpan","prevEndAngle","i","length","percent","max","sector","shape","r0","silent","setStyle","fill","getLineStyle","add","getColor","tmp","_renderTicks","_renderTitleAndDetail","_renderAnchor","_renderPointer","minVal","maxVal","splitLineModel","tickModel","labelModel","splitNumber","subSplitNumber","splitLineLen","tickLen","angle","step","subStep","splitLineStyle","tickLineStyle","splitLineDistance","unitX","unitY","cos","sin","distance","splitLine","Line","x1","y1","x2","y2","style","stroke","autoColor","Text","text","x","y","verticalAlign","align","inheritColor","j","tickLine","oldData","oldProgressData","_progressEls","progressList","showPointer","progressModel","showProgress","data","valueDim","mapDimension","valueExtent","angleExtent","createPointer","idx","itemModel","getItemModel","pointerModel","pointerWidth","pointerLength","pointerStr","pointerOffset","pointerKeepAspect","pointer","rotation","createProgress","ProgressPath","isOverlap","progressWidth","count","progress","z2","diff","initProps","setItemGraphicEl","isClip","update","newIdx","oldIdx","previousPointer","getItemGraphicEl","previousRotate","updateProps","previousProgress","previousEndAngle","execute","each","emphasisModel","useStyle","getItemVisual","getItemStyle","z2EmphasisLift","anchorModel","showAnchor","anchorSize","anchorType","offsetCenter","anchorKeepAspect","anchor","contentGroup","Group","newTitleEls","newDetailEls","hasAnimation","isAnimationEnabled","_titleEls","_detailEls","itemGroup","itemTitleModel","titleOffsetCenter","titleX","titleY","labelEl","attr","getName","normal","getRawValue","itemDetailModel","detailOffsetCenter","detailX","detailY","detailColor","formatter_1","isNaN","registerClass"],"mappings":"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","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath';\nimport * as graphic from '../../util/graphic';\nimport { setStatesStylesFromModel, enableHoverEmphasis } from '../../util/states';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle';\nimport ChartView from '../../view/Chart';\nimport { parsePercent, round, linearMap } from '../../util/number';\nimport Sausage from '../../util/shape/sausage';\nimport { createSymbol } from '../../util/symbol';\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label);\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(value);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\n\nvar GaugeView = function (_super) {\n  __extends(GaugeView, _super);\n\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GaugeView.type;\n    return _this;\n  }\n\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n    this._data = seriesModel.getData();\n  };\n\n  GaugeView.prototype.dispose = function () {};\n\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle(['color', 'width']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      var i;\n\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      }\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderAnchor(seriesModel, posInfo);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle);\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      }\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: createTextStyle(labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n            align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            inheritColor: autoColor\n          }),\n          silent: true\n        }));\n      }\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer;\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, parsePercent(pointerOffset[0], posInfo.r) - pointerWidth / 2, parsePercent(pointerOffset[1], posInfo.r) - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: parsePercent(pointerModel.get('width'), posInfo.r),\n            r: parsePercent(pointerModel.get('length'), posInfo.r)\n          }\n        });\n      }\n\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle);\n          graphic.initProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          pointer.useStyle(data.getItemVisual(idx, 'style'));\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          enableHoverEmphasis(pointer, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          enableHoverEmphasis(progress, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemTitleModel\n        }, seriesModel.getRawValue(idx), function () {\n          return data.getName(idx);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel);\n        itemGroup.add(labelEl);\n      }\n\n      var itemDetailModel = itemModel.getModel('detail');\n\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, seriesModel.getRawValue(idx), function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel);\n        itemGroup.add(labelEl);\n      }\n\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\n\nChartView.registerClass(GaugeView);\nexport default GaugeView;"]},"metadata":{},"sourceType":"module"}