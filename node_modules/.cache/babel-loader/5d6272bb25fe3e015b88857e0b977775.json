{"ast":null,"code":"/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport isArray from '@antv/util/lib/is-array';\nimport isNumber from '@antv/util/lib/is-number';\nimport isString from '@antv/util/lib/is-string';\nimport isFunction from '@antv/util/lib/is-function';\nimport { floydWarshall, getAdjMatrix } from '../../util/math';\nimport { isNaN } from '../../util/base';\nimport { BaseLayout } from '../layout';\nimport MDS from './mds';\nimport RadialNonoverlapForce from './radialNonoverlapForce';\n\nfunction getWeightMatrix(M) {\n  var rows = M.length;\n  var cols = M[0].length;\n  var result = [];\n\n  for (var i = 0; i < rows; i++) {\n    var row = [];\n\n    for (var j = 0; j < cols; j++) {\n      if (M[i][j] !== 0) {\n        row.push(1 / (M[i][j] * M[i][j]));\n      } else {\n        row.push(0);\n      }\n    }\n\n    result.push(row);\n  }\n\n  return result;\n}\n\nfunction getIndexById(array, id) {\n  var index = -1;\n  array.forEach(function (a, i) {\n    if (a.id === id) {\n      index = i;\n    }\n  });\n  return index;\n}\n\nfunction getEDistance(p1, p2) {\n  return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\n}\n/**\n * 辐射状布局\n */\n\n\nvar RadialLayout =\n/** @class */\nfunction (_super) {\n  __extends(RadialLayout, _super);\n\n  function RadialLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 中心点，默认为数据中第一个点 */\n\n    _this.focusNode = null;\n    /** 每一圈半径 */\n\n    _this.unitRadius = null;\n    /** 默认边长度 */\n\n    _this.linkDistance = 50;\n    /** 是否防止重叠 */\n\n    _this.preventOverlap = false;\n    /** 是否必须是严格的 radial 布局，即每一层的节点严格布局在一个环上。preventOverlap 为 true 时生效 */\n\n    _this.strictRadial = true;\n    /** 防止重叠步骤的最大迭代次数 */\n\n    _this.maxPreventOverlapIteration = 200;\n    _this.sortStrength = 10;\n    return _this;\n  }\n\n  RadialLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      maxIteration: 1000,\n      focusNode: null,\n      unitRadius: null,\n      linkDistance: 50,\n      preventOverlap: false,\n      nodeSize: undefined,\n      nodeSpacing: undefined,\n      strictRadial: true,\n      maxPreventOverlapIteration: 200,\n      sortBy: undefined,\n      sortStrength: 10\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  RadialLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var edges = self.edges || [];\n    var center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var linkDistance = self.linkDistance; // layout\n\n    var focusNode = null;\n\n    if (isString(self.focusNode)) {\n      var found = false;\n\n      for (var i = 0; i < nodes.length; i++) {\n        if (nodes[i].id === self.focusNode) {\n          focusNode = nodes[i];\n          self.focusNode = focusNode;\n          found = true;\n          i = nodes.length;\n        }\n      }\n\n      if (!found) {\n        focusNode = null;\n      }\n    } else {\n      focusNode = self.focusNode;\n    } // default focus node\n\n\n    if (!focusNode) {\n      focusNode = nodes[0];\n      self.focusNode = focusNode;\n    } // the index of the focusNode in data\n\n\n    var focusIndex = getIndexById(nodes, focusNode.id);\n    self.focusIndex = focusIndex; // the graph-theoretic distance (shortest path distance) matrix\n\n    var adjMatrix = getAdjMatrix({\n      nodes: nodes,\n      edges: edges\n    }, false);\n    var D = floydWarshall(adjMatrix);\n    var maxDistance = self.maxToFocus(D, focusIndex); // replace first node in unconnected component to the circle at (maxDistance + 1)\n\n    self.handleInfinity(D, focusIndex, maxDistance + 1);\n    self.distances = D; // the shortest path distance from each node to focusNode\n\n    var focusNodeD = D[focusIndex];\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    var width = self.width || 500;\n    var height = self.height || 500;\n    var semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];\n    var semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];\n\n    if (semiWidth === 0) {\n      semiWidth = width / 2;\n    }\n\n    if (semiHeight === 0) {\n      semiHeight = height / 2;\n    } // the maxRadius of the graph\n\n\n    var maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;\n    var maxD = Math.max.apply(Math, focusNodeD); // the radius for each nodes away from focusNode\n\n    var radii = [];\n    focusNodeD.forEach(function (value, i) {\n      if (!self.unitRadius) {\n        self.unitRadius = maxRadius / maxD;\n      }\n\n      radii[i] = value * self.unitRadius;\n    });\n    self.radii = radii;\n    var eIdealD = self.eIdealDisMatrix(); // const eIdealD = scaleMatrix(D, linkDistance);\n\n    self.eIdealDistances = eIdealD; // the weight matrix, Wij = 1 / dij^(-2)\n\n    var W = getWeightMatrix(eIdealD);\n    self.weights = W; // the initial positions from mds\n\n    var mds = new MDS({\n      distances: eIdealD,\n      linkDistance: linkDistance\n    });\n    var positions = mds.layout();\n    positions.forEach(function (p) {\n      if (isNaN(p[0])) {\n        p[0] = Math.random() * linkDistance;\n      }\n\n      if (isNaN(p[1])) {\n        p[1] = Math.random() * linkDistance;\n      }\n    });\n    self.positions = positions;\n    positions.forEach(function (p, i) {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    }); // move the graph to origin, centered at focusNode\n\n    positions.forEach(function (p) {\n      p[0] -= positions[focusIndex][0];\n      p[1] -= positions[focusIndex][1];\n    });\n    self.run();\n    var preventOverlap = self.preventOverlap;\n    var nodeSize = self.nodeSize;\n    var nodeSizeFunc;\n    var strictRadial = self.strictRadial; // stagger the overlapped nodes\n\n    if (preventOverlap) {\n      var nodeSpacing_1 = self.nodeSpacing;\n      var nodeSpacingFunc_1;\n\n      if (isNumber(nodeSpacing_1)) {\n        nodeSpacingFunc_1 = function nodeSpacingFunc_1() {\n          return nodeSpacing_1;\n        };\n      } else if (isFunction(nodeSpacing_1)) {\n        nodeSpacingFunc_1 = nodeSpacing_1;\n      } else {\n        nodeSpacingFunc_1 = function nodeSpacingFunc_1() {\n          return 0;\n        };\n      }\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n              return res + nodeSpacingFunc_1(d);\n            }\n\n            return d.size + nodeSpacingFunc_1(d);\n          }\n\n          return 10 + nodeSpacingFunc_1(d);\n        };\n      } else if (isArray(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n          return res + nodeSpacingFunc_1(d);\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return nodeSize + nodeSpacingFunc_1(d);\n        };\n      }\n\n      var nonoverlapForceParams = {\n        nodeSizeFunc: nodeSizeFunc,\n        adjMatrix: adjMatrix,\n        positions: positions,\n        radii: radii,\n        height: height,\n        width: width,\n        strictRadial: strictRadial,\n        focusID: focusIndex,\n        iterations: self.maxPreventOverlapIteration || 200,\n        k: positions.length / 4.5,\n        nodes: nodes\n      };\n      var nonoverlapForce = new RadialNonoverlapForce(nonoverlapForceParams);\n      positions = nonoverlapForce.layout();\n    } // move the graph to center\n\n\n    positions.forEach(function (p, i) {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n  };\n\n  RadialLayout.prototype.run = function () {\n    var self = this;\n    var maxIteration = self.maxIteration;\n    var positions = self.positions || [];\n    var W = self.weights || [];\n    var eIdealDis = self.eIdealDistances || [];\n    var radii = self.radii || [];\n\n    for (var i = 0; i <= maxIteration; i++) {\n      var param = i / maxIteration;\n      self.oneIteration(param, positions, radii, eIdealDis, W);\n    }\n  };\n\n  RadialLayout.prototype.oneIteration = function (param, positions, radii, D, W) {\n    var self = this;\n    var vparam = 1 - param;\n    var focusIndex = self.focusIndex;\n    positions.forEach(function (v, i) {\n      // v\n      var originDis = getEDistance(v, [0, 0]);\n      var reciODis = originDis === 0 ? 0 : 1 / originDis;\n\n      if (i === focusIndex) {\n        return;\n      }\n\n      var xMolecule = 0;\n      var yMolecule = 0;\n      var denominator = 0;\n      positions.forEach(function (u, j) {\n        // u\n        if (i === j) {\n          return;\n        } // the euclidean distance between v and u\n\n\n        var edis = getEDistance(v, u);\n        var reciEdis = edis === 0 ? 0 : 1 / edis;\n        var idealDis = D[j][i]; // same for x and y\n\n        denominator += W[i][j]; // x\n\n        xMolecule += W[i][j] * (u[0] + idealDis * (v[0] - u[0]) * reciEdis); // y\n\n        yMolecule += W[i][j] * (u[1] + idealDis * (v[1] - u[1]) * reciEdis);\n      });\n      var reciR = radii[i] === 0 ? 0 : 1 / radii[i];\n      denominator *= vparam;\n      denominator += param * reciR * reciR; // x\n\n      xMolecule *= vparam;\n      xMolecule += param * reciR * v[0] * reciODis;\n      v[0] = xMolecule / denominator; // y\n\n      yMolecule *= vparam;\n      yMolecule += param * reciR * v[1] * reciODis;\n      v[1] = yMolecule / denominator;\n    });\n  };\n\n  RadialLayout.prototype.eIdealDisMatrix = function () {\n    var self = this;\n    var nodes = self.nodes;\n    if (!nodes) return [];\n    var D = self.distances;\n    var linkDis = self.linkDistance;\n    var radii = self.radii || [];\n    var unitRadius = self.unitRadius || 50;\n    var result = [];\n\n    if (D) {\n      D.forEach(function (row, i) {\n        var newRow = [];\n        row.forEach(function (v, j) {\n          if (i === j) {\n            newRow.push(0);\n          } else if (radii[i] === radii[j]) {\n            // i and j are on the same circle\n            if (self.sortBy === 'data') {\n              // sort the nodes on the same circle according to the ordering of the data\n              newRow.push(v * (Math.abs(i - j) * self.sortStrength) / (radii[i] / unitRadius));\n            } else if (self.sortBy) {\n              // sort the nodes on the same circle according to the attributes\n              var iValue = nodes[i][self.sortBy] || 0;\n              var jValue = nodes[j][self.sortBy] || 0;\n\n              if (isString(iValue)) {\n                iValue = iValue.charCodeAt(0);\n              }\n\n              if (isString(jValue)) {\n                jValue = jValue.charCodeAt(0);\n              }\n\n              newRow.push(v * (Math.abs(iValue - jValue) * self.sortStrength) / (radii[i] / unitRadius));\n            } else {\n              newRow.push(v * linkDis / (radii[i] / unitRadius));\n            }\n          } else {\n            // i and j are on different circle\n            // i and j are on different circle\n            var link = (linkDis + unitRadius) / 2;\n            newRow.push(v * link);\n          }\n        });\n        result.push(newRow);\n      });\n    }\n\n    return result;\n  };\n\n  RadialLayout.prototype.handleInfinity = function (matrix, focusIndex, step) {\n    var length = matrix.length; // 遍历 matrix 中遍历 focus 对应行\n\n    for (var i = 0; i < length; i++) {\n      // matrix 关注点对应行的 Inf 项\n      if (matrix[focusIndex][i] === Infinity) {\n        matrix[focusIndex][i] = step;\n        matrix[i][focusIndex] = step; // 遍历 matrix 中的 i 行，i 行中非 Inf 项若在 focus 行为 Inf，则替换 focus 行的那个 Inf\n\n        for (var j = 0; j < length; j++) {\n          if (matrix[i][j] !== Infinity && matrix[focusIndex][j] === Infinity) {\n            matrix[focusIndex][j] = step + matrix[i][j];\n            matrix[j][focusIndex] = step + matrix[i][j];\n          }\n        }\n      }\n    } // 处理其他行的 Inf。根据该行对应点与 focus 距离以及 Inf 项点 与 focus 距离，决定替换值\n\n\n    for (var i = 0; i < length; i++) {\n      if (i === focusIndex) {\n        continue;\n      }\n\n      for (var j = 0; j < length; j++) {\n        if (matrix[i][j] === Infinity) {\n          var minus = Math.abs(matrix[focusIndex][i] - matrix[focusIndex][j]);\n          minus = minus === 0 ? 1 : minus;\n          matrix[i][j] = minus;\n        }\n      }\n    }\n  };\n\n  RadialLayout.prototype.maxToFocus = function (matrix, focusIndex) {\n    var max = 0;\n\n    for (var i = 0; i < matrix[focusIndex].length; i++) {\n      if (matrix[focusIndex][i] === Infinity) {\n        continue;\n      }\n\n      max = matrix[focusIndex][i] > max ? matrix[focusIndex][i] : max;\n    }\n\n    return max;\n  };\n\n  return RadialLayout;\n}(BaseLayout);\n\nexport default RadialLayout;","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/g6/es/layout/radial/radial.js"],"names":["__extends","isArray","isNumber","isString","isFunction","floydWarshall","getAdjMatrix","isNaN","BaseLayout","MDS","RadialNonoverlapForce","getWeightMatrix","M","rows","length","cols","result","i","row","j","push","getIndexById","array","id","index","forEach","a","getEDistance","p1","p2","Math","sqrt","RadialLayout","_super","_this","apply","arguments","center","maxIteration","focusNode","unitRadius","linkDistance","preventOverlap","strictRadial","maxPreventOverlapIteration","sortStrength","prototype","getDefaultCfg","nodeSize","undefined","nodeSpacing","sortBy","execute","self","nodes","edges","x","y","found","focusIndex","adjMatrix","D","maxDistance","maxToFocus","handleInfinity","distances","focusNodeD","width","window","innerWidth","height","innerHeight","semiWidth","semiHeight","maxRadius","maxD","max","radii","value","eIdealD","eIdealDisMatrix","eIdealDistances","W","weights","mds","positions","layout","p","random","run","nodeSizeFunc","nodeSpacing_1","nodeSpacingFunc_1","d","size","res","nonoverlapForceParams","focusID","iterations","k","nonoverlapForce","eIdealDis","param","oneIteration","vparam","v","originDis","reciODis","xMolecule","yMolecule","denominator","u","edis","reciEdis","idealDis","reciR","linkDis","newRow","abs","iValue","jValue","charCodeAt","link","matrix","step","Infinity","minus"],"mappings":"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","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { __extends } from \"tslib\";\nimport isArray from '@antv/util/lib/is-array';\nimport isNumber from '@antv/util/lib/is-number';\nimport isString from '@antv/util/lib/is-string';\nimport isFunction from '@antv/util/lib/is-function';\nimport { floydWarshall, getAdjMatrix } from '../../util/math';\nimport { isNaN } from '../../util/base';\nimport { BaseLayout } from '../layout';\nimport MDS from './mds';\nimport RadialNonoverlapForce from './radialNonoverlapForce';\n\nfunction getWeightMatrix(M) {\n  var rows = M.length;\n  var cols = M[0].length;\n  var result = [];\n\n  for (var i = 0; i < rows; i++) {\n    var row = [];\n\n    for (var j = 0; j < cols; j++) {\n      if (M[i][j] !== 0) {\n        row.push(1 / (M[i][j] * M[i][j]));\n      } else {\n        row.push(0);\n      }\n    }\n\n    result.push(row);\n  }\n\n  return result;\n}\n\nfunction getIndexById(array, id) {\n  var index = -1;\n  array.forEach(function (a, i) {\n    if (a.id === id) {\n      index = i;\n    }\n  });\n  return index;\n}\n\nfunction getEDistance(p1, p2) {\n  return Math.sqrt((p1[0] - p2[0]) * (p1[0] - p2[0]) + (p1[1] - p2[1]) * (p1[1] - p2[1]));\n}\n/**\n * 辐射状布局\n */\n\n\nvar RadialLayout =\n/** @class */\nfunction (_super) {\n  __extends(RadialLayout, _super);\n\n  function RadialLayout() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    /** 布局中心 */\n\n\n    _this.center = [0, 0];\n    /** 停止迭代的最大迭代数 */\n\n    _this.maxIteration = 1000;\n    /** 中心点，默认为数据中第一个点 */\n\n    _this.focusNode = null;\n    /** 每一圈半径 */\n\n    _this.unitRadius = null;\n    /** 默认边长度 */\n\n    _this.linkDistance = 50;\n    /** 是否防止重叠 */\n\n    _this.preventOverlap = false;\n    /** 是否必须是严格的 radial 布局，即每一层的节点严格布局在一个环上。preventOverlap 为 true 时生效 */\n\n    _this.strictRadial = true;\n    /** 防止重叠步骤的最大迭代次数 */\n\n    _this.maxPreventOverlapIteration = 200;\n    _this.sortStrength = 10;\n    return _this;\n  }\n\n  RadialLayout.prototype.getDefaultCfg = function () {\n    return {\n      center: [0, 0],\n      maxIteration: 1000,\n      focusNode: null,\n      unitRadius: null,\n      linkDistance: 50,\n      preventOverlap: false,\n      nodeSize: undefined,\n      nodeSpacing: undefined,\n      strictRadial: true,\n      maxPreventOverlapIteration: 200,\n      sortBy: undefined,\n      sortStrength: 10\n    };\n  };\n  /**\n   * 执行布局\n   */\n\n\n  RadialLayout.prototype.execute = function () {\n    var self = this;\n    var nodes = self.nodes;\n    var edges = self.edges || [];\n    var center = self.center;\n\n    if (!nodes || nodes.length === 0) {\n      return;\n    }\n\n    if (nodes.length === 1) {\n      nodes[0].x = center[0];\n      nodes[0].y = center[1];\n      return;\n    }\n\n    var linkDistance = self.linkDistance; // layout\n\n    var focusNode = null;\n\n    if (isString(self.focusNode)) {\n      var found = false;\n\n      for (var i = 0; i < nodes.length; i++) {\n        if (nodes[i].id === self.focusNode) {\n          focusNode = nodes[i];\n          self.focusNode = focusNode;\n          found = true;\n          i = nodes.length;\n        }\n      }\n\n      if (!found) {\n        focusNode = null;\n      }\n    } else {\n      focusNode = self.focusNode;\n    } // default focus node\n\n\n    if (!focusNode) {\n      focusNode = nodes[0];\n      self.focusNode = focusNode;\n    } // the index of the focusNode in data\n\n\n    var focusIndex = getIndexById(nodes, focusNode.id);\n    self.focusIndex = focusIndex; // the graph-theoretic distance (shortest path distance) matrix\n\n    var adjMatrix = getAdjMatrix({\n      nodes: nodes,\n      edges: edges\n    }, false);\n    var D = floydWarshall(adjMatrix);\n    var maxDistance = self.maxToFocus(D, focusIndex); // replace first node in unconnected component to the circle at (maxDistance + 1)\n\n    self.handleInfinity(D, focusIndex, maxDistance + 1);\n    self.distances = D; // the shortest path distance from each node to focusNode\n\n    var focusNodeD = D[focusIndex];\n\n    if (!self.width && typeof window !== 'undefined') {\n      self.width = window.innerWidth;\n    }\n\n    if (!self.height && typeof window !== 'undefined') {\n      self.height = window.innerHeight;\n    }\n\n    var width = self.width || 500;\n    var height = self.height || 500;\n    var semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];\n    var semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];\n\n    if (semiWidth === 0) {\n      semiWidth = width / 2;\n    }\n\n    if (semiHeight === 0) {\n      semiHeight = height / 2;\n    } // the maxRadius of the graph\n\n\n    var maxRadius = semiHeight > semiWidth ? semiWidth : semiHeight;\n    var maxD = Math.max.apply(Math, focusNodeD); // the radius for each nodes away from focusNode\n\n    var radii = [];\n    focusNodeD.forEach(function (value, i) {\n      if (!self.unitRadius) {\n        self.unitRadius = maxRadius / maxD;\n      }\n\n      radii[i] = value * self.unitRadius;\n    });\n    self.radii = radii;\n    var eIdealD = self.eIdealDisMatrix(); // const eIdealD = scaleMatrix(D, linkDistance);\n\n    self.eIdealDistances = eIdealD; // the weight matrix, Wij = 1 / dij^(-2)\n\n    var W = getWeightMatrix(eIdealD);\n    self.weights = W; // the initial positions from mds\n\n    var mds = new MDS({\n      distances: eIdealD,\n      linkDistance: linkDistance\n    });\n    var positions = mds.layout();\n    positions.forEach(function (p) {\n      if (isNaN(p[0])) {\n        p[0] = Math.random() * linkDistance;\n      }\n\n      if (isNaN(p[1])) {\n        p[1] = Math.random() * linkDistance;\n      }\n    });\n    self.positions = positions;\n    positions.forEach(function (p, i) {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    }); // move the graph to origin, centered at focusNode\n\n    positions.forEach(function (p) {\n      p[0] -= positions[focusIndex][0];\n      p[1] -= positions[focusIndex][1];\n    });\n    self.run();\n    var preventOverlap = self.preventOverlap;\n    var nodeSize = self.nodeSize;\n    var nodeSizeFunc;\n    var strictRadial = self.strictRadial; // stagger the overlapped nodes\n\n    if (preventOverlap) {\n      var nodeSpacing_1 = self.nodeSpacing;\n      var nodeSpacingFunc_1;\n\n      if (isNumber(nodeSpacing_1)) {\n        nodeSpacingFunc_1 = function nodeSpacingFunc_1() {\n          return nodeSpacing_1;\n        };\n      } else if (isFunction(nodeSpacing_1)) {\n        nodeSpacingFunc_1 = nodeSpacing_1;\n      } else {\n        nodeSpacingFunc_1 = function nodeSpacingFunc_1() {\n          return 0;\n        };\n      }\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              var res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];\n              return res + nodeSpacingFunc_1(d);\n            }\n\n            return d.size + nodeSpacingFunc_1(d);\n          }\n\n          return 10 + nodeSpacingFunc_1(d);\n        };\n      } else if (isArray(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          var res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];\n          return res + nodeSpacingFunc_1(d);\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          return nodeSize + nodeSpacingFunc_1(d);\n        };\n      }\n\n      var nonoverlapForceParams = {\n        nodeSizeFunc: nodeSizeFunc,\n        adjMatrix: adjMatrix,\n        positions: positions,\n        radii: radii,\n        height: height,\n        width: width,\n        strictRadial: strictRadial,\n        focusID: focusIndex,\n        iterations: self.maxPreventOverlapIteration || 200,\n        k: positions.length / 4.5,\n        nodes: nodes\n      };\n      var nonoverlapForce = new RadialNonoverlapForce(nonoverlapForceParams);\n      positions = nonoverlapForce.layout();\n    } // move the graph to center\n\n\n    positions.forEach(function (p, i) {\n      nodes[i].x = p[0] + center[0];\n      nodes[i].y = p[1] + center[1];\n    });\n  };\n\n  RadialLayout.prototype.run = function () {\n    var self = this;\n    var maxIteration = self.maxIteration;\n    var positions = self.positions || [];\n    var W = self.weights || [];\n    var eIdealDis = self.eIdealDistances || [];\n    var radii = self.radii || [];\n\n    for (var i = 0; i <= maxIteration; i++) {\n      var param = i / maxIteration;\n      self.oneIteration(param, positions, radii, eIdealDis, W);\n    }\n  };\n\n  RadialLayout.prototype.oneIteration = function (param, positions, radii, D, W) {\n    var self = this;\n    var vparam = 1 - param;\n    var focusIndex = self.focusIndex;\n    positions.forEach(function (v, i) {\n      // v\n      var originDis = getEDistance(v, [0, 0]);\n      var reciODis = originDis === 0 ? 0 : 1 / originDis;\n\n      if (i === focusIndex) {\n        return;\n      }\n\n      var xMolecule = 0;\n      var yMolecule = 0;\n      var denominator = 0;\n      positions.forEach(function (u, j) {\n        // u\n        if (i === j) {\n          return;\n        } // the euclidean distance between v and u\n\n\n        var edis = getEDistance(v, u);\n        var reciEdis = edis === 0 ? 0 : 1 / edis;\n        var idealDis = D[j][i]; // same for x and y\n\n        denominator += W[i][j]; // x\n\n        xMolecule += W[i][j] * (u[0] + idealDis * (v[0] - u[0]) * reciEdis); // y\n\n        yMolecule += W[i][j] * (u[1] + idealDis * (v[1] - u[1]) * reciEdis);\n      });\n      var reciR = radii[i] === 0 ? 0 : 1 / radii[i];\n      denominator *= vparam;\n      denominator += param * reciR * reciR; // x\n\n      xMolecule *= vparam;\n      xMolecule += param * reciR * v[0] * reciODis;\n      v[0] = xMolecule / denominator; // y\n\n      yMolecule *= vparam;\n      yMolecule += param * reciR * v[1] * reciODis;\n      v[1] = yMolecule / denominator;\n    });\n  };\n\n  RadialLayout.prototype.eIdealDisMatrix = function () {\n    var self = this;\n    var nodes = self.nodes;\n    if (!nodes) return [];\n    var D = self.distances;\n    var linkDis = self.linkDistance;\n    var radii = self.radii || [];\n    var unitRadius = self.unitRadius || 50;\n    var result = [];\n\n    if (D) {\n      D.forEach(function (row, i) {\n        var newRow = [];\n        row.forEach(function (v, j) {\n          if (i === j) {\n            newRow.push(0);\n          } else if (radii[i] === radii[j]) {\n            // i and j are on the same circle\n            if (self.sortBy === 'data') {\n              // sort the nodes on the same circle according to the ordering of the data\n              newRow.push(v * (Math.abs(i - j) * self.sortStrength) / (radii[i] / unitRadius));\n            } else if (self.sortBy) {\n              // sort the nodes on the same circle according to the attributes\n              var iValue = nodes[i][self.sortBy] || 0;\n              var jValue = nodes[j][self.sortBy] || 0;\n\n              if (isString(iValue)) {\n                iValue = iValue.charCodeAt(0);\n              }\n\n              if (isString(jValue)) {\n                jValue = jValue.charCodeAt(0);\n              }\n\n              newRow.push(v * (Math.abs(iValue - jValue) * self.sortStrength) / (radii[i] / unitRadius));\n            } else {\n              newRow.push(v * linkDis / (radii[i] / unitRadius));\n            }\n          } else {\n            // i and j are on different circle\n            // i and j are on different circle\n            var link = (linkDis + unitRadius) / 2;\n            newRow.push(v * link);\n          }\n        });\n        result.push(newRow);\n      });\n    }\n\n    return result;\n  };\n\n  RadialLayout.prototype.handleInfinity = function (matrix, focusIndex, step) {\n    var length = matrix.length; // 遍历 matrix 中遍历 focus 对应行\n\n    for (var i = 0; i < length; i++) {\n      // matrix 关注点对应行的 Inf 项\n      if (matrix[focusIndex][i] === Infinity) {\n        matrix[focusIndex][i] = step;\n        matrix[i][focusIndex] = step; // 遍历 matrix 中的 i 行，i 行中非 Inf 项若在 focus 行为 Inf，则替换 focus 行的那个 Inf\n\n        for (var j = 0; j < length; j++) {\n          if (matrix[i][j] !== Infinity && matrix[focusIndex][j] === Infinity) {\n            matrix[focusIndex][j] = step + matrix[i][j];\n            matrix[j][focusIndex] = step + matrix[i][j];\n          }\n        }\n      }\n    } // 处理其他行的 Inf。根据该行对应点与 focus 距离以及 Inf 项点 与 focus 距离，决定替换值\n\n\n    for (var i = 0; i < length; i++) {\n      if (i === focusIndex) {\n        continue;\n      }\n\n      for (var j = 0; j < length; j++) {\n        if (matrix[i][j] === Infinity) {\n          var minus = Math.abs(matrix[focusIndex][i] - matrix[focusIndex][j]);\n          minus = minus === 0 ? 1 : minus;\n          matrix[i][j] = minus;\n        }\n      }\n    }\n  };\n\n  RadialLayout.prototype.maxToFocus = function (matrix, focusIndex) {\n    var max = 0;\n\n    for (var i = 0; i < matrix[focusIndex].length; i++) {\n      if (matrix[focusIndex][i] === Infinity) {\n        continue;\n      }\n\n      max = matrix[focusIndex][i] > max ? matrix[focusIndex][i] : max;\n    }\n\n    return max;\n  };\n\n  return RadialLayout;\n}(BaseLayout);\n\nexport default RadialLayout;"]},"metadata":{},"sourceType":"module"}