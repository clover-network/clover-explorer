{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar tslib_1 = require(\"tslib\");\n/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\n\n\nvar g_base_1 = require(\"@antv/g-base\");\n\nvar quadratic_1 = require(\"@antv/g-math/lib/quadratic\");\n\nvar cubic_1 = require(\"@antv/g-math/lib/cubic\");\n\nvar util_1 = require(\"./util\");\n\nvar line_1 = require(\"./in-stroke/line\");\n\nvar arc_1 = require(\"./in-stroke/arc\");\n\nvar matrix_util_1 = require(\"@antv/matrix-util\");\n\nvar vec3 = require(\"gl-matrix/vec3\");\n\nvar transform = matrix_util_1.ext.transform;\n\nfunction hasArc(path) {\n  var hasArc = false;\n  var count = path.length;\n\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n\n    if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n      hasArc = true;\n      break;\n    }\n  }\n\n  return hasArc;\n}\n\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n  var isHit = false;\n  var halfWidth = lineWidth / 2;\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    var currentPoint = segment.currentPoint,\n        params = segment.params,\n        prePoint = segment.prePoint,\n        box = segment.box; // 如果在前面已经生成过包围盒，直接按照包围盒计算\n\n    if (box && !util_1.inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n      continue;\n    }\n\n    switch (segment.command) {\n      // L 和 Z 都是直线， M 不进行拾取\n      case 'L':\n      case 'Z':\n        isHit = line_1.default(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n        break;\n\n      case 'Q':\n        var qDistance = quadratic_1.default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\n        isHit = qDistance <= lineWidth / 2;\n        break;\n\n      case 'C':\n        var cDistance = cubic_1.default.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n        prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n        params[2], params[3], params[4], params[5], params[6], x, y, length);\n        isHit = cDistance <= lineWidth / 2;\n        break;\n\n      case 'A':\n        // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n        var arcParams = segment.arcParams;\n        var cx = arcParams.cx,\n            cy = arcParams.cy,\n            rx = arcParams.rx,\n            ry = arcParams.ry,\n            startAngle = arcParams.startAngle,\n            endAngle = arcParams.endAngle,\n            xRotation = arcParams.xRotation;\n        var p = [x, y, 1];\n        var r = rx > ry ? rx : ry;\n        var scaleX = rx > ry ? 1 : rx / ry;\n        var scaleY = rx > ry ? ry / rx : 1;\n        var m = transform(null, [['t', -cx, -cy], ['r', -xRotation], ['s', 1 / scaleX, 1 / scaleY]]);\n        vec3.transformMat3(p, p, m);\n        isHit = arc_1.default(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n        break;\n\n      default:\n        break;\n    }\n\n    if (isHit) {\n      break;\n    }\n  }\n\n  return isHit;\n}\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\n\n\nfunction extractPolygons(path) {\n  var count = path.length;\n  var polygons = [];\n  var polylines = [];\n  var points = []; // 防止第一个命令不是 'M'\n\n  for (var i = 0; i < count; i++) {\n    var params = path[i];\n    var cmd = params[0];\n\n    if (cmd === 'M') {\n      // 遇到 'M' 判定是否是新数组，新数组中没有点\n      if (points.length) {\n        // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n        polylines.push(points);\n        points = []; // 创建新的点\n      }\n\n      points.push([params[1], params[2]]);\n    } else if (cmd === 'Z') {\n      if (points.length) {\n        // 存在点\n        polygons.push(points);\n        points = []; // 开始新的点集合\n      } // 如果不存在点，同时 'Z'，则说明是错误，不处理\n\n    } else {\n      points.push([params[1], params[2]]);\n    }\n  } // 说明 points 未放入 polygons 或者 polyline\n  // 仅当只有一个 M，没有 Z 时会发生这种情况\n\n\n  if (points.length > 0) {\n    polylines.push(points);\n  }\n\n  return {\n    polygons: polygons,\n    polylines: polylines\n  };\n}\n\nexports.default = tslib_1.__assign({\n  hasArc: hasArc,\n  extractPolygons: extractPolygons,\n  isPointInStroke: isPointInStroke\n}, g_base_1.PathUtil);","map":{"version":3,"sources":["../../src/util/path.ts"],"names":[],"mappings":";;;;;;;AAAA;;;AAGG;;;AACH,IAAA,QAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AACA,IAAA,WAAA,GAAA,OAAA,CAAA,4BAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,wBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA,KAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,aAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA,IAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AAEQ,IAAA,SAAS,GAAK,aAAA,CAAA,GAAA,CAAL,SAAT;;AAER,SAAS,MAAT,CAAgB,IAAhB,EAAoB;AAClB,MAAI,MAAM,GAAG,KAAb;AACA,MAAM,KAAK,GAAG,IAAI,CAAC,MAAnB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,QAAM,MAAM,GAAG,IAAI,CAAC,CAAD,CAAnB;AACA,QAAM,GAAG,GAAG,MAAM,CAAC,CAAD,CAAlB;;AACA,QAAI,GAAG,KAAK,GAAR,IAAe,GAAG,KAAK,GAAvB,IAA8B,GAAG,KAAK,GAA1C,EAA+C;AAC7C,MAAA,MAAM,GAAG,IAAT;AACA;AACD;AACF;;AACD,SAAO,MAAP;AACD;;AAED,SAAS,eAAT,CAAyB,QAAzB,EAAmC,SAAnC,EAA8C,CAA9C,EAAiD,CAAjD,EAAoD,MAApD,EAA0D;AACxD,MAAI,KAAK,GAAG,KAAZ;AACA,MAAM,SAAS,GAAG,SAAS,GAAG,CAA9B;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,EAAtC,EAA0C;AACxC,QAAM,OAAO,GAAG,QAAQ,CAAC,CAAD,CAAxB;AACQ,QAAA,YAAY,GAA4B,OAAO,CAAnC,YAAZ;AAAA,QAAc,MAAM,GAAoB,OAAO,CAA3B,MAApB;AAAA,QAAsB,QAAQ,GAAU,OAAO,CAAjB,QAA9B;AAAA,QAAgC,GAAG,GAAK,OAAO,CAAZ,GAAnC,CAFgC,CAGxC;;AACA,QAAI,GAAG,IAAI,CAAC,MAAA,CAAA,KAAA,CAAM,GAAG,CAAC,CAAJ,GAAQ,SAAd,EAAyB,GAAG,CAAC,CAAJ,GAAQ,SAAjC,EAA4C,GAAG,CAAC,KAAJ,GAAY,SAAxD,EAAmE,GAAG,CAAC,MAAJ,GAAa,SAAhF,EAA2F,CAA3F,EAA8F,CAA9F,CAAZ,EAA8G;AAC5G;AACD;;AACD,YAAQ,OAAO,CAAC,OAAhB;AACE;AACA,WAAK,GAAL;AACA,WAAK,GAAL;AACE,QAAA,KAAK,GAAG,MAAA,CAAA,OAAA,CAAO,QAAQ,CAAC,CAAD,CAAf,EAAoB,QAAQ,CAAC,CAAD,CAA5B,EAAiC,YAAY,CAAC,CAAD,CAA7C,EAAkD,YAAY,CAAC,CAAD,CAA9D,EAAmE,SAAnE,EAA8E,CAA9E,EAAiF,CAAjF,CAAR;AACA;;AACF,WAAK,GAAL;AACE,YAAM,SAAS,GAAG,WAAA,CAAA,OAAA,CAAS,aAAT,CAChB,QAAQ,CAAC,CAAD,CADQ,EAEhB,QAAQ,CAAC,CAAD,CAFQ,EAGhB,MAAM,CAAC,CAAD,CAHU,EAIhB,MAAM,CAAC,CAAD,CAJU,EAKhB,MAAM,CAAC,CAAD,CALU,EAMhB,MAAM,CAAC,CAAD,CANU,EAOhB,CAPgB,EAQhB,CARgB,CAAlB;AAUA,QAAA,KAAK,GAAG,SAAS,IAAI,SAAS,GAAG,CAAjC;AACA;;AACF,WAAK,GAAL;AACE,YAAM,SAAS,GAAG,OAAA,CAAA,OAAA,CAAU,aAAV,CAChB,QAAQ,CAAC,CAAD,CADQ,EACH;AACb,QAAA,QAAQ,CAAC,CAAD,CAFQ,EAGhB,MAAM,CAAC,CAAD,CAHU,EAGL;AACX,QAAA,MAAM,CAAC,CAAD,CAJU,EAKhB,MAAM,CAAC,CAAD,CALU,EAMhB,MAAM,CAAC,CAAD,CANU,EAOhB,MAAM,CAAC,CAAD,CAPU,EAQhB,MAAM,CAAC,CAAD,CARU,EAShB,CATgB,EAUhB,CAVgB,EAWhB,MAXgB,CAAlB;AAaA,QAAA,KAAK,GAAG,SAAS,IAAI,SAAS,GAAG,CAAjC;AACA;;AACF,WAAK,GAAL;AACE;AACA,YAAM,SAAS,GAAG,OAAO,CAAC,SAA1B;AACQ,YAAA,EAAE,GAAkD,SAAS,CAA3D,EAAF;AAAA,YAAI,EAAE,GAA8C,SAAS,CAAvD,EAAN;AAAA,YAAQ,EAAE,GAA0C,SAAS,CAAnD,EAAV;AAAA,YAAY,EAAE,GAAsC,SAAS,CAA/C,EAAd;AAAA,YAAgB,UAAU,GAA0B,SAAS,CAAnC,UAA1B;AAAA,YAA4B,QAAQ,GAAgB,SAAS,CAAzB,QAApC;AAAA,YAAsC,SAAS,GAAK,SAAS,CAAd,SAA/C;AACR,YAAM,CAAC,GAAG,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAAV;AACA,YAAM,CAAC,GAAG,EAAE,GAAG,EAAL,GAAU,EAAV,GAAe,EAAzB;AACA,YAAM,MAAM,GAAG,EAAE,GAAG,EAAL,GAAU,CAAV,GAAc,EAAE,GAAG,EAAlC;AACA,YAAM,MAAM,GAAG,EAAE,GAAG,EAAL,GAAU,EAAE,GAAG,EAAf,GAAoB,CAAnC;AACA,YAAM,CAAC,GAAG,SAAS,CAAC,IAAD,EAAO,CACxB,CAAC,GAAD,EAAM,CAAC,EAAP,EAAW,CAAC,EAAZ,CADwB,EAExB,CAAC,GAAD,EAAM,CAAC,SAAP,CAFwB,EAGxB,CAAC,GAAD,EAAM,IAAI,MAAV,EAAkB,IAAI,MAAtB,CAHwB,CAAP,CAAnB;AAKA,QAAA,IAAI,CAAC,aAAL,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB;AACA,QAAA,KAAK,GAAG,KAAA,CAAA,OAAA,CAAM,CAAN,EAAS,CAAT,EAAY,CAAZ,EAAe,UAAf,EAA2B,QAA3B,EAAqC,SAArC,EAAgD,CAAC,CAAC,CAAD,CAAjD,EAAsD,CAAC,CAAC,CAAD,CAAvD,CAAR;AACA;;AACF;AACE;AApDJ;;AAsDA,QAAI,KAAJ,EAAW;AACT;AACD;AACF;;AACD,SAAO,KAAP;AACD;AAED;;;;AAIG;;;AACH,SAAS,eAAT,CAAyB,IAAzB,EAA6B;AAC3B,MAAM,KAAK,GAAG,IAAI,CAAC,MAAnB;AACA,MAAM,QAAQ,GAAG,EAAjB;AACA,MAAM,SAAS,GAAG,EAAlB;AACA,MAAI,MAAM,GAAG,EAAb,CAJ2B,CAIV;;AACjB,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,KAApB,EAA2B,CAAC,EAA5B,EAAgC;AAC9B,QAAM,MAAM,GAAG,IAAI,CAAC,CAAD,CAAnB;AACA,QAAM,GAAG,GAAG,MAAM,CAAC,CAAD,CAAlB;;AACA,QAAI,GAAG,KAAK,GAAZ,EAAiB;AACf;AACA,UAAI,MAAM,CAAC,MAAX,EAAmB;AACjB;AACA,QAAA,SAAS,CAAC,IAAV,CAAe,MAAf;AACA,QAAA,MAAM,GAAG,EAAT,CAHiB,CAGJ;AACd;;AACD,MAAA,MAAM,CAAC,IAAP,CAAY,CAAC,MAAM,CAAC,CAAD,CAAP,EAAY,MAAM,CAAC,CAAD,CAAlB,CAAZ;AACD,KARD,MAQO,IAAI,GAAG,KAAK,GAAZ,EAAiB;AACtB,UAAI,MAAM,CAAC,MAAX,EAAmB;AACjB;AACA,QAAA,QAAQ,CAAC,IAAT,CAAc,MAAd;AACA,QAAA,MAAM,GAAG,EAAT,CAHiB,CAGJ;AACd,OALqB,CAMtB;;AACD,KAPM,MAOA;AACL,MAAA,MAAM,CAAC,IAAP,CAAY,CAAC,MAAM,CAAC,CAAD,CAAP,EAAY,MAAM,CAAC,CAAD,CAAlB,CAAZ;AACD;AACF,GA1B0B,CA2B3B;AACA;;;AACA,MAAI,MAAM,CAAC,MAAP,GAAgB,CAApB,EAAuB;AACrB,IAAA,SAAS,CAAC,IAAV,CAAe,MAAf;AACD;;AACD,SAAO;AACL,IAAA,QAAQ,EAAA,QADH;AAEL,IAAA,SAAS,EAAA;AAFJ,GAAP;AAID;;AAED,OAAA,CAAA,OAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AACE,EAAA,MAAM,EAAA,MADR;AAEE,EAAA,eAAe,EAAA,eAFjB;AAGE,EAAA,eAAe,EAAA;AAHjB,CAAA,EAIK,QAAA,CAAA,QAJL,CAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\n/**\n * @fileoverview path 的一些工具\n * @author dxq613@gmail.com\n */\nvar g_base_1 = require(\"@antv/g-base\");\nvar quadratic_1 = require(\"@antv/g-math/lib/quadratic\");\nvar cubic_1 = require(\"@antv/g-math/lib/cubic\");\nvar util_1 = require(\"./util\");\nvar line_1 = require(\"./in-stroke/line\");\nvar arc_1 = require(\"./in-stroke/arc\");\nvar matrix_util_1 = require(\"@antv/matrix-util\");\nvar vec3 = require(\"gl-matrix/vec3\");\nvar transform = matrix_util_1.ext.transform;\nfunction hasArc(path) {\n    var hasArc = false;\n    var count = path.length;\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'C' || cmd === 'A' || cmd === 'Q') {\n            hasArc = true;\n            break;\n        }\n    }\n    return hasArc;\n}\nfunction isPointInStroke(segments, lineWidth, x, y, length) {\n    var isHit = false;\n    var halfWidth = lineWidth / 2;\n    for (var i = 0; i < segments.length; i++) {\n        var segment = segments[i];\n        var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box = segment.box;\n        // 如果在前面已经生成过包围盒，直接按照包围盒计算\n        if (box && !util_1.inBox(box.x - halfWidth, box.y - halfWidth, box.width + lineWidth, box.height + lineWidth, x, y)) {\n            continue;\n        }\n        switch (segment.command) {\n            // L 和 Z 都是直线， M 不进行拾取\n            case 'L':\n            case 'Z':\n                isHit = line_1.default(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);\n                break;\n            case 'Q':\n                var qDistance = quadratic_1.default.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);\n                isHit = qDistance <= lineWidth / 2;\n                break;\n            case 'C':\n                var cDistance = cubic_1.default.pointDistance(prePoint[0], // 上一段结束位置, 即 C 的起始点\n                prePoint[1], params[1], // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点\n                params[2], params[3], params[4], params[5], params[6], x, y, length);\n                isHit = cDistance <= lineWidth / 2;\n                break;\n            case 'A':\n                // 计算点到椭圆圆弧的距离，暂时使用近似算法，后面可以改成切割法求最近距离\n                var arcParams = segment.arcParams;\n                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;\n                var p = [x, y, 1];\n                var r = rx > ry ? rx : ry;\n                var scaleX = rx > ry ? 1 : rx / ry;\n                var scaleY = rx > ry ? ry / rx : 1;\n                var m = transform(null, [\n                    ['t', -cx, -cy],\n                    ['r', -xRotation],\n                    ['s', 1 / scaleX, 1 / scaleY],\n                ]);\n                vec3.transformMat3(p, p, m);\n                isHit = arc_1.default(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);\n                break;\n            default:\n                break;\n        }\n        if (isHit) {\n            break;\n        }\n    }\n    return isHit;\n}\n/**\n * 提取出内部的闭合多边形和非闭合的多边形，假设 path 不存在圆弧\n * @param {Array} path 路径\n * @returns {Array} 点的集合\n */\nfunction extractPolygons(path) {\n    var count = path.length;\n    var polygons = [];\n    var polylines = [];\n    var points = []; // 防止第一个命令不是 'M'\n    for (var i = 0; i < count; i++) {\n        var params = path[i];\n        var cmd = params[0];\n        if (cmd === 'M') {\n            // 遇到 'M' 判定是否是新数组，新数组中没有点\n            if (points.length) {\n                // 如果存在点，则说明没有遇到 'Z'，开始了一个新的多边形\n                polylines.push(points);\n                points = []; // 创建新的点\n            }\n            points.push([params[1], params[2]]);\n        }\n        else if (cmd === 'Z') {\n            if (points.length) {\n                // 存在点\n                polygons.push(points);\n                points = []; // 开始新的点集合\n            }\n            // 如果不存在点，同时 'Z'，则说明是错误，不处理\n        }\n        else {\n            points.push([params[1], params[2]]);\n        }\n    }\n    // 说明 points 未放入 polygons 或者 polyline\n    // 仅当只有一个 M，没有 Z 时会发生这种情况\n    if (points.length > 0) {\n        polylines.push(points);\n    }\n    return {\n        polygons: polygons,\n        polylines: polylines,\n    };\n}\nexports.default = tslib_1.__assign({ hasArc: hasArc,\n    extractPolygons: extractPolygons,\n    isPointInStroke: isPointInStroke }, g_base_1.PathUtil);\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"script"}