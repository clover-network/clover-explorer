{"ast":null,"code":"// wrap tree node\n// TODO considering size\nvar util = require('../util');\n\nfunction WrappedTree(height, children) {\n  if (height === void 0) {\n    height = 0;\n  }\n\n  if (children === void 0) {\n    children = [];\n  }\n\n  var me = this;\n  me.x = me.y = 0;\n  me.leftChild = me.rightChild = null;\n  me.height = 0;\n  me.children = children;\n}\n\nvar DEFAULT_OPTIONS = {\n  isHorizontal: true,\n  nodeSep: 20,\n  nodeSize: 20,\n  rankSep: 200,\n  subTreeSep: 10\n};\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.x = converted.x;\n    root.y = converted.y;\n  } else {\n    root.x = converted.y;\n    root.y = converted.x;\n  }\n\n  converted.children.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var maxDepth = 0;\n\n  function wrappedTreeFromNode(n) {\n    if (!n) return null;\n    n.width = 0;\n\n    if (n.depth && n.depth > maxDepth) {\n      maxDepth = n.depth; // get the max depth\n    }\n\n    var children = n.children;\n    var childrenCount = children.length;\n    var t = new WrappedTree(n.height, []);\n    children.forEach(function (child, i) {\n      var childWT = wrappedTreeFromNode(child);\n      t.children.push(childWT);\n\n      if (i === 0) {\n        // t.leftChild = childWT.leftChild ? childWT.leftChild : childWT\n        t.leftChild = childWT;\n      }\n\n      if (i === childrenCount - 1) {\n        // t.rightChild = childWT.rightChild ? childWT.rightChild : childWT\n        t.rightChild = childWT;\n      }\n    });\n    t.originNode = n;\n    t.isLeaf = n.isLeaf();\n    return t;\n  }\n\n  function getDrawingDepth(t) {\n    if (t.isLeaf || t.children.length === 0) {\n      t.drawingDepth = maxDepth;\n    } else {\n      var depths = t.children.map(function (child) {\n        return getDrawingDepth(child);\n      });\n      var minChildDepth = Math.min.apply(null, depths);\n      t.drawingDepth = minChildDepth - 1;\n    }\n\n    return t.drawingDepth;\n  }\n\n  var prevLeaf;\n\n  function position(t) {\n    t.x = t.drawingDepth * options.rankSep;\n\n    if (t.isLeaf) {\n      t.y = 0;\n\n      if (prevLeaf) {\n        t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\n\n        if (t.originNode.parent !== prevLeaf.originNode.parent) {\n          t.y += options.subTreeSep;\n        }\n      }\n\n      prevLeaf = t;\n    } else {\n      t.children.forEach(function (child) {\n        position(child);\n      });\n      t.y = (t.leftChild.y + t.rightChild.y) / 2;\n    }\n  } // wrap node\n\n\n  var wt = wrappedTreeFromNode(root); // get depth for drawing\n\n  getDrawingDepth(wt); // get position\n\n  position(wt); // get x, y\n\n  convertBack(wt, root, options.isHorizontal);\n  return root;\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/@antv/hierarchy/lib/layout/dendrogram.js"],"names":["util","require","WrappedTree","height","children","me","x","y","leftChild","rightChild","DEFAULT_OPTIONS","isHorizontal","nodeSep","nodeSize","rankSep","subTreeSep","convertBack","converted","root","forEach","child","i","module","exports","options","assign","maxDepth","wrappedTreeFromNode","n","width","depth","childrenCount","length","t","childWT","push","originNode","isLeaf","getDrawingDepth","drawingDepth","depths","map","minChildDepth","Math","min","apply","prevLeaf","position","parent","wt"],"mappings":"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","sourcesContent":["// wrap tree node\n// TODO considering size\nvar util = require('../util');\n\nfunction WrappedTree(height, children) {\n  if (height === void 0) {\n    height = 0;\n  }\n\n  if (children === void 0) {\n    children = [];\n  }\n\n  var me = this;\n  me.x = me.y = 0;\n  me.leftChild = me.rightChild = null;\n  me.height = 0;\n  me.children = children;\n}\n\nvar DEFAULT_OPTIONS = {\n  isHorizontal: true,\n  nodeSep: 20,\n  nodeSize: 20,\n  rankSep: 200,\n  subTreeSep: 10\n};\n\nfunction convertBack(converted\n/* WrappedTree */\n, root\n/* TreeNode */\n, isHorizontal) {\n  if (isHorizontal) {\n    root.x = converted.x;\n    root.y = converted.y;\n  } else {\n    root.x = converted.y;\n    root.y = converted.x;\n  }\n\n  converted.children.forEach(function (child, i) {\n    convertBack(child, root.children[i], isHorizontal);\n  });\n}\n\nmodule.exports = function (root, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  options = util.assign({}, DEFAULT_OPTIONS, options);\n  var maxDepth = 0;\n\n  function wrappedTreeFromNode(n) {\n    if (!n) return null;\n    n.width = 0;\n\n    if (n.depth && n.depth > maxDepth) {\n      maxDepth = n.depth; // get the max depth\n    }\n\n    var children = n.children;\n    var childrenCount = children.length;\n    var t = new WrappedTree(n.height, []);\n    children.forEach(function (child, i) {\n      var childWT = wrappedTreeFromNode(child);\n      t.children.push(childWT);\n\n      if (i === 0) {\n        // t.leftChild = childWT.leftChild ? childWT.leftChild : childWT\n        t.leftChild = childWT;\n      }\n\n      if (i === childrenCount - 1) {\n        // t.rightChild = childWT.rightChild ? childWT.rightChild : childWT\n        t.rightChild = childWT;\n      }\n    });\n    t.originNode = n;\n    t.isLeaf = n.isLeaf();\n    return t;\n  }\n\n  function getDrawingDepth(t) {\n    if (t.isLeaf || t.children.length === 0) {\n      t.drawingDepth = maxDepth;\n    } else {\n      var depths = t.children.map(function (child) {\n        return getDrawingDepth(child);\n      });\n      var minChildDepth = Math.min.apply(null, depths);\n      t.drawingDepth = minChildDepth - 1;\n    }\n\n    return t.drawingDepth;\n  }\n\n  var prevLeaf;\n\n  function position(t) {\n    t.x = t.drawingDepth * options.rankSep;\n\n    if (t.isLeaf) {\n      t.y = 0;\n\n      if (prevLeaf) {\n        t.y = prevLeaf.y + prevLeaf.height + options.nodeSep;\n\n        if (t.originNode.parent !== prevLeaf.originNode.parent) {\n          t.y += options.subTreeSep;\n        }\n      }\n\n      prevLeaf = t;\n    } else {\n      t.children.forEach(function (child) {\n        position(child);\n      });\n      t.y = (t.leftChild.y + t.rightChild.y) / 2;\n    }\n  } // wrap node\n\n\n  var wt = wrappedTreeFromNode(root); // get depth for drawing\n\n  getDrawingDepth(wt); // get position\n\n  position(wt); // get x, y\n\n  convertBack(wt, root, options.isHorizontal);\n  return root;\n};"]},"metadata":{},"sourceType":"script"}