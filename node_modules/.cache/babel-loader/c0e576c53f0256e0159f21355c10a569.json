{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\nimport { createHashMap, isString, isArray, each, assert } from 'zrender/esm/core/util';\nimport { parseXML } from 'zrender/esm/tool/parseSVG';\nvar storage = createHashMap();\nexport default {\n  registerMap: function (mapName, rawDef, rawSpecialAreas) {\n    var records;\n\n    if (isArray(rawDef)) {\n      records = rawDef;\n    } else if (rawDef.svg) {\n      records = [{\n        type: 'svg',\n        source: rawDef.svg,\n        specialAreas: rawDef.specialAreas\n      }];\n    } else {\n      var geoSource = rawDef.geoJson || rawDef.geoJSON;\n\n      if (geoSource && !rawDef.features) {\n        rawSpecialAreas = rawDef.specialAreas;\n        rawDef = geoSource;\n      }\n\n      records = [{\n        type: 'geoJSON',\n        source: rawDef,\n        specialAreas: rawSpecialAreas\n      }];\n    }\n\n    each(records, function (record) {\n      var type = record.type;\n      type === 'geoJson' && (type = record.type = 'geoJSON');\n      var parse = parsers[type];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(parse, 'Illegal map type: ' + type);\n      }\n\n      parse(record);\n    });\n    return storage.set(mapName, records);\n  },\n  retrieveMap: function (mapName) {\n    return storage.get(mapName);\n  }\n};\nvar parsers = {\n  geoJSON: function (record) {\n    var source = record.source;\n    record.geoJSON = !isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();\n  },\n  svg: function (record) {\n    record.svgXML = parseXML(record.source);\n  }\n};","map":{"version":3,"sources":["/Users/wanglijie/wanglijie/clover-defi-wallet/node_modules/echarts/esm/coord/geo/mapDataStorage.js"],"names":["createHashMap","isString","isArray","each","assert","parseXML","storage","registerMap","mapName","rawDef","rawSpecialAreas","records","svg","type","source","specialAreas","geoSource","geoJson","geoJSON","features","record","parse","parsers","process","env","NODE_ENV","set","retrieveMap","get","JSON","Function","svgXML"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AAEA,SAASA,aAAT,EAAwBC,QAAxB,EAAkCC,OAAlC,EAA2CC,IAA3C,EAAiDC,MAAjD,QAA+D,uBAA/D;AACA,SAASC,QAAT,QAAyB,2BAAzB;AACA,IAAIC,OAAO,GAAGN,aAAa,EAA3B;AACA,eAAe;AACbO,EAAAA,WAAW,EAAE,UAAUC,OAAV,EAAmBC,MAAnB,EAA2BC,eAA3B,EAA4C;AACvD,QAAIC,OAAJ;;AAEA,QAAIT,OAAO,CAACO,MAAD,CAAX,EAAqB;AACnBE,MAAAA,OAAO,GAAGF,MAAV;AACD,KAFD,MAEO,IAAIA,MAAM,CAACG,GAAX,EAAgB;AACrBD,MAAAA,OAAO,GAAG,CAAC;AACTE,QAAAA,IAAI,EAAE,KADG;AAETC,QAAAA,MAAM,EAAEL,MAAM,CAACG,GAFN;AAGTG,QAAAA,YAAY,EAAEN,MAAM,CAACM;AAHZ,OAAD,CAAV;AAKD,KANM,MAMA;AACL,UAAIC,SAAS,GAAGP,MAAM,CAACQ,OAAP,IAAkBR,MAAM,CAACS,OAAzC;;AAEA,UAAIF,SAAS,IAAI,CAACP,MAAM,CAACU,QAAzB,EAAmC;AACjCT,QAAAA,eAAe,GAAGD,MAAM,CAACM,YAAzB;AACAN,QAAAA,MAAM,GAAGO,SAAT;AACD;;AAEDL,MAAAA,OAAO,GAAG,CAAC;AACTE,QAAAA,IAAI,EAAE,SADG;AAETC,QAAAA,MAAM,EAAEL,MAFC;AAGTM,QAAAA,YAAY,EAAEL;AAHL,OAAD,CAAV;AAKD;;AAEDP,IAAAA,IAAI,CAACQ,OAAD,EAAU,UAAUS,MAAV,EAAkB;AAC9B,UAAIP,IAAI,GAAGO,MAAM,CAACP,IAAlB;AACAA,MAAAA,IAAI,KAAK,SAAT,KAAuBA,IAAI,GAAGO,MAAM,CAACP,IAAP,GAAc,SAA5C;AACA,UAAIQ,KAAK,GAAGC,OAAO,CAACT,IAAD,CAAnB;;AAEA,UAAIU,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACzCrB,QAAAA,MAAM,CAACiB,KAAD,EAAQ,uBAAuBR,IAA/B,CAAN;AACD;;AAEDQ,MAAAA,KAAK,CAACD,MAAD,CAAL;AACD,KAVG,CAAJ;AAWA,WAAOd,OAAO,CAACoB,GAAR,CAAYlB,OAAZ,EAAqBG,OAArB,CAAP;AACD,GAvCY;AAwCbgB,EAAAA,WAAW,EAAE,UAAUnB,OAAV,EAAmB;AAC9B,WAAOF,OAAO,CAACsB,GAAR,CAAYpB,OAAZ,CAAP;AACD;AA1CY,CAAf;AA4CA,IAAIc,OAAO,GAAG;AACZJ,EAAAA,OAAO,EAAE,UAAUE,MAAV,EAAkB;AACzB,QAAIN,MAAM,GAAGM,MAAM,CAACN,MAApB;AACAM,IAAAA,MAAM,CAACF,OAAP,GAAiB,CAACjB,QAAQ,CAACa,MAAD,CAAT,GAAoBA,MAApB,GAA6B,OAAOe,IAAP,KAAgB,WAAhB,IAA+BA,IAAI,CAACR,KAApC,GAA4CQ,IAAI,CAACR,KAAL,CAAWP,MAAX,CAA5C,GAAiE,IAAIgB,QAAJ,CAAa,aAAahB,MAAb,GAAsB,IAAnC,GAA/G;AACD,GAJW;AAKZF,EAAAA,GAAG,EAAE,UAAUQ,MAAV,EAAkB;AACrBA,IAAAA,MAAM,CAACW,MAAP,GAAgB1B,QAAQ,CAACe,MAAM,CAACN,MAAR,CAAxB;AACD;AAPW,CAAd","sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\nimport { createHashMap, isString, isArray, each, assert } from 'zrender/esm/core/util';\nimport { parseXML } from 'zrender/esm/tool/parseSVG';\nvar storage = createHashMap();\nexport default {\n  registerMap: function (mapName, rawDef, rawSpecialAreas) {\n    var records;\n\n    if (isArray(rawDef)) {\n      records = rawDef;\n    } else if (rawDef.svg) {\n      records = [{\n        type: 'svg',\n        source: rawDef.svg,\n        specialAreas: rawDef.specialAreas\n      }];\n    } else {\n      var geoSource = rawDef.geoJson || rawDef.geoJSON;\n\n      if (geoSource && !rawDef.features) {\n        rawSpecialAreas = rawDef.specialAreas;\n        rawDef = geoSource;\n      }\n\n      records = [{\n        type: 'geoJSON',\n        source: rawDef,\n        specialAreas: rawSpecialAreas\n      }];\n    }\n\n    each(records, function (record) {\n      var type = record.type;\n      type === 'geoJson' && (type = record.type = 'geoJSON');\n      var parse = parsers[type];\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(parse, 'Illegal map type: ' + type);\n      }\n\n      parse(record);\n    });\n    return storage.set(mapName, records);\n  },\n  retrieveMap: function (mapName) {\n    return storage.get(mapName);\n  }\n};\nvar parsers = {\n  geoJSON: function (record) {\n    var source = record.source;\n    record.geoJSON = !isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')();\n  },\n  svg: function (record) {\n    record.svgXML = parseXML(record.source);\n  }\n};"]},"metadata":{},"sourceType":"module"}