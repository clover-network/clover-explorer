"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.customIconNode = void 0;
var es_1 = __importDefault(require("@antv/g6/es"));
es_1.default.registerNode('card-node', {
    draw: function (cfg, group) {
        var color = cfg && cfg.color ? cfg.color : '#5B8FF9';
        var size = cfg && cfg.size ? cfg.size : [100, 30];
        if (typeof size === 'number')
            size = [size, size];
        var style = cfg && cfg.style ? cfg.style : {};
        style = Object.assign({ radius: 2, fill: '#fff' }, style);
        color = style.stroke || '#5B8FF9';
        var r = style.radius || 0;
        var shape = group.addShape('rect', {
            attrs: __assign({ x: -size[0] / 2, y: -size[1] / 2, width: size[0], height: size[1], stroke: color }, style),
            name: 'main-box',
            draggable: true,
        });
        // title text
        var title = cfg.title || cfg.label;
        var titleTextShape;
        var labelStyle = cfg && cfg.labelCfg && cfg.labelCfg.style ? cfg.labelCfg.style : {};
        if (title) {
            var titleStyle = Object.assign({ fill: '#fff' }, labelStyle);
            titleTextShape = group.addShape('text', {
                attrs: __assign(__assign({ textBaseline: 'top', x: -size[0] / 2 + 8, y: -size[1] / 2 + 2, 
                    // lineHeight: 20,
                    text: title }, titleStyle), { fill: '#fff' }),
                name: 'title',
            });
        }
        var titleBox = titleTextShape ? titleTextShape.getBBox() : { height: size[1] / 2 };
        // title rect
        var titleRectShape = group.addShape('rect', {
            attrs: {
                x: -size[0] / 2,
                y: -size[1] / 2,
                width: size[0],
                height: titleBox.height + 4,
                fill: color,
                radius: [r, r, 0, 0],
            },
            name: 'title-rect',
            draggable: true,
        });
        titleTextShape && titleTextShape.toFront();
        // marker
        var markerShape;
        if (cfg.children) {
            markerShape = group.addShape('marker', {
                attrs: {
                    x: size[0] / 2,
                    y: 0,
                    r: 6,
                    cursor: 'pointer',
                    symbol: cfg.collapsed ? es_1.default.Marker.expand : es_1.default.Marker.collapse,
                    stroke: color,
                    lineWidth: 1,
                    fill: '#fff',
                },
                name: 'collapse-icon',
            });
        }
        // description
        var description = cfg && cfg.description ? cfg.description : undefined;
        var titleRectBox = titleRectShape.getBBox();
        var descriptionTextShape;
        if (description) {
            descriptionTextShape = group.addShape('text', {
                attrs: __assign({ textBaseline: 'top', x: -size[0] / 2 + 8, y: -size[1] / 2 + titleRectBox.height + 8, text: description }, labelStyle),
                name: "description",
            });
        }
        if (descriptionTextShape) {
            var desTextShapeBBox = descriptionTextShape.getBBox();
            var height = titleRectBox.height + 16 + desTextShapeBBox.height;
            var width = size[0] > desTextShapeBBox.width + 16 ? size[0] : desTextShapeBBox.width + 16;
            shape.attr({ width: width, height: height });
            titleRectShape === null || titleRectShape === void 0 ? void 0 : titleRectShape.attr('width', width);
            markerShape === null || markerShape === void 0 ? void 0 : markerShape.attr({
                x: width - size[0] / 2,
                y: height / 2 - size[1] / 2,
            });
        }
        return shape;
    },
    update: undefined,
}, 'single-node');
es_1.default.registerNode('round-rect', {
    drawShape: function (cfg, group) {
        var color = cfg && cfg.color ? cfg.color : '#5B8FF9';
        var size = cfg && cfg.size ? cfg.size : [100, 30];
        if (typeof size === 'number')
            size = [size, size];
        var style = cfg && cfg.style ? cfg.style : {};
        if (style.stroke)
            color = style.stroke;
        var fill = style && style.fill ? style.fill : '#fff';
        style = Object.assign({
            width: size[0],
            height: size[1],
            radius: size[1] / 2,
            fill: fill,
            lineWidth: 1.2,
            stroke: color,
        }, style);
        var rect = group.addShape('rect', {
            attrs: __assign({ x: -size[0] / 2, y: -size[1] / 2 }, style),
            name: 'rect-shape',
        });
        // circles for anchor points
        group.addShape('circle', {
            attrs: {
                x: -size[0] / 2,
                y: 0,
                r: 3,
                fill: style.stroke,
            },
            name: 'circle-shape',
        });
        group.addShape('circle', {
            attrs: {
                x: size[0] / 2,
                y: 0,
                r: 3,
                fill: style.stroke,
            },
            name: 'circle-shape2',
        });
        return rect;
    },
    getAnchorPoints: function getAnchorPoints() {
        return [
            [0, 0.5],
            [1, 0.5],
        ];
    },
    update: function update(cfg, item) {
        var group = item.getContainer();
        var children = group.get('children');
        var node = children[0];
        var circleLeft = children[1];
        var circleRight = children[2];
        var stroke = cfg.style && cfg.style.stroke ? cfg.style.stroke : '#5B8FF9';
        if (stroke) {
            node.attr('stroke', stroke);
            circleLeft.attr('fill', stroke);
            circleRight.attr('fill', stroke);
        }
    },
}, 'single-node');
var customIconNode = function (params) {
    es_1.default.registerNode('icon-node', {
        options: {
            size: [60, 20],
            stroke: '#91d5ff',
            fill: '#91d5ff',
        },
        draw: function (cfg, group) {
            // @ts-ignore
            var styles = this.getShapeStyle(cfg);
            var _a = cfg.labelCfg, labelCfg = _a === void 0 ? {} : _a;
            var keyShape = group.addShape('rect', {
                attrs: __assign(__assign({}, styles), { x: 0, y: 0 }),
            });
            /**
             * leftIcon 格式如下：
             *  {
             *    style: ShapeStyle;
             *    img: ''
             *  }
             */
            var style = {
                fill: '#e6fffb',
            };
            var img = 'https://g.alicdn.com/cm-design/arms-trace/1.0.155/styles/armsTrace/images/TAIR.png';
            if (cfg.leftIcon) {
                style = Object.assign({}, style, cfg.leftIcon.style);
                img = cfg.leftIcon.img;
            }
            group.addShape('rect', {
                attrs: __assign({ x: 1, y: 1, width: 38, height: styles.height - 2 }, style),
            });
            group.addShape('image', {
                attrs: {
                    x: 8,
                    y: 8,
                    width: 24,
                    height: 24,
                    img: img,
                },
                name: 'image-shape',
            });
            if (params.enableEdit) {
                group.addShape('marker', {
                    attrs: {
                        x: styles.width / 3,
                        y: styles.height + 6,
                        r: 6,
                        stroke: '#73d13d',
                        cursor: 'pointer',
                        symbol: es_1.default.Marker.expand,
                    },
                    name: 'add-item',
                });
                group.addShape('marker', {
                    attrs: {
                        x: (styles.width * 2) / 3,
                        y: styles.height + 6,
                        r: 6,
                        stroke: '#ff4d4f',
                        cursor: 'pointer',
                        symbol: es_1.default.Marker.collapse,
                    },
                    name: 'remove-item',
                });
            }
            if (cfg.label) {
                group.addShape('text', {
                    attrs: __assign(__assign({}, labelCfg.style), { text: cfg.label, x: styles.width / 2, y: styles.height / 1.5 }),
                });
            }
            return keyShape;
        },
    }, 'rect');
};
exports.customIconNode = customIconNode;
es_1.default.registerEdge('fund-polyline', {
    draw: function draw(cfg, group) {
        var startPoint = cfg.startPoint;
        var endPoint = cfg.endPoint;
        var Ydiff = endPoint.y - startPoint.y;
        var slope = Ydiff !== 0 ? 500 / Math.abs(Ydiff) : 0;
        var cpOffset = 16;
        var offset = Ydiff < 0 ? cpOffset : -cpOffset;
        var line1EndPoint = {
            x: startPoint.x + slope,
            y: endPoint.y + offset,
        };
        var line2StartPoint = {
            x: line1EndPoint.x + cpOffset,
            y: endPoint.y,
        };
        // 控制点坐标
        var controlPoint = {
            x: ((line1EndPoint.x - startPoint.x) * (endPoint.y - startPoint.y)) /
                (line1EndPoint.y - startPoint.y) +
                startPoint.x,
            y: endPoint.y,
        };
        var path = [
            ['M', startPoint.x, startPoint.y],
            ['L', line1EndPoint.x, line1EndPoint.y],
            ['Q', controlPoint.x, controlPoint.y, line2StartPoint.x, line2StartPoint.y],
            ['L', endPoint.x, endPoint.y],
        ];
        if (Ydiff === 0) {
            path = [
                ['M', startPoint.x, startPoint.y],
                ['L', endPoint.x, endPoint.y],
            ];
        }
        var style = (cfg || {}).style;
        var line = group.addShape('path', {
            attrs: {
                path: path,
                stroke: style.stroke || (cfg.colorMap && cfg.colorMap[cfg.dataType])
                    ? cfg.colorMap[cfg.dataType]
                    : '#5B8FF9',
                lineWidth: style.lineWidth || 1.2,
                endArrow: false,
            },
            name: 'path-shape',
        });
        var labelLeftOffset = 0;
        var labelTopOffset = 8;
        // label
        var labelTextShape;
        if (cfg.label) {
            labelTextShape = group.addShape('text', {
                attrs: {
                    text: cfg.label,
                    x: line2StartPoint.x + labelLeftOffset,
                    y: endPoint.y - labelTopOffset - 2,
                    fontSize: 14,
                    textAlign: 'left',
                    textBaseline: 'middle',
                    fill: '#000',
                },
                name: 'text-shape-label',
            });
        }
        // dataType
        if (cfg.dataType) {
            var labelTextShapeBBox = labelTextShape ? labelTextShape.getBBox() : { height: 0 };
            group.addShape('text', {
                attrs: {
                    text: cfg.dataType,
                    x: line2StartPoint.x + labelLeftOffset,
                    y: endPoint.y - labelTopOffset - labelTextShapeBBox.height - 2,
                    fontSize: 10,
                    textAlign: 'left',
                    textBaseline: 'middle',
                    fill: '#000',
                },
                name: 'text-shape-type',
            });
        }
        // subLabel
        if (cfg.subLabel) {
            group.addShape('text', {
                attrs: {
                    text: cfg.subLabel,
                    x: line2StartPoint.x + labelLeftOffset,
                    y: endPoint.y + labelTopOffset + 4,
                    fontSize: 12,
                    fontWeight: 300,
                    textAlign: 'left',
                    textBaseline: 'middle',
                    fill: '#000',
                },
                name: 'text-shape-sub-label',
            });
        }
        return line;
    },
    update: undefined,
}, 'single-edge');
es_1.default.registerEdge('flow-line', {
    draw: function (cfg, group) {
        var startPoint = cfg.startPoint;
        var endPoint = cfg.endPoint;
        var _a = cfg.style, style = _a === void 0 ? {} : _a;
        var shape = group.addShape('path', {
            attrs: {
                stroke: style.stroke,
                endArrow: style.endArrow,
                path: [
                    ['M', startPoint.x, startPoint.y],
                    ['L', startPoint.x, (startPoint.y + endPoint.y) / 2],
                    ['L', endPoint.x, (startPoint.y + endPoint.y) / 2],
                    ['L', endPoint.x, endPoint.y],
                ],
            },
        });
        return shape;
    },
});
